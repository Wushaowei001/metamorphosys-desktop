// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AssemblyInterface.proto

#ifndef PROTOBUF_AssemblyInterface_2eproto__INCLUDED
#define PROTOBUF_AssemblyInterface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace edu {
namespace vanderbilt {
namespace isis {
namespace meta {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AssemblyInterface_2eproto();
void protobuf_AssignDesc_AssemblyInterface_2eproto();
void protobuf_ShutdownFile_AssemblyInterface_2eproto();

class AccelerationType;
class AnalysesType;
class AnalysisComponentsType;
class AnalysisConstraintType;
class AnalysisConstraintsType;
class AssembliesType;
class AssemblyType;
class AxialDisplacementType;
class AxialRotationType;
class BallType;
class BallisticType;
class BoundingBoxType;
class CADComponentType;
class CADParameterType;
class CenterOfGravityType;
class ComponentType;
class ComputationsType;
class ConditionType;
class ConditionsType;
class ConnectorDatumType;
class ConnectorType;
class ConstraintFeatureType;
class ConstraintOffsetType;
class ConstraintType;
class DataExchangeType;
class DisplacementType;
class FEAType;
class FeatureType;
class FeaturesType;
class FixedType;
class ForceMomentType;
class ForceType;
class GeometryType;
class InterferenceType;
class KinematicConnectionsType;
class KinematicFeatureType;
class LoadType;
class LoadsType;
class MassType;
class MaterialPropertyType;
class MaterialType;
class MaterialsType;
class MetricType;
class MetricsType;
class MomentType;
class PairType;
class ParametricParametersType;
class PartInterfaceType;
class PartInterfacesType;
class PinType;
class PointCoordinatesType;
class PressureType;
class PrismaticType;
class PropertiesType;
class ReferencePlaneType;
class RevoluteType;
class RotationType;
class STEPFormatType;
class SetOperationType;
class ShotlineType;
class ShotlinesType;
class SolverType;
class SolversType;
class SphericalType;
class SurfaceTreatmentType;
class SurfaceTreatmentsType;
class ToleranceType;
class TranslationType;
class UnassembledComponentsType;
class UnitsType;

enum ConnectorDatumType_AlignType {
  ConnectorDatumType_AlignType_MATE = 0,
  ConnectorDatumType_AlignType_ALIGN = 1
};
bool ConnectorDatumType_AlignType_IsValid(int value);
const ConnectorDatumType_AlignType ConnectorDatumType_AlignType_AlignType_MIN = ConnectorDatumType_AlignType_MATE;
const ConnectorDatumType_AlignType ConnectorDatumType_AlignType_AlignType_MAX = ConnectorDatumType_AlignType_ALIGN;
const int ConnectorDatumType_AlignType_AlignType_ARRAYSIZE = ConnectorDatumType_AlignType_AlignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectorDatumType_AlignType_descriptor();
inline const ::std::string& ConnectorDatumType_AlignType_Name(ConnectorDatumType_AlignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectorDatumType_AlignType_descriptor(), value);
}
inline bool ConnectorDatumType_AlignType_Parse(
    const ::std::string& name, ConnectorDatumType_AlignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectorDatumType_AlignType>(
    ConnectorDatumType_AlignType_descriptor(), name, value);
}
// ===================================================================

class AccelerationType : public ::google::protobuf::Message {
 public:
  AccelerationType();
  virtual ~AccelerationType();

  AccelerationType(const AccelerationType& from);

  inline AccelerationType& operator=(const AccelerationType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationType& default_instance();

  void Swap(AccelerationType* other);

  // implements Message ----------------------------------------------

  AccelerationType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccelerationType& from);
  void MergeFrom(const AccelerationType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 5;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 5;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AccelerationType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AccelerationType* default_instance_;
};
// -------------------------------------------------------------------

class AnalysesType : public ::google::protobuf::Message {
 public:
  AnalysesType();
  virtual ~AnalysesType();

  AnalysesType(const AnalysesType& from);

  inline AnalysesType& operator=(const AnalysesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysesType& default_instance();

  void Swap(AnalysesType* other);

  // implements Message ----------------------------------------------

  AnalysesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalysesType& from);
  void MergeFrom(const AnalysesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.BallisticType Ballistic = 1;
  inline int ballistic_size() const;
  inline void clear_ballistic();
  static const int kBallisticFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::BallisticType& ballistic(int index) const;
  inline ::edu::vanderbilt::isis::meta::BallisticType* mutable_ballistic(int index);
  inline ::edu::vanderbilt::isis::meta::BallisticType* add_ballistic();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BallisticType >&
      ballistic() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BallisticType >*
      mutable_ballistic();

  // repeated .edu.vanderbilt.isis.meta.FEAType FEA = 2;
  inline int fea_size() const;
  inline void clear_fea();
  static const int kFEAFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::FEAType& fea(int index) const;
  inline ::edu::vanderbilt::isis::meta::FEAType* mutable_fea(int index);
  inline ::edu::vanderbilt::isis::meta::FEAType* add_fea();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FEAType >&
      fea() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FEAType >*
      mutable_fea();

  // repeated .edu.vanderbilt.isis.meta.InterferenceType Interference = 3;
  inline int interference_size() const;
  inline void clear_interference();
  static const int kInterferenceFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::InterferenceType& interference(int index) const;
  inline ::edu::vanderbilt::isis::meta::InterferenceType* mutable_interference(int index);
  inline ::edu::vanderbilt::isis::meta::InterferenceType* add_interference();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::InterferenceType >&
      interference() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::InterferenceType >*
      mutable_interference();

  // repeated .edu.vanderbilt.isis.meta.ToleranceType Tolerance = 4;
  inline int tolerance_size() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::ToleranceType& tolerance(int index) const;
  inline ::edu::vanderbilt::isis::meta::ToleranceType* mutable_tolerance(int index);
  inline ::edu::vanderbilt::isis::meta::ToleranceType* add_tolerance();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ToleranceType >&
      tolerance() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ToleranceType >*
      mutable_tolerance();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AnalysesType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BallisticType > ballistic_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FEAType > fea_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::InterferenceType > interference_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ToleranceType > tolerance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AnalysesType* default_instance_;
};
// -------------------------------------------------------------------

class AnalysisComponentsType : public ::google::protobuf::Message {
 public:
  AnalysisComponentsType();
  virtual ~AnalysisComponentsType();

  AnalysisComponentsType(const AnalysisComponentsType& from);

  inline AnalysisComponentsType& operator=(const AnalysisComponentsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisComponentsType& default_instance();

  void Swap(AnalysisComponentsType* other);

  // implements Message ----------------------------------------------

  AnalysisComponentsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalysisComponentsType& from);
  void MergeFrom(const AnalysisComponentsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.ComponentType Component = 1;
  inline int component_size() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ComponentType& component(int index) const;
  inline ::edu::vanderbilt::isis::meta::ComponentType* mutable_component(int index);
  inline ::edu::vanderbilt::isis::meta::ComponentType* add_component();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ComponentType >&
      component() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ComponentType >*
      mutable_component();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AnalysisComponentsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ComponentType > component_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AnalysisComponentsType* default_instance_;
};
// -------------------------------------------------------------------

class AnalysisConstraintType : public ::google::protobuf::Message {
 public:
  AnalysisConstraintType();
  virtual ~AnalysisConstraintType();

  AnalysisConstraintType(const AnalysisConstraintType& from);

  inline AnalysisConstraintType& operator=(const AnalysisConstraintType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisConstraintType& default_instance();

  void Swap(AnalysisConstraintType* other);

  // implements Message ----------------------------------------------

  AnalysisConstraintType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalysisConstraintType& from);
  void MergeFrom(const AnalysisConstraintType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.BallType Ball = 1;
  inline bool has_ball() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::BallType& ball() const;
  inline ::edu::vanderbilt::isis::meta::BallType* mutable_ball();
  inline ::edu::vanderbilt::isis::meta::BallType* release_ball();
  inline void set_allocated_ball(::edu::vanderbilt::isis::meta::BallType* ball);

  // optional .edu.vanderbilt.isis.meta.DisplacementType Displacement = 2;
  inline bool has_displacement() const;
  inline void clear_displacement();
  static const int kDisplacementFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::DisplacementType& displacement() const;
  inline ::edu::vanderbilt::isis::meta::DisplacementType* mutable_displacement();
  inline ::edu::vanderbilt::isis::meta::DisplacementType* release_displacement();
  inline void set_allocated_displacement(::edu::vanderbilt::isis::meta::DisplacementType* displacement);

  // optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 3;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::GeometryType& geometry() const;
  inline ::edu::vanderbilt::isis::meta::GeometryType* mutable_geometry();
  inline ::edu::vanderbilt::isis::meta::GeometryType* release_geometry();
  inline void set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry);

  // optional .edu.vanderbilt.isis.meta.PinType Pin = 4;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::PinType& pin() const;
  inline ::edu::vanderbilt::isis::meta::PinType* mutable_pin();
  inline ::edu::vanderbilt::isis::meta::PinType* release_pin();
  inline void set_allocated_pin(::edu::vanderbilt::isis::meta::PinType* pin);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AnalysisConstraintType)
 private:
  inline void set_has_ball();
  inline void clear_has_ball();
  inline void set_has_displacement();
  inline void clear_has_displacement();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::BallType* ball_;
  ::edu::vanderbilt::isis::meta::DisplacementType* displacement_;
  ::edu::vanderbilt::isis::meta::GeometryType* geometry_;
  ::edu::vanderbilt::isis::meta::PinType* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AnalysisConstraintType* default_instance_;
};
// -------------------------------------------------------------------

class AnalysisConstraintsType : public ::google::protobuf::Message {
 public:
  AnalysisConstraintsType();
  virtual ~AnalysisConstraintsType();

  AnalysisConstraintsType(const AnalysisConstraintsType& from);

  inline AnalysisConstraintsType& operator=(const AnalysisConstraintsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisConstraintsType& default_instance();

  void Swap(AnalysisConstraintsType* other);

  // implements Message ----------------------------------------------

  AnalysisConstraintsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalysisConstraintsType& from);
  void MergeFrom(const AnalysisConstraintsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.AnalysisConstraintType AnalysisConstraint = 1;
  inline int analysisconstraint_size() const;
  inline void clear_analysisconstraint();
  static const int kAnalysisConstraintFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AnalysisConstraintType& analysisconstraint(int index) const;
  inline ::edu::vanderbilt::isis::meta::AnalysisConstraintType* mutable_analysisconstraint(int index);
  inline ::edu::vanderbilt::isis::meta::AnalysisConstraintType* add_analysisconstraint();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AnalysisConstraintType >&
      analysisconstraint() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AnalysisConstraintType >*
      mutable_analysisconstraint();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AnalysisConstraintsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AnalysisConstraintType > analysisconstraint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AnalysisConstraintsType* default_instance_;
};
// -------------------------------------------------------------------

class AssembliesType : public ::google::protobuf::Message {
 public:
  AssembliesType();
  virtual ~AssembliesType();

  AssembliesType(const AssembliesType& from);

  inline AssembliesType& operator=(const AssembliesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssembliesType& default_instance();

  void Swap(AssembliesType* other);

  // implements Message ----------------------------------------------

  AssembliesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssembliesType& from);
  void MergeFrom(const AssembliesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.AssemblyType Assembly = 1;
  inline int assembly_size() const;
  inline void clear_assembly();
  static const int kAssemblyFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AssemblyType& assembly(int index) const;
  inline ::edu::vanderbilt::isis::meta::AssemblyType* mutable_assembly(int index);
  inline ::edu::vanderbilt::isis::meta::AssemblyType* add_assembly();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssemblyType >&
      assembly() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssemblyType >*
      mutable_assembly();

  // optional .edu.vanderbilt.isis.meta.DataExchangeType DataExchange = 2;
  inline bool has_dataexchange() const;
  inline void clear_dataexchange();
  static const int kDataExchangeFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::DataExchangeType& dataexchange() const;
  inline ::edu::vanderbilt::isis::meta::DataExchangeType* mutable_dataexchange();
  inline ::edu::vanderbilt::isis::meta::DataExchangeType* release_dataexchange();
  inline void set_allocated_dataexchange(::edu::vanderbilt::isis::meta::DataExchangeType* dataexchange);

  // repeated .edu.vanderbilt.isis.meta.MaterialsType Materials = 3;
  inline int materials_size() const;
  inline void clear_materials();
  static const int kMaterialsFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::MaterialsType& materials(int index) const;
  inline ::edu::vanderbilt::isis::meta::MaterialsType* mutable_materials(int index);
  inline ::edu::vanderbilt::isis::meta::MaterialsType* add_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialsType >&
      materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialsType >*
      mutable_materials();

  // optional .edu.vanderbilt.isis.meta.UnassembledComponentsType UnassembledComponents = 4;
  inline bool has_unassembledcomponents() const;
  inline void clear_unassembledcomponents();
  static const int kUnassembledComponentsFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::UnassembledComponentsType& unassembledcomponents() const;
  inline ::edu::vanderbilt::isis::meta::UnassembledComponentsType* mutable_unassembledcomponents();
  inline ::edu::vanderbilt::isis::meta::UnassembledComponentsType* release_unassembledcomponents();
  inline void set_allocated_unassembledcomponents(::edu::vanderbilt::isis::meta::UnassembledComponentsType* unassembledcomponents);

  // repeated .edu.vanderbilt.isis.meta.AssembliesType Assemblies = 5;
  inline int assemblies_size() const;
  inline void clear_assemblies();
  static const int kAssembliesFieldNumber = 5;
  inline const ::edu::vanderbilt::isis::meta::AssembliesType& assemblies(int index) const;
  inline ::edu::vanderbilt::isis::meta::AssembliesType* mutable_assemblies(int index);
  inline ::edu::vanderbilt::isis::meta::AssembliesType* add_assemblies();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssembliesType >&
      assemblies() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssembliesType >*
      mutable_assemblies();

  // required string VersionInfo = 6;
  inline bool has_versioninfo() const;
  inline void clear_versioninfo();
  static const int kVersionInfoFieldNumber = 6;
  inline const ::std::string& versioninfo() const;
  inline void set_versioninfo(const ::std::string& value);
  inline void set_versioninfo(const char* value);
  inline void set_versioninfo(const char* value, size_t size);
  inline ::std::string* mutable_versioninfo();
  inline ::std::string* release_versioninfo();
  inline void set_allocated_versioninfo(::std::string* versioninfo);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AssembliesType)
 private:
  inline void set_has_dataexchange();
  inline void clear_has_dataexchange();
  inline void set_has_unassembledcomponents();
  inline void clear_has_unassembledcomponents();
  inline void set_has_versioninfo();
  inline void clear_has_versioninfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssemblyType > assembly_;
  ::edu::vanderbilt::isis::meta::DataExchangeType* dataexchange_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialsType > materials_;
  ::edu::vanderbilt::isis::meta::UnassembledComponentsType* unassembledcomponents_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssembliesType > assemblies_;
  ::std::string* versioninfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AssembliesType* default_instance_;
};
// -------------------------------------------------------------------

class AssemblyType : public ::google::protobuf::Message {
 public:
  AssemblyType();
  virtual ~AssemblyType();

  AssemblyType(const AssemblyType& from);

  inline AssemblyType& operator=(const AssemblyType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssemblyType& default_instance();

  void Swap(AssemblyType* other);

  // implements Message ----------------------------------------------

  AssemblyType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssemblyType& from);
  void MergeFrom(const AssemblyType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.AnalysesType Analyses = 1;
  inline bool has_analyses() const;
  inline void clear_analyses();
  static const int kAnalysesFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AnalysesType& analyses() const;
  inline ::edu::vanderbilt::isis::meta::AnalysesType* mutable_analyses();
  inline ::edu::vanderbilt::isis::meta::AnalysesType* release_analyses();
  inline void set_allocated_analyses(::edu::vanderbilt::isis::meta::AnalysesType* analyses);

  // optional .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 2;
  inline bool has_cadcomponent() const;
  inline void clear_cadcomponent();
  static const int kCADComponentFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::CADComponentType& cadcomponent() const;
  inline ::edu::vanderbilt::isis::meta::CADComponentType* mutable_cadcomponent();
  inline ::edu::vanderbilt::isis::meta::CADComponentType* release_cadcomponent();
  inline void set_allocated_cadcomponent(::edu::vanderbilt::isis::meta::CADComponentType* cadcomponent);

  // optional .edu.vanderbilt.isis.meta.ComputationsType Computations = 3;
  inline bool has_computations() const;
  inline void clear_computations();
  static const int kComputationsFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::ComputationsType& computations() const;
  inline ::edu::vanderbilt::isis::meta::ComputationsType* mutable_computations();
  inline ::edu::vanderbilt::isis::meta::ComputationsType* release_computations();
  inline void set_allocated_computations(::edu::vanderbilt::isis::meta::ComputationsType* computations);

  // required .edu.vanderbilt.isis.meta.PropertiesType Properties = 4;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::PropertiesType& properties() const;
  inline ::edu::vanderbilt::isis::meta::PropertiesType* mutable_properties();
  inline ::edu::vanderbilt::isis::meta::PropertiesType* release_properties();
  inline void set_allocated_properties(::edu::vanderbilt::isis::meta::PropertiesType* properties);

  // required string ConfigurationID = 5;
  inline bool has_configurationid() const;
  inline void clear_configurationid();
  static const int kConfigurationIDFieldNumber = 5;
  inline const ::std::string& configurationid() const;
  inline void set_configurationid(const ::std::string& value);
  inline void set_configurationid(const char* value);
  inline void set_configurationid(const char* value, size_t size);
  inline ::std::string* mutable_configurationid();
  inline ::std::string* release_configurationid();
  inline void set_allocated_configurationid(::std::string* configurationid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AssemblyType)
 private:
  inline void set_has_analyses();
  inline void clear_has_analyses();
  inline void set_has_cadcomponent();
  inline void clear_has_cadcomponent();
  inline void set_has_computations();
  inline void clear_has_computations();
  inline void set_has_properties();
  inline void clear_has_properties();
  inline void set_has_configurationid();
  inline void clear_has_configurationid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::AnalysesType* analyses_;
  ::edu::vanderbilt::isis::meta::CADComponentType* cadcomponent_;
  ::edu::vanderbilt::isis::meta::ComputationsType* computations_;
  ::edu::vanderbilt::isis::meta::PropertiesType* properties_;
  ::std::string* configurationid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AssemblyType* default_instance_;
};
// -------------------------------------------------------------------

class AxialDisplacementType : public ::google::protobuf::Message {
 public:
  AxialDisplacementType();
  virtual ~AxialDisplacementType();

  AxialDisplacementType(const AxialDisplacementType& from);

  inline AxialDisplacementType& operator=(const AxialDisplacementType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxialDisplacementType& default_instance();

  void Swap(AxialDisplacementType* other);

  // implements Message ----------------------------------------------

  AxialDisplacementType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxialDisplacementType& from);
  void MergeFrom(const AxialDisplacementType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Property = 1;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 1;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AxialDisplacementType)
 private:
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AxialDisplacementType* default_instance_;
};
// -------------------------------------------------------------------

class AxialRotationType : public ::google::protobuf::Message {
 public:
  AxialRotationType();
  virtual ~AxialRotationType();

  AxialRotationType(const AxialRotationType& from);

  inline AxialRotationType& operator=(const AxialRotationType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxialRotationType& default_instance();

  void Swap(AxialRotationType* other);

  // implements Message ----------------------------------------------

  AxialRotationType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxialRotationType& from);
  void MergeFrom(const AxialRotationType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Property = 1;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 1;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.AxialRotationType)
 private:
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static AxialRotationType* default_instance_;
};
// -------------------------------------------------------------------

class BallType : public ::google::protobuf::Message {
 public:
  BallType();
  virtual ~BallType();

  BallType(const BallType& from);

  inline BallType& operator=(const BallType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallType& default_instance();

  void Swap(BallType* other);

  // implements Message ----------------------------------------------

  BallType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallType& from);
  void MergeFrom(const BallType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.BallType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static BallType* default_instance_;
};
// -------------------------------------------------------------------

class BallisticType : public ::google::protobuf::Message {
 public:
  BallisticType();
  virtual ~BallisticType();

  BallisticType(const BallisticType& from);

  inline BallisticType& operator=(const BallisticType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallisticType& default_instance();

  void Swap(BallisticType* other);

  // implements Message ----------------------------------------------

  BallisticType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallisticType& from);
  void MergeFrom(const BallisticType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.ReferencePlaneType ReferencePlane = 1;
  inline bool has_referenceplane() const;
  inline void clear_referenceplane();
  static const int kReferencePlaneFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ReferencePlaneType& referenceplane() const;
  inline ::edu::vanderbilt::isis::meta::ReferencePlaneType* mutable_referenceplane();
  inline ::edu::vanderbilt::isis::meta::ReferencePlaneType* release_referenceplane();
  inline void set_allocated_referenceplane(::edu::vanderbilt::isis::meta::ReferencePlaneType* referenceplane);

  // optional .edu.vanderbilt.isis.meta.ShotlinesType Shotlines = 2;
  inline bool has_shotlines() const;
  inline void clear_shotlines();
  static const int kShotlinesFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::ShotlinesType& shotlines() const;
  inline ::edu::vanderbilt::isis::meta::ShotlinesType* mutable_shotlines();
  inline ::edu::vanderbilt::isis::meta::ShotlinesType* release_shotlines();
  inline void set_allocated_shotlines(::edu::vanderbilt::isis::meta::ShotlinesType* shotlines);

  // required string AnalysisID = 3;
  inline bool has_analysisid() const;
  inline void clear_analysisid();
  static const int kAnalysisIDFieldNumber = 3;
  inline const ::std::string& analysisid() const;
  inline void set_analysisid(const ::std::string& value);
  inline void set_analysisid(const char* value);
  inline void set_analysisid(const char* value, size_t size);
  inline ::std::string* mutable_analysisid();
  inline ::std::string* release_analysisid();
  inline void set_allocated_analysisid(::std::string* analysisid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.BallisticType)
 private:
  inline void set_has_referenceplane();
  inline void clear_has_referenceplane();
  inline void set_has_shotlines();
  inline void clear_has_shotlines();
  inline void set_has_analysisid();
  inline void clear_has_analysisid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::ReferencePlaneType* referenceplane_;
  ::edu::vanderbilt::isis::meta::ShotlinesType* shotlines_;
  ::std::string* analysisid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static BallisticType* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBoxType : public ::google::protobuf::Message {
 public:
  BoundingBoxType();
  virtual ~BoundingBoxType();

  BoundingBoxType(const BoundingBoxType& from);

  inline BoundingBoxType& operator=(const BoundingBoxType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBoxType& default_instance();

  void Swap(BoundingBoxType* other);

  // implements Message ----------------------------------------------

  BoundingBoxType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundingBoxType& from);
  void MergeFrom(const BoundingBoxType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string MetricID = 2;
  inline bool has_metricid() const;
  inline void clear_metricid();
  static const int kMetricIDFieldNumber = 2;
  inline const ::std::string& metricid() const;
  inline void set_metricid(const ::std::string& value);
  inline void set_metricid(const char* value);
  inline void set_metricid(const char* value, size_t size);
  inline ::std::string* mutable_metricid();
  inline ::std::string* release_metricid();
  inline void set_allocated_metricid(::std::string* metricid);

  // required string RequestedValueType = 3;
  inline bool has_requestedvaluetype() const;
  inline void clear_requestedvaluetype();
  static const int kRequestedValueTypeFieldNumber = 3;
  inline const ::std::string& requestedvaluetype() const;
  inline void set_requestedvaluetype(const ::std::string& value);
  inline void set_requestedvaluetype(const char* value);
  inline void set_requestedvaluetype(const char* value, size_t size);
  inline ::std::string* mutable_requestedvaluetype();
  inline ::std::string* release_requestedvaluetype();
  inline void set_allocated_requestedvaluetype(::std::string* requestedvaluetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.BoundingBoxType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_metricid();
  inline void clear_has_metricid();
  inline void set_has_requestedvaluetype();
  inline void clear_has_requestedvaluetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* metricid_;
  ::std::string* requestedvaluetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static BoundingBoxType* default_instance_;
};
// -------------------------------------------------------------------

class CADComponentType : public ::google::protobuf::Message {
 public:
  CADComponentType();
  virtual ~CADComponentType();

  CADComponentType(const CADComponentType& from);

  inline CADComponentType& operator=(const CADComponentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CADComponentType& default_instance();

  void Swap(CADComponentType* other);

  // implements Message ----------------------------------------------

  CADComponentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CADComponentType& from);
  void MergeFrom(const CADComponentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 1;
  inline int cadcomponent_size() const;
  inline void clear_cadcomponent();
  static const int kCADComponentFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::CADComponentType& cadcomponent(int index) const;
  inline ::edu::vanderbilt::isis::meta::CADComponentType* mutable_cadcomponent(int index);
  inline ::edu::vanderbilt::isis::meta::CADComponentType* add_cadcomponent();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >&
      cadcomponent() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >*
      mutable_cadcomponent();

  // repeated .edu.vanderbilt.isis.meta.ConstraintType Constraint = 2;
  inline int constraint_size() const;
  inline void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::ConstraintType& constraint(int index) const;
  inline ::edu::vanderbilt::isis::meta::ConstraintType* mutable_constraint(int index);
  inline ::edu::vanderbilt::isis::meta::ConstraintType* add_constraint();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConstraintType >&
      constraint() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConstraintType >*
      mutable_constraint();

  // optional .edu.vanderbilt.isis.meta.KinematicConnectionsType KinematicConnections = 3;
  inline bool has_kinematicconnections() const;
  inline void clear_kinematicconnections();
  static const int kKinematicConnectionsFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::KinematicConnectionsType& kinematicconnections() const;
  inline ::edu::vanderbilt::isis::meta::KinematicConnectionsType* mutable_kinematicconnections();
  inline ::edu::vanderbilt::isis::meta::KinematicConnectionsType* release_kinematicconnections();
  inline void set_allocated_kinematicconnections(::edu::vanderbilt::isis::meta::KinematicConnectionsType* kinematicconnections);

  // optional .edu.vanderbilt.isis.meta.ParametricParametersType ParametricParameters = 4;
  inline bool has_parametricparameters() const;
  inline void clear_parametricparameters();
  static const int kParametricParametersFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::ParametricParametersType& parametricparameters() const;
  inline ::edu::vanderbilt::isis::meta::ParametricParametersType* mutable_parametricparameters();
  inline ::edu::vanderbilt::isis::meta::ParametricParametersType* release_parametricparameters();
  inline void set_allocated_parametricparameters(::edu::vanderbilt::isis::meta::ParametricParametersType* parametricparameters);

  // repeated .edu.vanderbilt.isis.meta.ConnectorType Connectors = 14;
  inline int connectors_size() const;
  inline void clear_connectors();
  static const int kConnectorsFieldNumber = 14;
  inline const ::edu::vanderbilt::isis::meta::ConnectorType& connectors(int index) const;
  inline ::edu::vanderbilt::isis::meta::ConnectorType* mutable_connectors(int index);
  inline ::edu::vanderbilt::isis::meta::ConnectorType* add_connectors();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorType >&
      connectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorType >*
      mutable_connectors();

  // repeated .edu.vanderbilt.isis.meta.ConnectorDatumType Datums = 15;
  inline int datums_size() const;
  inline void clear_datums();
  static const int kDatumsFieldNumber = 15;
  inline const ::edu::vanderbilt::isis::meta::ConnectorDatumType& datums(int index) const;
  inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* mutable_datums(int index);
  inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* add_datums();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >&
      datums() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >*
      mutable_datums();

  // optional string ComponentID = 5;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 5;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // optional string AvmComponentID = 11;
  inline bool has_avmcomponentid() const;
  inline void clear_avmcomponentid();
  static const int kAvmComponentIDFieldNumber = 11;
  inline const ::std::string& avmcomponentid() const;
  inline void set_avmcomponentid(const ::std::string& value);
  inline void set_avmcomponentid(const char* value);
  inline void set_avmcomponentid(const char* value, size_t size);
  inline ::std::string* mutable_avmcomponentid();
  inline ::std::string* release_avmcomponentid();
  inline void set_allocated_avmcomponentid(::std::string* avmcomponentid);

  // optional string MaterialID = 6;
  inline bool has_materialid() const;
  inline void clear_materialid();
  static const int kMaterialIDFieldNumber = 6;
  inline const ::std::string& materialid() const;
  inline void set_materialid(const ::std::string& value);
  inline void set_materialid(const char* value);
  inline void set_materialid(const char* value, size_t size);
  inline ::std::string* mutable_materialid();
  inline ::std::string* release_materialid();
  inline void set_allocated_materialid(::std::string* materialid);

  // optional string Name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string SpecialInstruction = 8;
  inline bool has_specialinstruction() const;
  inline void clear_specialinstruction();
  static const int kSpecialInstructionFieldNumber = 8;
  inline const ::std::string& specialinstruction() const;
  inline void set_specialinstruction(const ::std::string& value);
  inline void set_specialinstruction(const char* value);
  inline void set_specialinstruction(const char* value, size_t size);
  inline ::std::string* mutable_specialinstruction();
  inline ::std::string* release_specialinstruction();
  inline void set_allocated_specialinstruction(::std::string* specialinstruction);

  // optional bool Standalone = 9;
  inline bool has_standalone() const;
  inline void clear_standalone();
  static const int kStandaloneFieldNumber = 9;
  inline bool standalone() const;
  inline void set_standalone(bool value);

  // optional string Type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string CADModelID = 12;
  inline bool has_cadmodelid() const;
  inline void clear_cadmodelid();
  static const int kCADModelIDFieldNumber = 12;
  inline const ::std::string& cadmodelid() const;
  inline void set_cadmodelid(const ::std::string& value);
  inline void set_cadmodelid(const char* value);
  inline void set_cadmodelid(const char* value, size_t size);
  inline ::std::string* mutable_cadmodelid();
  inline ::std::string* release_cadmodelid();
  inline void set_allocated_cadmodelid(::std::string* cadmodelid);

  // optional string DisplayName = 13;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 13;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.CADComponentType)
 private:
  inline void set_has_kinematicconnections();
  inline void clear_has_kinematicconnections();
  inline void set_has_parametricparameters();
  inline void clear_has_parametricparameters();
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_avmcomponentid();
  inline void clear_has_avmcomponentid();
  inline void set_has_materialid();
  inline void clear_has_materialid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_specialinstruction();
  inline void clear_has_specialinstruction();
  inline void set_has_standalone();
  inline void clear_has_standalone();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cadmodelid();
  inline void clear_has_cadmodelid();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType > cadcomponent_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConstraintType > constraint_;
  ::edu::vanderbilt::isis::meta::KinematicConnectionsType* kinematicconnections_;
  ::edu::vanderbilt::isis::meta::ParametricParametersType* parametricparameters_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorType > connectors_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType > datums_;
  ::std::string* componentid_;
  ::std::string* avmcomponentid_;
  ::std::string* materialid_;
  ::std::string* name_;
  ::std::string* specialinstruction_;
  ::std::string* type_;
  ::std::string* cadmodelid_;
  ::std::string* displayname_;
  bool standalone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static CADComponentType* default_instance_;
};
// -------------------------------------------------------------------

class CADParameterType : public ::google::protobuf::Message {
 public:
  CADParameterType();
  virtual ~CADParameterType();

  CADParameterType(const CADParameterType& from);

  inline CADParameterType& operator=(const CADParameterType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CADParameterType& default_instance();

  void Swap(CADParameterType* other);

  // implements Message ----------------------------------------------

  CADParameterType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CADParameterType& from);
  void MergeFrom(const CADParameterType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::UnitsType& units() const;
  inline ::edu::vanderbilt::isis::meta::UnitsType* mutable_units();
  inline ::edu::vanderbilt::isis::meta::UnitsType* release_units();
  inline void set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string Value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.CADParameterType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::UnitsType* units_;
  ::std::string* name_;
  ::std::string* type_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static CADParameterType* default_instance_;
};
// -------------------------------------------------------------------

class CenterOfGravityType : public ::google::protobuf::Message {
 public:
  CenterOfGravityType();
  virtual ~CenterOfGravityType();

  CenterOfGravityType(const CenterOfGravityType& from);

  inline CenterOfGravityType& operator=(const CenterOfGravityType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CenterOfGravityType& default_instance();

  void Swap(CenterOfGravityType* other);

  // implements Message ----------------------------------------------

  CenterOfGravityType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CenterOfGravityType& from);
  void MergeFrom(const CenterOfGravityType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string MetricID = 2;
  inline bool has_metricid() const;
  inline void clear_metricid();
  static const int kMetricIDFieldNumber = 2;
  inline const ::std::string& metricid() const;
  inline void set_metricid(const ::std::string& value);
  inline void set_metricid(const char* value);
  inline void set_metricid(const char* value, size_t size);
  inline ::std::string* mutable_metricid();
  inline ::std::string* release_metricid();
  inline void set_allocated_metricid(::std::string* metricid);

  // required string RequestedValueType = 3;
  inline bool has_requestedvaluetype() const;
  inline void clear_requestedvaluetype();
  static const int kRequestedValueTypeFieldNumber = 3;
  inline const ::std::string& requestedvaluetype() const;
  inline void set_requestedvaluetype(const ::std::string& value);
  inline void set_requestedvaluetype(const char* value);
  inline void set_requestedvaluetype(const char* value, size_t size);
  inline ::std::string* mutable_requestedvaluetype();
  inline ::std::string* release_requestedvaluetype();
  inline void set_allocated_requestedvaluetype(::std::string* requestedvaluetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.CenterOfGravityType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_metricid();
  inline void clear_has_metricid();
  inline void set_has_requestedvaluetype();
  inline void clear_has_requestedvaluetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* metricid_;
  ::std::string* requestedvaluetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static CenterOfGravityType* default_instance_;
};
// -------------------------------------------------------------------

class ComponentType : public ::google::protobuf::Message {
 public:
  ComponentType();
  virtual ~ComponentType();

  ComponentType(const ComponentType& from);

  inline ComponentType& operator=(const ComponentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComponentType& default_instance();

  void Swap(ComponentType* other);

  // implements Message ----------------------------------------------

  ComponentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComponentType& from);
  void MergeFrom(const ComponentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.MetricsType Metrics = 1;
  inline bool has_metrics() const;
  inline void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::MetricsType& metrics() const;
  inline ::edu::vanderbilt::isis::meta::MetricsType* mutable_metrics();
  inline ::edu::vanderbilt::isis::meta::MetricsType* release_metrics();
  inline void set_allocated_metrics(::edu::vanderbilt::isis::meta::MetricsType* metrics);

  // required string ComponentID = 2;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 2;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required bool InfiniteCycle = 3;
  inline bool has_infinitecycle() const;
  inline void clear_infinitecycle();
  static const int kInfiniteCycleFieldNumber = 3;
  inline bool infinitecycle() const;
  inline void set_infinitecycle(bool value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ComponentType)
 private:
  inline void set_has_metrics();
  inline void clear_has_metrics();
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_infinitecycle();
  inline void clear_has_infinitecycle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::MetricsType* metrics_;
  ::std::string* componentid_;
  bool infinitecycle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ComponentType* default_instance_;
};
// -------------------------------------------------------------------

class ComputationsType : public ::google::protobuf::Message {
 public:
  ComputationsType();
  virtual ~ComputationsType();

  ComputationsType(const ComputationsType& from);

  inline ComputationsType& operator=(const ComputationsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputationsType& default_instance();

  void Swap(ComputationsType* other);

  // implements Message ----------------------------------------------

  ComputationsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputationsType& from);
  void MergeFrom(const ComputationsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.BoundingBoxType BoundingBox = 1;
  inline int boundingbox_size() const;
  inline void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::BoundingBoxType& boundingbox(int index) const;
  inline ::edu::vanderbilt::isis::meta::BoundingBoxType* mutable_boundingbox(int index);
  inline ::edu::vanderbilt::isis::meta::BoundingBoxType* add_boundingbox();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BoundingBoxType >&
      boundingbox() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BoundingBoxType >*
      mutable_boundingbox();

  // repeated .edu.vanderbilt.isis.meta.CenterOfGravityType CenterOfGravity = 2;
  inline int centerofgravity_size() const;
  inline void clear_centerofgravity();
  static const int kCenterOfGravityFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::CenterOfGravityType& centerofgravity(int index) const;
  inline ::edu::vanderbilt::isis::meta::CenterOfGravityType* mutable_centerofgravity(int index);
  inline ::edu::vanderbilt::isis::meta::CenterOfGravityType* add_centerofgravity();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CenterOfGravityType >&
      centerofgravity() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CenterOfGravityType >*
      mutable_centerofgravity();

  // repeated .edu.vanderbilt.isis.meta.MassType Mass = 3;
  inline int mass_size() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::MassType& mass(int index) const;
  inline ::edu::vanderbilt::isis::meta::MassType* mutable_mass(int index);
  inline ::edu::vanderbilt::isis::meta::MassType* add_mass();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MassType >&
      mass() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MassType >*
      mutable_mass();

  // repeated .edu.vanderbilt.isis.meta.PointCoordinatesType PointCoordinates = 4;
  inline int pointcoordinates_size() const;
  inline void clear_pointcoordinates();
  static const int kPointCoordinatesFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::PointCoordinatesType& pointcoordinates(int index) const;
  inline ::edu::vanderbilt::isis::meta::PointCoordinatesType* mutable_pointcoordinates(int index);
  inline ::edu::vanderbilt::isis::meta::PointCoordinatesType* add_pointcoordinates();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PointCoordinatesType >&
      pointcoordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PointCoordinatesType >*
      mutable_pointcoordinates();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ComputationsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BoundingBoxType > boundingbox_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CenterOfGravityType > centerofgravity_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MassType > mass_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PointCoordinatesType > pointcoordinates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ComputationsType* default_instance_;
};
// -------------------------------------------------------------------

class ConditionType : public ::google::protobuf::Message {
 public:
  ConditionType();
  virtual ~ConditionType();

  ConditionType(const ConditionType& from);

  inline ConditionType& operator=(const ConditionType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionType& default_instance();

  void Swap(ConditionType* other);

  // implements Message ----------------------------------------------

  ConditionType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionType& from);
  void MergeFrom(const ConditionType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string Units = 2;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 2;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double Value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConditionType)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* units_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConditionType* default_instance_;
};
// -------------------------------------------------------------------

class ConditionsType : public ::google::protobuf::Message {
 public:
  ConditionsType();
  virtual ~ConditionsType();

  ConditionsType(const ConditionsType& from);

  inline ConditionsType& operator=(const ConditionsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionsType& default_instance();

  void Swap(ConditionsType* other);

  // implements Message ----------------------------------------------

  ConditionsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionsType& from);
  void MergeFrom(const ConditionsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.ConditionType Condition = 1;
  inline int condition_size() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ConditionType& condition(int index) const;
  inline ::edu::vanderbilt::isis::meta::ConditionType* mutable_condition(int index);
  inline ::edu::vanderbilt::isis::meta::ConditionType* add_condition();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConditionType >&
      condition() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConditionType >*
      mutable_condition();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConditionsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConditionType > condition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConditionsType* default_instance_;
};
// -------------------------------------------------------------------

class ConnectorDatumType : public ::google::protobuf::Message {
 public:
  ConnectorDatumType();
  virtual ~ConnectorDatumType();

  ConnectorDatumType(const ConnectorDatumType& from);

  inline ConnectorDatumType& operator=(const ConnectorDatumType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectorDatumType& default_instance();

  void Swap(ConnectorDatumType* other);

  // implements Message ----------------------------------------------

  ConnectorDatumType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectorDatumType& from);
  void MergeFrom(const ConnectorDatumType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ConnectorDatumType_AlignType AlignType;
  static const AlignType MATE = ConnectorDatumType_AlignType_MATE;
  static const AlignType ALIGN = ConnectorDatumType_AlignType_ALIGN;
  static inline bool AlignType_IsValid(int value) {
    return ConnectorDatumType_AlignType_IsValid(value);
  }
  static const AlignType AlignType_MIN =
    ConnectorDatumType_AlignType_AlignType_MIN;
  static const AlignType AlignType_MAX =
    ConnectorDatumType_AlignType_AlignType_MAX;
  static const int AlignType_ARRAYSIZE =
    ConnectorDatumType_AlignType_AlignType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AlignType_descriptor() {
    return ConnectorDatumType_AlignType_descriptor();
  }
  static inline const ::std::string& AlignType_Name(AlignType value) {
    return ConnectorDatumType_AlignType_Name(value);
  }
  static inline bool AlignType_Parse(const ::std::string& name,
      AlignType* value) {
    return ConnectorDatumType_AlignType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.ConnectorDatumType.AlignType Alignment = 3;
  inline bool has_alignment() const;
  inline void clear_alignment();
  static const int kAlignmentFieldNumber = 3;
  inline ::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType alignment() const;
  inline void set_alignment(::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType value);

  // optional string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string DisplayName = 2;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConnectorDatumType)
 private:
  inline void set_has_alignment();
  inline void clear_has_alignment();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* displayname_;
  int alignment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConnectorDatumType* default_instance_;
};
// -------------------------------------------------------------------

class ConnectorType : public ::google::protobuf::Message {
 public:
  ConnectorType();
  virtual ~ConnectorType();

  ConnectorType(const ConnectorType& from);

  inline ConnectorType& operator=(const ConnectorType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectorType& default_instance();

  void Swap(ConnectorType* other);

  // implements Message ----------------------------------------------

  ConnectorType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectorType& from);
  void MergeFrom(const ConnectorType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string DisplayName = 2;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // repeated .edu.vanderbilt.isis.meta.ConnectorDatumType Datums = 3;
  inline int datums_size() const;
  inline void clear_datums();
  static const int kDatumsFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::ConnectorDatumType& datums(int index) const;
  inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* mutable_datums(int index);
  inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* add_datums();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >&
      datums() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >*
      mutable_datums();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConnectorType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* displayname_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType > datums_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConnectorType* default_instance_;
};
// -------------------------------------------------------------------

class ConstraintFeatureType : public ::google::protobuf::Message {
 public:
  ConstraintFeatureType();
  virtual ~ConstraintFeatureType();

  ConstraintFeatureType(const ConstraintFeatureType& from);

  inline ConstraintFeatureType& operator=(const ConstraintFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstraintFeatureType& default_instance();

  void Swap(ConstraintFeatureType* other);

  // implements Message ----------------------------------------------

  ConstraintFeatureType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstraintFeatureType& from);
  void MergeFrom(const ConstraintFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string FeatureName = 2;
  inline bool has_featurename() const;
  inline void clear_featurename();
  static const int kFeatureNameFieldNumber = 2;
  inline const ::std::string& featurename() const;
  inline void set_featurename(const ::std::string& value);
  inline void set_featurename(const char* value);
  inline void set_featurename(const char* value, size_t size);
  inline ::std::string* mutable_featurename();
  inline ::std::string* release_featurename();
  inline void set_allocated_featurename(::std::string* featurename);

  // required string FeatureOrientationType = 3;
  inline bool has_featureorientationtype() const;
  inline void clear_featureorientationtype();
  static const int kFeatureOrientationTypeFieldNumber = 3;
  inline const ::std::string& featureorientationtype() const;
  inline void set_featureorientationtype(const ::std::string& value);
  inline void set_featureorientationtype(const char* value);
  inline void set_featureorientationtype(const char* value, size_t size);
  inline ::std::string* mutable_featureorientationtype();
  inline ::std::string* release_featureorientationtype();
  inline void set_allocated_featureorientationtype(::std::string* featureorientationtype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConstraintFeatureType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_featurename();
  inline void clear_has_featurename();
  inline void set_has_featureorientationtype();
  inline void clear_has_featureorientationtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* featurename_;
  ::std::string* featureorientationtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConstraintFeatureType* default_instance_;
};
// -------------------------------------------------------------------

class ConstraintOffsetType : public ::google::protobuf::Message {
 public:
  ConstraintOffsetType();
  virtual ~ConstraintOffsetType();

  ConstraintOffsetType(const ConstraintOffsetType& from);

  inline ConstraintOffsetType& operator=(const ConstraintOffsetType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstraintOffsetType& default_instance();

  void Swap(ConstraintOffsetType* other);

  // implements Message ----------------------------------------------

  ConstraintOffsetType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstraintOffsetType& from);
  void MergeFrom(const ConstraintOffsetType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::UnitsType& units() const;
  inline ::edu::vanderbilt::isis::meta::UnitsType* mutable_units();
  inline ::edu::vanderbilt::isis::meta::UnitsType* release_units();
  inline void set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units);

  // required string OffsetAlignmentType = 2;
  inline bool has_offsetalignmenttype() const;
  inline void clear_offsetalignmenttype();
  static const int kOffsetAlignmentTypeFieldNumber = 2;
  inline const ::std::string& offsetalignmenttype() const;
  inline void set_offsetalignmenttype(const ::std::string& value);
  inline void set_offsetalignmenttype(const char* value);
  inline void set_offsetalignmenttype(const char* value, size_t size);
  inline ::std::string* mutable_offsetalignmenttype();
  inline ::std::string* release_offsetalignmenttype();
  inline void set_allocated_offsetalignmenttype(::std::string* offsetalignmenttype);

  // required double Value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConstraintOffsetType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_offsetalignmenttype();
  inline void clear_has_offsetalignmenttype();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::UnitsType* units_;
  ::std::string* offsetalignmenttype_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConstraintOffsetType* default_instance_;
};
// -------------------------------------------------------------------

class ConstraintType : public ::google::protobuf::Message {
 public:
  ConstraintType();
  virtual ~ConstraintType();

  ConstraintType(const ConstraintType& from);

  inline ConstraintType& operator=(const ConstraintType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstraintType& default_instance();

  void Swap(ConstraintType* other);

  // implements Message ----------------------------------------------

  ConstraintType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstraintType& from);
  void MergeFrom(const ConstraintType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.PairType Pair = 1;
  inline int pair_size() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::PairType& pair(int index) const;
  inline ::edu::vanderbilt::isis::meta::PairType* mutable_pair(int index);
  inline ::edu::vanderbilt::isis::meta::PairType* add_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PairType >&
      pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PairType >*
      mutable_pair();

  // optional string ComponentID = 2;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 2;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ConstraintType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PairType > pair_;
  ::std::string* componentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ConstraintType* default_instance_;
};
// -------------------------------------------------------------------

class DataExchangeType : public ::google::protobuf::Message {
 public:
  DataExchangeType();
  virtual ~DataExchangeType();

  DataExchangeType(const DataExchangeType& from);

  inline DataExchangeType& operator=(const DataExchangeType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataExchangeType& default_instance();

  void Swap(DataExchangeType* other);

  // implements Message ----------------------------------------------

  DataExchangeType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataExchangeType& from);
  void MergeFrom(const DataExchangeType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.STEPFormatType STEPFormat = 1;
  inline int stepformat_size() const;
  inline void clear_stepformat();
  static const int kSTEPFormatFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::STEPFormatType& stepformat(int index) const;
  inline ::edu::vanderbilt::isis::meta::STEPFormatType* mutable_stepformat(int index);
  inline ::edu::vanderbilt::isis::meta::STEPFormatType* add_stepformat();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::STEPFormatType >&
      stepformat() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::STEPFormatType >*
      mutable_stepformat();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.DataExchangeType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::STEPFormatType > stepformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static DataExchangeType* default_instance_;
};
// -------------------------------------------------------------------

class DisplacementType : public ::google::protobuf::Message {
 public:
  DisplacementType();
  virtual ~DisplacementType();

  DisplacementType(const DisplacementType& from);

  inline DisplacementType& operator=(const DisplacementType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisplacementType& default_instance();

  void Swap(DisplacementType* other);

  // implements Message ----------------------------------------------

  DisplacementType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisplacementType& from);
  void MergeFrom(const DisplacementType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .edu.vanderbilt.isis.meta.RotationType Rotation = 1;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::RotationType& rotation() const;
  inline ::edu::vanderbilt::isis::meta::RotationType* mutable_rotation();
  inline ::edu::vanderbilt::isis::meta::RotationType* release_rotation();
  inline void set_allocated_rotation(::edu::vanderbilt::isis::meta::RotationType* rotation);

  // required .edu.vanderbilt.isis.meta.TranslationType Translation = 2;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::TranslationType& translation() const;
  inline ::edu::vanderbilt::isis::meta::TranslationType* mutable_translation();
  inline ::edu::vanderbilt::isis::meta::TranslationType* release_translation();
  inline void set_allocated_translation(::edu::vanderbilt::isis::meta::TranslationType* translation);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.DisplacementType)
 private:
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_translation();
  inline void clear_has_translation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::RotationType* rotation_;
  ::edu::vanderbilt::isis::meta::TranslationType* translation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static DisplacementType* default_instance_;
};
// -------------------------------------------------------------------

class FEAType : public ::google::protobuf::Message {
 public:
  FEAType();
  virtual ~FEAType();

  FEAType(const FEAType& from);

  inline FEAType& operator=(const FEAType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FEAType& default_instance();

  void Swap(FEAType* other);

  // implements Message ----------------------------------------------

  FEAType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FEAType& from);
  void MergeFrom(const FEAType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.AnalysisComponentsType AnalysisComponents = 1;
  inline bool has_analysiscomponents() const;
  inline void clear_analysiscomponents();
  static const int kAnalysisComponentsFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AnalysisComponentsType& analysiscomponents() const;
  inline ::edu::vanderbilt::isis::meta::AnalysisComponentsType* mutable_analysiscomponents();
  inline ::edu::vanderbilt::isis::meta::AnalysisComponentsType* release_analysiscomponents();
  inline void set_allocated_analysiscomponents(::edu::vanderbilt::isis::meta::AnalysisComponentsType* analysiscomponents);

  // optional .edu.vanderbilt.isis.meta.AnalysisConstraintsType AnalysisConstraints = 2;
  inline bool has_analysisconstraints() const;
  inline void clear_analysisconstraints();
  static const int kAnalysisConstraintsFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::AnalysisConstraintsType& analysisconstraints() const;
  inline ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* mutable_analysisconstraints();
  inline ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* release_analysisconstraints();
  inline void set_allocated_analysisconstraints(::edu::vanderbilt::isis::meta::AnalysisConstraintsType* analysisconstraints);

  // optional .edu.vanderbilt.isis.meta.ConditionsType Conditions = 3;
  inline bool has_conditions() const;
  inline void clear_conditions();
  static const int kConditionsFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::ConditionsType& conditions() const;
  inline ::edu::vanderbilt::isis::meta::ConditionsType* mutable_conditions();
  inline ::edu::vanderbilt::isis::meta::ConditionsType* release_conditions();
  inline void set_allocated_conditions(::edu::vanderbilt::isis::meta::ConditionsType* conditions);

  // optional .edu.vanderbilt.isis.meta.LoadsType Loads = 4;
  inline bool has_loads() const;
  inline void clear_loads();
  static const int kLoadsFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::LoadsType& loads() const;
  inline ::edu::vanderbilt::isis::meta::LoadsType* mutable_loads();
  inline ::edu::vanderbilt::isis::meta::LoadsType* release_loads();
  inline void set_allocated_loads(::edu::vanderbilt::isis::meta::LoadsType* loads);

  // optional .edu.vanderbilt.isis.meta.PartInterfacesType PartInterfaces = 5;
  inline bool has_partinterfaces() const;
  inline void clear_partinterfaces();
  static const int kPartInterfacesFieldNumber = 5;
  inline const ::edu::vanderbilt::isis::meta::PartInterfacesType& partinterfaces() const;
  inline ::edu::vanderbilt::isis::meta::PartInterfacesType* mutable_partinterfaces();
  inline ::edu::vanderbilt::isis::meta::PartInterfacesType* release_partinterfaces();
  inline void set_allocated_partinterfaces(::edu::vanderbilt::isis::meta::PartInterfacesType* partinterfaces);

  // required .edu.vanderbilt.isis.meta.SolversType Solvers = 6;
  inline bool has_solvers() const;
  inline void clear_solvers();
  static const int kSolversFieldNumber = 6;
  inline const ::edu::vanderbilt::isis::meta::SolversType& solvers() const;
  inline ::edu::vanderbilt::isis::meta::SolversType* mutable_solvers();
  inline ::edu::vanderbilt::isis::meta::SolversType* release_solvers();
  inline void set_allocated_solvers(::edu::vanderbilt::isis::meta::SolversType* solvers);

  // repeated .edu.vanderbilt.isis.meta.SurfaceTreatmentsType SurfaceTreatments = 7;
  inline int surfacetreatments_size() const;
  inline void clear_surfacetreatments();
  static const int kSurfaceTreatmentsFieldNumber = 7;
  inline const ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType& surfacetreatments(int index) const;
  inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType* mutable_surfacetreatments(int index);
  inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType* add_surfacetreatments();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType >&
      surfacetreatments() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType >*
      mutable_surfacetreatments();

  // required string AnalysisID = 8;
  inline bool has_analysisid() const;
  inline void clear_analysisid();
  static const int kAnalysisIDFieldNumber = 8;
  inline const ::std::string& analysisid() const;
  inline void set_analysisid(const ::std::string& value);
  inline void set_analysisid(const char* value);
  inline void set_analysisid(const char* value, size_t size);
  inline ::std::string* mutable_analysisid();
  inline ::std::string* release_analysisid();
  inline void set_allocated_analysisid(::std::string* analysisid);

  // required string Type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.FEAType)
 private:
  inline void set_has_analysiscomponents();
  inline void clear_has_analysiscomponents();
  inline void set_has_analysisconstraints();
  inline void clear_has_analysisconstraints();
  inline void set_has_conditions();
  inline void clear_has_conditions();
  inline void set_has_loads();
  inline void clear_has_loads();
  inline void set_has_partinterfaces();
  inline void clear_has_partinterfaces();
  inline void set_has_solvers();
  inline void clear_has_solvers();
  inline void set_has_analysisid();
  inline void clear_has_analysisid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::AnalysisComponentsType* analysiscomponents_;
  ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* analysisconstraints_;
  ::edu::vanderbilt::isis::meta::ConditionsType* conditions_;
  ::edu::vanderbilt::isis::meta::LoadsType* loads_;
  ::edu::vanderbilt::isis::meta::PartInterfacesType* partinterfaces_;
  ::edu::vanderbilt::isis::meta::SolversType* solvers_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType > surfacetreatments_;
  ::std::string* analysisid_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static FEAType* default_instance_;
};
// -------------------------------------------------------------------

class FeatureType : public ::google::protobuf::Message {
 public:
  FeatureType();
  virtual ~FeatureType();

  FeatureType(const FeatureType& from);

  inline FeatureType& operator=(const FeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureType& default_instance();

  void Swap(FeatureType* other);

  // implements Message ----------------------------------------------

  FeatureType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureType& from);
  void MergeFrom(const FeatureType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.FeatureType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static FeatureType* default_instance_;
};
// -------------------------------------------------------------------

class FeaturesType : public ::google::protobuf::Message {
 public:
  FeaturesType();
  virtual ~FeaturesType();

  FeaturesType(const FeaturesType& from);

  inline FeaturesType& operator=(const FeaturesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeaturesType& default_instance();

  void Swap(FeaturesType* other);

  // implements Message ----------------------------------------------

  FeaturesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeaturesType& from);
  void MergeFrom(const FeaturesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.FeatureType Feature = 1;
  inline int feature_size() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::FeatureType& feature(int index) const;
  inline ::edu::vanderbilt::isis::meta::FeatureType* mutable_feature(int index);
  inline ::edu::vanderbilt::isis::meta::FeatureType* add_feature();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeatureType >&
      feature() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeatureType >*
      mutable_feature();

  // required string FeatureGeometryType = 2;
  inline bool has_featuregeometrytype() const;
  inline void clear_featuregeometrytype();
  static const int kFeatureGeometryTypeFieldNumber = 2;
  inline const ::std::string& featuregeometrytype() const;
  inline void set_featuregeometrytype(const ::std::string& value);
  inline void set_featuregeometrytype(const char* value);
  inline void set_featuregeometrytype(const char* value, size_t size);
  inline ::std::string* mutable_featuregeometrytype();
  inline ::std::string* release_featuregeometrytype();
  inline void set_allocated_featuregeometrytype(::std::string* featuregeometrytype);

  // required string FeatureID = 3;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 3;
  inline const ::std::string& featureid() const;
  inline void set_featureid(const ::std::string& value);
  inline void set_featureid(const char* value);
  inline void set_featureid(const char* value, size_t size);
  inline ::std::string* mutable_featureid();
  inline ::std::string* release_featureid();
  inline void set_allocated_featureid(::std::string* featureid);

  // required string FeatureInterfaceType = 4;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 4;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // required string GeometryType = 5;
  inline bool has_geometrytype() const;
  inline void clear_geometrytype();
  static const int kGeometryTypeFieldNumber = 5;
  inline const ::std::string& geometrytype() const;
  inline void set_geometrytype(const ::std::string& value);
  inline void set_geometrytype(const char* value);
  inline void set_geometrytype(const char* value, size_t size);
  inline ::std::string* mutable_geometrytype();
  inline ::std::string* release_geometrytype();
  inline void set_allocated_geometrytype(::std::string* geometrytype);

  // required string PrimaryGeometryQualifier = 6;
  inline bool has_primarygeometryqualifier() const;
  inline void clear_primarygeometryqualifier();
  static const int kPrimaryGeometryQualifierFieldNumber = 6;
  inline const ::std::string& primarygeometryqualifier() const;
  inline void set_primarygeometryqualifier(const ::std::string& value);
  inline void set_primarygeometryqualifier(const char* value);
  inline void set_primarygeometryqualifier(const char* value, size_t size);
  inline ::std::string* mutable_primarygeometryqualifier();
  inline ::std::string* release_primarygeometryqualifier();
  inline void set_allocated_primarygeometryqualifier(::std::string* primarygeometryqualifier);

  // required string SecondaryGeometryQualifier = 7;
  inline bool has_secondarygeometryqualifier() const;
  inline void clear_secondarygeometryqualifier();
  static const int kSecondaryGeometryQualifierFieldNumber = 7;
  inline const ::std::string& secondarygeometryqualifier() const;
  inline void set_secondarygeometryqualifier(const ::std::string& value);
  inline void set_secondarygeometryqualifier(const char* value);
  inline void set_secondarygeometryqualifier(const char* value, size_t size);
  inline ::std::string* mutable_secondarygeometryqualifier();
  inline ::std::string* release_secondarygeometryqualifier();
  inline void set_allocated_secondarygeometryqualifier(::std::string* secondarygeometryqualifier);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.FeaturesType)
 private:
  inline void set_has_featuregeometrytype();
  inline void clear_has_featuregeometrytype();
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();
  inline void set_has_geometrytype();
  inline void clear_has_geometrytype();
  inline void set_has_primarygeometryqualifier();
  inline void clear_has_primarygeometryqualifier();
  inline void set_has_secondarygeometryqualifier();
  inline void clear_has_secondarygeometryqualifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeatureType > feature_;
  ::std::string* featuregeometrytype_;
  ::std::string* featureid_;
  ::std::string* featureinterfacetype_;
  ::std::string* geometrytype_;
  ::std::string* primarygeometryqualifier_;
  ::std::string* secondarygeometryqualifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static FeaturesType* default_instance_;
};
// -------------------------------------------------------------------

class FixedType : public ::google::protobuf::Message {
 public:
  FixedType();
  virtual ~FixedType();

  FixedType(const FixedType& from);

  inline FixedType& operator=(const FixedType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedType& default_instance();

  void Swap(FixedType* other);

  // implements Message ----------------------------------------------

  FixedType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixedType& from);
  void MergeFrom(const FixedType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
  inline int kinematicfeature_size() const;
  inline void clear_kinematicfeature();
  static const int kKinematicFeatureFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& kinematicfeature(int index) const;
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* mutable_kinematicfeature(int index);
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* add_kinematicfeature();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
      kinematicfeature() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
      mutable_kinematicfeature();

  // required double CFM = 2;
  inline bool has_cfm() const;
  inline void clear_cfm();
  static const int kCFMFieldNumber = 2;
  inline double cfm() const;
  inline void set_cfm(double value);

  // required string ConnectedComponentID = 3;
  inline bool has_connectedcomponentid() const;
  inline void clear_connectedcomponentid();
  static const int kConnectedComponentIDFieldNumber = 3;
  inline const ::std::string& connectedcomponentid() const;
  inline void set_connectedcomponentid(const ::std::string& value);
  inline void set_connectedcomponentid(const char* value);
  inline void set_connectedcomponentid(const char* value, size_t size);
  inline ::std::string* mutable_connectedcomponentid();
  inline ::std::string* release_connectedcomponentid();
  inline void set_allocated_connectedcomponentid(::std::string* connectedcomponentid);

  // required string ConnectionID = 4;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 4;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // required double ERP = 5;
  inline bool has_erp() const;
  inline void clear_erp();
  static const int kERPFieldNumber = 5;
  inline double erp() const;
  inline void set_erp(double value);

  // required string FeatureInterfaceType = 6;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 6;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.FixedType)
 private:
  inline void set_has_cfm();
  inline void clear_has_cfm();
  inline void set_has_connectedcomponentid();
  inline void clear_has_connectedcomponentid();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_erp();
  inline void clear_has_erp();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType > kinematicfeature_;
  double cfm_;
  ::std::string* connectedcomponentid_;
  ::std::string* connectionid_;
  double erp_;
  ::std::string* featureinterfacetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static FixedType* default_instance_;
};
// -------------------------------------------------------------------

class ForceMomentType : public ::google::protobuf::Message {
 public:
  ForceMomentType();
  virtual ~ForceMomentType();

  ForceMomentType(const ForceMomentType& from);

  inline ForceMomentType& operator=(const ForceMomentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceMomentType& default_instance();

  void Swap(ForceMomentType* other);

  // implements Message ----------------------------------------------

  ForceMomentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceMomentType& from);
  void MergeFrom(const ForceMomentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .edu.vanderbilt.isis.meta.ForceType Force = 1;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ForceType& force() const;
  inline ::edu::vanderbilt::isis::meta::ForceType* mutable_force();
  inline ::edu::vanderbilt::isis::meta::ForceType* release_force();
  inline void set_allocated_force(::edu::vanderbilt::isis::meta::ForceType* force);

  // required .edu.vanderbilt.isis.meta.MomentType Moment = 2;
  inline bool has_moment() const;
  inline void clear_moment();
  static const int kMomentFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::MomentType& moment() const;
  inline ::edu::vanderbilt::isis::meta::MomentType* mutable_moment();
  inline ::edu::vanderbilt::isis::meta::MomentType* release_moment();
  inline void set_allocated_moment(::edu::vanderbilt::isis::meta::MomentType* moment);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ForceMomentType)
 private:
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_moment();
  inline void clear_has_moment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::ForceType* force_;
  ::edu::vanderbilt::isis::meta::MomentType* moment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ForceMomentType* default_instance_;
};
// -------------------------------------------------------------------

class ForceType : public ::google::protobuf::Message {
 public:
  ForceType();
  virtual ~ForceType();

  ForceType(const ForceType& from);

  inline ForceType& operator=(const ForceType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceType& default_instance();

  void Swap(ForceType* other);

  // implements Message ----------------------------------------------

  ForceType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceType& from);
  void MergeFrom(const ForceType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 5;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 5;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ForceType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ForceType* default_instance_;
};
// -------------------------------------------------------------------

class GeometryType : public ::google::protobuf::Message {
 public:
  GeometryType();
  virtual ~GeometryType();

  GeometryType(const GeometryType& from);

  inline GeometryType& operator=(const GeometryType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeometryType& default_instance();

  void Swap(GeometryType* other);

  // implements Message ----------------------------------------------

  GeometryType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeometryType& from);
  void MergeFrom(const GeometryType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.FeaturesType Features = 1;
  inline int features_size() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::FeaturesType& features(int index) const;
  inline ::edu::vanderbilt::isis::meta::FeaturesType* mutable_features(int index);
  inline ::edu::vanderbilt::isis::meta::FeaturesType* add_features();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeaturesType >&
      features() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeaturesType >*
      mutable_features();

  // repeated .edu.vanderbilt.isis.meta.SetOperationType SetOperation = 2;
  inline int setoperation_size() const;
  inline void clear_setoperation();
  static const int kSetOperationFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::SetOperationType& setoperation(int index) const;
  inline ::edu::vanderbilt::isis::meta::SetOperationType* mutable_setoperation(int index);
  inline ::edu::vanderbilt::isis::meta::SetOperationType* add_setoperation();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SetOperationType >&
      setoperation() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SetOperationType >*
      mutable_setoperation();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.GeometryType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeaturesType > features_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SetOperationType > setoperation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static GeometryType* default_instance_;
};
// -------------------------------------------------------------------

class InterferenceType : public ::google::protobuf::Message {
 public:
  InterferenceType();
  virtual ~InterferenceType();

  InterferenceType(const InterferenceType& from);

  inline InterferenceType& operator=(const InterferenceType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterferenceType& default_instance();

  void Swap(InterferenceType* other);

  // implements Message ----------------------------------------------

  InterferenceType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterferenceType& from);
  void MergeFrom(const InterferenceType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string AnalysisID = 1;
  inline bool has_analysisid() const;
  inline void clear_analysisid();
  static const int kAnalysisIDFieldNumber = 1;
  inline const ::std::string& analysisid() const;
  inline void set_analysisid(const ::std::string& value);
  inline void set_analysisid(const char* value);
  inline void set_analysisid(const char* value, size_t size);
  inline ::std::string* mutable_analysisid();
  inline ::std::string* release_analysisid();
  inline void set_allocated_analysisid(::std::string* analysisid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.InterferenceType)
 private:
  inline void set_has_analysisid();
  inline void clear_has_analysisid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* analysisid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static InterferenceType* default_instance_;
};
// -------------------------------------------------------------------

class KinematicConnectionsType : public ::google::protobuf::Message {
 public:
  KinematicConnectionsType();
  virtual ~KinematicConnectionsType();

  KinematicConnectionsType(const KinematicConnectionsType& from);

  inline KinematicConnectionsType& operator=(const KinematicConnectionsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KinematicConnectionsType& default_instance();

  void Swap(KinematicConnectionsType* other);

  // implements Message ----------------------------------------------

  KinematicConnectionsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KinematicConnectionsType& from);
  void MergeFrom(const KinematicConnectionsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.FixedType Fixed = 1;
  inline int fixed_size() const;
  inline void clear_fixed();
  static const int kFixedFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::FixedType& fixed(int index) const;
  inline ::edu::vanderbilt::isis::meta::FixedType* mutable_fixed(int index);
  inline ::edu::vanderbilt::isis::meta::FixedType* add_fixed();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FixedType >&
      fixed() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FixedType >*
      mutable_fixed();

  // repeated .edu.vanderbilt.isis.meta.PrismaticType Prismatic = 2;
  inline int prismatic_size() const;
  inline void clear_prismatic();
  static const int kPrismaticFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::PrismaticType& prismatic(int index) const;
  inline ::edu::vanderbilt::isis::meta::PrismaticType* mutable_prismatic(int index);
  inline ::edu::vanderbilt::isis::meta::PrismaticType* add_prismatic();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PrismaticType >&
      prismatic() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PrismaticType >*
      mutable_prismatic();

  // repeated .edu.vanderbilt.isis.meta.RevoluteType Revolute = 3;
  inline int revolute_size() const;
  inline void clear_revolute();
  static const int kRevoluteFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::RevoluteType& revolute(int index) const;
  inline ::edu::vanderbilt::isis::meta::RevoluteType* mutable_revolute(int index);
  inline ::edu::vanderbilt::isis::meta::RevoluteType* add_revolute();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::RevoluteType >&
      revolute() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::RevoluteType >*
      mutable_revolute();

  // repeated .edu.vanderbilt.isis.meta.SphericalType Spherical = 4;
  inline int spherical_size() const;
  inline void clear_spherical();
  static const int kSphericalFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::SphericalType& spherical(int index) const;
  inline ::edu::vanderbilt::isis::meta::SphericalType* mutable_spherical(int index);
  inline ::edu::vanderbilt::isis::meta::SphericalType* add_spherical();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SphericalType >&
      spherical() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SphericalType >*
      mutable_spherical();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.KinematicConnectionsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FixedType > fixed_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PrismaticType > prismatic_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::RevoluteType > revolute_;
  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SphericalType > spherical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static KinematicConnectionsType* default_instance_;
};
// -------------------------------------------------------------------

class KinematicFeatureType : public ::google::protobuf::Message {
 public:
  KinematicFeatureType();
  virtual ~KinematicFeatureType();

  KinematicFeatureType(const KinematicFeatureType& from);

  inline KinematicFeatureType& operator=(const KinematicFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KinematicFeatureType& default_instance();

  void Swap(KinematicFeatureType* other);

  // implements Message ----------------------------------------------

  KinematicFeatureType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KinematicFeatureType& from);
  void MergeFrom(const KinematicFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string DatumName = 2;
  inline bool has_datumname() const;
  inline void clear_datumname();
  static const int kDatumNameFieldNumber = 2;
  inline const ::std::string& datumname() const;
  inline void set_datumname(const ::std::string& value);
  inline void set_datumname(const char* value);
  inline void set_datumname(const char* value, size_t size);
  inline ::std::string* mutable_datumname();
  inline ::std::string* release_datumname();
  inline void set_allocated_datumname(::std::string* datumname);

  // required string FeatureGeometryType = 3;
  inline bool has_featuregeometrytype() const;
  inline void clear_featuregeometrytype();
  static const int kFeatureGeometryTypeFieldNumber = 3;
  inline const ::std::string& featuregeometrytype() const;
  inline void set_featuregeometrytype(const ::std::string& value);
  inline void set_featuregeometrytype(const char* value);
  inline void set_featuregeometrytype(const char* value, size_t size);
  inline ::std::string* mutable_featuregeometrytype();
  inline ::std::string* release_featuregeometrytype();
  inline void set_allocated_featuregeometrytype(::std::string* featuregeometrytype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.KinematicFeatureType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_datumname();
  inline void clear_has_datumname();
  inline void set_has_featuregeometrytype();
  inline void clear_has_featuregeometrytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* datumname_;
  ::std::string* featuregeometrytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static KinematicFeatureType* default_instance_;
};
// -------------------------------------------------------------------

class LoadType : public ::google::protobuf::Message {
 public:
  LoadType();
  virtual ~LoadType();

  LoadType(const LoadType& from);

  inline LoadType& operator=(const LoadType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadType& default_instance();

  void Swap(LoadType* other);

  // implements Message ----------------------------------------------

  LoadType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadType& from);
  void MergeFrom(const LoadType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.AccelerationType Acceleration = 1;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AccelerationType& acceleration() const;
  inline ::edu::vanderbilt::isis::meta::AccelerationType* mutable_acceleration();
  inline ::edu::vanderbilt::isis::meta::AccelerationType* release_acceleration();
  inline void set_allocated_acceleration(::edu::vanderbilt::isis::meta::AccelerationType* acceleration);

  // optional .edu.vanderbilt.isis.meta.ForceMomentType ForceMoment = 2;
  inline bool has_forcemoment() const;
  inline void clear_forcemoment();
  static const int kForceMomentFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::ForceMomentType& forcemoment() const;
  inline ::edu::vanderbilt::isis::meta::ForceMomentType* mutable_forcemoment();
  inline ::edu::vanderbilt::isis::meta::ForceMomentType* release_forcemoment();
  inline void set_allocated_forcemoment(::edu::vanderbilt::isis::meta::ForceMomentType* forcemoment);

  // optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 3;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::GeometryType& geometry() const;
  inline ::edu::vanderbilt::isis::meta::GeometryType* mutable_geometry();
  inline ::edu::vanderbilt::isis::meta::GeometryType* release_geometry();
  inline void set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry);

  // optional .edu.vanderbilt.isis.meta.PressureType Pressure = 4;
  inline bool has_pressure() const;
  inline void clear_pressure();
  static const int kPressureFieldNumber = 4;
  inline const ::edu::vanderbilt::isis::meta::PressureType& pressure() const;
  inline ::edu::vanderbilt::isis::meta::PressureType* mutable_pressure();
  inline ::edu::vanderbilt::isis::meta::PressureType* release_pressure();
  inline void set_allocated_pressure(::edu::vanderbilt::isis::meta::PressureType* pressure);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.LoadType)
 private:
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_forcemoment();
  inline void clear_has_forcemoment();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_pressure();
  inline void clear_has_pressure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::AccelerationType* acceleration_;
  ::edu::vanderbilt::isis::meta::ForceMomentType* forcemoment_;
  ::edu::vanderbilt::isis::meta::GeometryType* geometry_;
  ::edu::vanderbilt::isis::meta::PressureType* pressure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static LoadType* default_instance_;
};
// -------------------------------------------------------------------

class LoadsType : public ::google::protobuf::Message {
 public:
  LoadsType();
  virtual ~LoadsType();

  LoadsType(const LoadsType& from);

  inline LoadsType& operator=(const LoadsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadsType& default_instance();

  void Swap(LoadsType* other);

  // implements Message ----------------------------------------------

  LoadsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadsType& from);
  void MergeFrom(const LoadsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.LoadType Load = 1;
  inline int load_size() const;
  inline void clear_load();
  static const int kLoadFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::LoadType& load(int index) const;
  inline ::edu::vanderbilt::isis::meta::LoadType* mutable_load(int index);
  inline ::edu::vanderbilt::isis::meta::LoadType* add_load();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::LoadType >&
      load() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::LoadType >*
      mutable_load();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.LoadsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::LoadType > load_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static LoadsType* default_instance_;
};
// -------------------------------------------------------------------

class MassType : public ::google::protobuf::Message {
 public:
  MassType();
  virtual ~MassType();

  MassType(const MassType& from);

  inline MassType& operator=(const MassType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassType& default_instance();

  void Swap(MassType* other);

  // implements Message ----------------------------------------------

  MassType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassType& from);
  void MergeFrom(const MassType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string MetricID = 2;
  inline bool has_metricid() const;
  inline void clear_metricid();
  static const int kMetricIDFieldNumber = 2;
  inline const ::std::string& metricid() const;
  inline void set_metricid(const ::std::string& value);
  inline void set_metricid(const char* value);
  inline void set_metricid(const char* value, size_t size);
  inline ::std::string* mutable_metricid();
  inline ::std::string* release_metricid();
  inline void set_allocated_metricid(::std::string* metricid);

  // required string RequestedValueType = 3;
  inline bool has_requestedvaluetype() const;
  inline void clear_requestedvaluetype();
  static const int kRequestedValueTypeFieldNumber = 3;
  inline const ::std::string& requestedvaluetype() const;
  inline void set_requestedvaluetype(const ::std::string& value);
  inline void set_requestedvaluetype(const char* value);
  inline void set_requestedvaluetype(const char* value, size_t size);
  inline ::std::string* mutable_requestedvaluetype();
  inline ::std::string* release_requestedvaluetype();
  inline void set_allocated_requestedvaluetype(::std::string* requestedvaluetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MassType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_metricid();
  inline void clear_has_metricid();
  inline void set_has_requestedvaluetype();
  inline void clear_has_requestedvaluetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* metricid_;
  ::std::string* requestedvaluetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MassType* default_instance_;
};
// -------------------------------------------------------------------

class MaterialPropertyType : public ::google::protobuf::Message {
 public:
  MaterialPropertyType();
  virtual ~MaterialPropertyType();

  MaterialPropertyType(const MaterialPropertyType& from);

  inline MaterialPropertyType& operator=(const MaterialPropertyType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialPropertyType& default_instance();

  void Swap(MaterialPropertyType* other);

  // implements Message ----------------------------------------------

  MaterialPropertyType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialPropertyType& from);
  void MergeFrom(const MaterialPropertyType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PropertyName = 1;
  inline bool has_propertyname() const;
  inline void clear_propertyname();
  static const int kPropertyNameFieldNumber = 1;
  inline const ::std::string& propertyname() const;
  inline void set_propertyname(const ::std::string& value);
  inline void set_propertyname(const char* value);
  inline void set_propertyname(const char* value, size_t size);
  inline ::std::string* mutable_propertyname();
  inline ::std::string* release_propertyname();
  inline void set_allocated_propertyname(::std::string* propertyname);

  // required string Units = 2;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 2;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double Value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MaterialPropertyType)
 private:
  inline void set_has_propertyname();
  inline void clear_has_propertyname();
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* propertyname_;
  ::std::string* units_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MaterialPropertyType* default_instance_;
};
// -------------------------------------------------------------------

class MaterialType : public ::google::protobuf::Message {
 public:
  MaterialType();
  virtual ~MaterialType();

  MaterialType(const MaterialType& from);

  inline MaterialType& operator=(const MaterialType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialType& default_instance();

  void Swap(MaterialType* other);

  // implements Message ----------------------------------------------

  MaterialType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialType& from);
  void MergeFrom(const MaterialType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.MaterialPropertyType MaterialProperty = 1;
  inline int materialproperty_size() const;
  inline void clear_materialproperty();
  static const int kMaterialPropertyFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::MaterialPropertyType& materialproperty(int index) const;
  inline ::edu::vanderbilt::isis::meta::MaterialPropertyType* mutable_materialproperty(int index);
  inline ::edu::vanderbilt::isis::meta::MaterialPropertyType* add_materialproperty();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialPropertyType >&
      materialproperty() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialPropertyType >*
      mutable_materialproperty();

  // required string MaterialID = 2;
  inline bool has_materialid() const;
  inline void clear_materialid();
  static const int kMaterialIDFieldNumber = 2;
  inline const ::std::string& materialid() const;
  inline void set_materialid(const ::std::string& value);
  inline void set_materialid(const char* value);
  inline void set_materialid(const char* value, size_t size);
  inline ::std::string* mutable_materialid();
  inline ::std::string* release_materialid();
  inline void set_allocated_materialid(::std::string* materialid);

  // required string MaterialName = 3;
  inline bool has_materialname() const;
  inline void clear_materialname();
  static const int kMaterialNameFieldNumber = 3;
  inline const ::std::string& materialname() const;
  inline void set_materialname(const ::std::string& value);
  inline void set_materialname(const char* value);
  inline void set_materialname(const char* value, size_t size);
  inline ::std::string* mutable_materialname();
  inline ::std::string* release_materialname();
  inline void set_allocated_materialname(::std::string* materialname);

  // required string Type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MaterialType)
 private:
  inline void set_has_materialid();
  inline void clear_has_materialid();
  inline void set_has_materialname();
  inline void clear_has_materialname();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialPropertyType > materialproperty_;
  ::std::string* materialid_;
  ::std::string* materialname_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MaterialType* default_instance_;
};
// -------------------------------------------------------------------

class MaterialsType : public ::google::protobuf::Message {
 public:
  MaterialsType();
  virtual ~MaterialsType();

  MaterialsType(const MaterialsType& from);

  inline MaterialsType& operator=(const MaterialsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialsType& default_instance();

  void Swap(MaterialsType* other);

  // implements Message ----------------------------------------------

  MaterialsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialsType& from);
  void MergeFrom(const MaterialsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.MaterialType Material = 1;
  inline int material_size() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::MaterialType& material(int index) const;
  inline ::edu::vanderbilt::isis::meta::MaterialType* mutable_material(int index);
  inline ::edu::vanderbilt::isis::meta::MaterialType* add_material();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialType >&
      material() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialType >*
      mutable_material();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MaterialsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialType > material_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MaterialsType* default_instance_;
};
// -------------------------------------------------------------------

class MetricType : public ::google::protobuf::Message {
 public:
  MetricType();
  virtual ~MetricType();

  MetricType(const MetricType& from);

  inline MetricType& operator=(const MetricType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricType& default_instance();

  void Swap(MetricType* other);

  // implements Message ----------------------------------------------

  MetricType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetricType& from);
  void MergeFrom(const MetricType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MetricType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MetricType* default_instance_;
};
// -------------------------------------------------------------------

class MetricsType : public ::google::protobuf::Message {
 public:
  MetricsType();
  virtual ~MetricsType();

  MetricsType(const MetricsType& from);

  inline MetricsType& operator=(const MetricsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricsType& default_instance();

  void Swap(MetricsType* other);

  // implements Message ----------------------------------------------

  MetricsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetricsType& from);
  void MergeFrom(const MetricsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.MetricType Metric = 1;
  inline int metric_size() const;
  inline void clear_metric();
  static const int kMetricFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::MetricType& metric(int index) const;
  inline ::edu::vanderbilt::isis::meta::MetricType* mutable_metric(int index);
  inline ::edu::vanderbilt::isis::meta::MetricType* add_metric();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MetricType >&
      metric() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MetricType >*
      mutable_metric();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MetricsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MetricType > metric_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MetricsType* default_instance_;
};
// -------------------------------------------------------------------

class MomentType : public ::google::protobuf::Message {
 public:
  MomentType();
  virtual ~MomentType();

  MomentType(const MomentType& from);

  inline MomentType& operator=(const MomentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MomentType& default_instance();

  void Swap(MomentType* other);

  // implements Message ----------------------------------------------

  MomentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MomentType& from);
  void MergeFrom(const MomentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 5;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 5;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.MomentType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static MomentType* default_instance_;
};
// -------------------------------------------------------------------

class PairType : public ::google::protobuf::Message {
 public:
  PairType();
  virtual ~PairType();

  PairType(const PairType& from);

  inline PairType& operator=(const PairType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PairType& default_instance();

  void Swap(PairType* other);

  // implements Message ----------------------------------------------

  PairType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PairType& from);
  void MergeFrom(const PairType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .edu.vanderbilt.isis.meta.ConstraintFeatureType ConstraintFeatureA = 1;
  inline bool has_constraintfeaturea() const;
  inline void clear_constraintfeaturea();
  static const int kConstraintFeatureAFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ConstraintFeatureType& constraintfeaturea() const;
  inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* mutable_constraintfeaturea();
  inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* release_constraintfeaturea();
  inline void set_allocated_constraintfeaturea(::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeaturea);

  // required .edu.vanderbilt.isis.meta.ConstraintFeatureType ConstraintFeatureB = 2;
  inline bool has_constraintfeatureb() const;
  inline void clear_constraintfeatureb();
  static const int kConstraintFeatureBFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::ConstraintFeatureType& constraintfeatureb() const;
  inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* mutable_constraintfeatureb();
  inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* release_constraintfeatureb();
  inline void set_allocated_constraintfeatureb(::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeatureb);

  // optional .edu.vanderbilt.isis.meta.ConstraintOffsetType ConstraintOffset = 3;
  inline bool has_constraintoffset() const;
  inline void clear_constraintoffset();
  static const int kConstraintOffsetFieldNumber = 3;
  inline const ::edu::vanderbilt::isis::meta::ConstraintOffsetType& constraintoffset() const;
  inline ::edu::vanderbilt::isis::meta::ConstraintOffsetType* mutable_constraintoffset();
  inline ::edu::vanderbilt::isis::meta::ConstraintOffsetType* release_constraintoffset();
  inline void set_allocated_constraintoffset(::edu::vanderbilt::isis::meta::ConstraintOffsetType* constraintoffset);

  // required string FeatureAlignmentType = 4;
  inline bool has_featurealignmenttype() const;
  inline void clear_featurealignmenttype();
  static const int kFeatureAlignmentTypeFieldNumber = 4;
  inline const ::std::string& featurealignmenttype() const;
  inline void set_featurealignmenttype(const ::std::string& value);
  inline void set_featurealignmenttype(const char* value);
  inline void set_featurealignmenttype(const char* value, size_t size);
  inline ::std::string* mutable_featurealignmenttype();
  inline ::std::string* release_featurealignmenttype();
  inline void set_allocated_featurealignmenttype(::std::string* featurealignmenttype);

  // required string FeatureGeometryType = 5;
  inline bool has_featuregeometrytype() const;
  inline void clear_featuregeometrytype();
  static const int kFeatureGeometryTypeFieldNumber = 5;
  inline const ::std::string& featuregeometrytype() const;
  inline void set_featuregeometrytype(const ::std::string& value);
  inline void set_featuregeometrytype(const char* value);
  inline void set_featuregeometrytype(const char* value, size_t size);
  inline ::std::string* mutable_featuregeometrytype();
  inline ::std::string* release_featuregeometrytype();
  inline void set_allocated_featuregeometrytype(::std::string* featuregeometrytype);

  // required string FeatureInterfaceType = 6;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 6;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PairType)
 private:
  inline void set_has_constraintfeaturea();
  inline void clear_has_constraintfeaturea();
  inline void set_has_constraintfeatureb();
  inline void clear_has_constraintfeatureb();
  inline void set_has_constraintoffset();
  inline void clear_has_constraintoffset();
  inline void set_has_featurealignmenttype();
  inline void clear_has_featurealignmenttype();
  inline void set_has_featuregeometrytype();
  inline void clear_has_featuregeometrytype();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeaturea_;
  ::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeatureb_;
  ::edu::vanderbilt::isis::meta::ConstraintOffsetType* constraintoffset_;
  ::std::string* featurealignmenttype_;
  ::std::string* featuregeometrytype_;
  ::std::string* featureinterfacetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PairType* default_instance_;
};
// -------------------------------------------------------------------

class ParametricParametersType : public ::google::protobuf::Message {
 public:
  ParametricParametersType();
  virtual ~ParametricParametersType();

  ParametricParametersType(const ParametricParametersType& from);

  inline ParametricParametersType& operator=(const ParametricParametersType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParametricParametersType& default_instance();

  void Swap(ParametricParametersType* other);

  // implements Message ----------------------------------------------

  ParametricParametersType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParametricParametersType& from);
  void MergeFrom(const ParametricParametersType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.CADParameterType CADParameter = 1;
  inline int cadparameter_size() const;
  inline void clear_cadparameter();
  static const int kCADParameterFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::CADParameterType& cadparameter(int index) const;
  inline ::edu::vanderbilt::isis::meta::CADParameterType* mutable_cadparameter(int index);
  inline ::edu::vanderbilt::isis::meta::CADParameterType* add_cadparameter();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADParameterType >&
      cadparameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADParameterType >*
      mutable_cadparameter();

  // optional string ComponentID = 2;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 2;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ParametricParametersType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADParameterType > cadparameter_;
  ::std::string* componentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ParametricParametersType* default_instance_;
};
// -------------------------------------------------------------------

class PartInterfaceType : public ::google::protobuf::Message {
 public:
  PartInterfaceType();
  virtual ~PartInterfaceType();

  PartInterfaceType(const PartInterfaceType& from);

  inline PartInterfaceType& operator=(const PartInterfaceType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartInterfaceType& default_instance();

  void Swap(PartInterfaceType* other);

  // implements Message ----------------------------------------------

  PartInterfaceType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartInterfaceType& from);
  void MergeFrom(const PartInterfaceType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID_1 = 1;
  inline bool has_componentid_1() const;
  inline void clear_componentid_1();
  static const int kComponentID1FieldNumber = 1;
  inline const ::std::string& componentid_1() const;
  inline void set_componentid_1(const ::std::string& value);
  inline void set_componentid_1(const char* value);
  inline void set_componentid_1(const char* value, size_t size);
  inline ::std::string* mutable_componentid_1();
  inline ::std::string* release_componentid_1();
  inline void set_allocated_componentid_1(::std::string* componentid_1);

  // required string ComponentID_2 = 2;
  inline bool has_componentid_2() const;
  inline void clear_componentid_2();
  static const int kComponentID2FieldNumber = 2;
  inline const ::std::string& componentid_2() const;
  inline void set_componentid_2(const ::std::string& value);
  inline void set_componentid_2(const char* value);
  inline void set_componentid_2(const char* value, size_t size);
  inline ::std::string* mutable_componentid_2();
  inline ::std::string* release_componentid_2();
  inline void set_allocated_componentid_2(::std::string* componentid_2);

  // required string Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PartInterfaceType)
 private:
  inline void set_has_componentid_1();
  inline void clear_has_componentid_1();
  inline void set_has_componentid_2();
  inline void clear_has_componentid_2();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_1_;
  ::std::string* componentid_2_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PartInterfaceType* default_instance_;
};
// -------------------------------------------------------------------

class PartInterfacesType : public ::google::protobuf::Message {
 public:
  PartInterfacesType();
  virtual ~PartInterfacesType();

  PartInterfacesType(const PartInterfacesType& from);

  inline PartInterfacesType& operator=(const PartInterfacesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartInterfacesType& default_instance();

  void Swap(PartInterfacesType* other);

  // implements Message ----------------------------------------------

  PartInterfacesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartInterfacesType& from);
  void MergeFrom(const PartInterfacesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.PartInterfaceType PartInterface = 1;
  inline int partinterface_size() const;
  inline void clear_partinterface();
  static const int kPartInterfaceFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::PartInterfaceType& partinterface(int index) const;
  inline ::edu::vanderbilt::isis::meta::PartInterfaceType* mutable_partinterface(int index);
  inline ::edu::vanderbilt::isis::meta::PartInterfaceType* add_partinterface();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PartInterfaceType >&
      partinterface() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PartInterfaceType >*
      mutable_partinterface();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PartInterfacesType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PartInterfaceType > partinterface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PartInterfacesType* default_instance_;
};
// -------------------------------------------------------------------

class PinType : public ::google::protobuf::Message {
 public:
  PinType();
  virtual ~PinType();

  PinType(const PinType& from);

  inline PinType& operator=(const PinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinType& default_instance();

  void Swap(PinType* other);

  // implements Message ----------------------------------------------

  PinType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinType& from);
  void MergeFrom(const PinType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .edu.vanderbilt.isis.meta.AxialDisplacementType AxialDisplacement = 1;
  inline bool has_axialdisplacement() const;
  inline void clear_axialdisplacement();
  static const int kAxialDisplacementFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::AxialDisplacementType& axialdisplacement() const;
  inline ::edu::vanderbilt::isis::meta::AxialDisplacementType* mutable_axialdisplacement();
  inline ::edu::vanderbilt::isis::meta::AxialDisplacementType* release_axialdisplacement();
  inline void set_allocated_axialdisplacement(::edu::vanderbilt::isis::meta::AxialDisplacementType* axialdisplacement);

  // required .edu.vanderbilt.isis.meta.AxialRotationType AxialRotation = 2;
  inline bool has_axialrotation() const;
  inline void clear_axialrotation();
  static const int kAxialRotationFieldNumber = 2;
  inline const ::edu::vanderbilt::isis::meta::AxialRotationType& axialrotation() const;
  inline ::edu::vanderbilt::isis::meta::AxialRotationType* mutable_axialrotation();
  inline ::edu::vanderbilt::isis::meta::AxialRotationType* release_axialrotation();
  inline void set_allocated_axialrotation(::edu::vanderbilt::isis::meta::AxialRotationType* axialrotation);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PinType)
 private:
  inline void set_has_axialdisplacement();
  inline void clear_has_axialdisplacement();
  inline void set_has_axialrotation();
  inline void clear_has_axialrotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::AxialDisplacementType* axialdisplacement_;
  ::edu::vanderbilt::isis::meta::AxialRotationType* axialrotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PinType* default_instance_;
};
// -------------------------------------------------------------------

class PointCoordinatesType : public ::google::protobuf::Message {
 public:
  PointCoordinatesType();
  virtual ~PointCoordinatesType();

  PointCoordinatesType(const PointCoordinatesType& from);

  inline PointCoordinatesType& operator=(const PointCoordinatesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCoordinatesType& default_instance();

  void Swap(PointCoordinatesType* other);

  // implements Message ----------------------------------------------

  PointCoordinatesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCoordinatesType& from);
  void MergeFrom(const PointCoordinatesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ComponentID = 1;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 1;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string FeatureDatumName = 2;
  inline bool has_featuredatumname() const;
  inline void clear_featuredatumname();
  static const int kFeatureDatumNameFieldNumber = 2;
  inline const ::std::string& featuredatumname() const;
  inline void set_featuredatumname(const ::std::string& value);
  inline void set_featuredatumname(const char* value);
  inline void set_featuredatumname(const char* value, size_t size);
  inline ::std::string* mutable_featuredatumname();
  inline ::std::string* release_featuredatumname();
  inline void set_allocated_featuredatumname(::std::string* featuredatumname);

  // required string MetricID = 3;
  inline bool has_metricid() const;
  inline void clear_metricid();
  static const int kMetricIDFieldNumber = 3;
  inline const ::std::string& metricid() const;
  inline void set_metricid(const ::std::string& value);
  inline void set_metricid(const char* value);
  inline void set_metricid(const char* value, size_t size);
  inline ::std::string* mutable_metricid();
  inline ::std::string* release_metricid();
  inline void set_allocated_metricid(::std::string* metricid);

  // required string RequestedValueType = 4;
  inline bool has_requestedvaluetype() const;
  inline void clear_requestedvaluetype();
  static const int kRequestedValueTypeFieldNumber = 4;
  inline const ::std::string& requestedvaluetype() const;
  inline void set_requestedvaluetype(const ::std::string& value);
  inline void set_requestedvaluetype(const char* value);
  inline void set_requestedvaluetype(const char* value, size_t size);
  inline ::std::string* mutable_requestedvaluetype();
  inline ::std::string* release_requestedvaluetype();
  inline void set_allocated_requestedvaluetype(::std::string* requestedvaluetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PointCoordinatesType)
 private:
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_featuredatumname();
  inline void clear_has_featuredatumname();
  inline void set_has_metricid();
  inline void clear_has_metricid();
  inline void set_has_requestedvaluetype();
  inline void clear_has_requestedvaluetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* componentid_;
  ::std::string* featuredatumname_;
  ::std::string* metricid_;
  ::std::string* requestedvaluetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PointCoordinatesType* default_instance_;
};
// -------------------------------------------------------------------

class PressureType : public ::google::protobuf::Message {
 public:
  PressureType();
  virtual ~PressureType();

  PressureType(const PressureType& from);

  inline PressureType& operator=(const PressureType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PressureType& default_instance();

  void Swap(PressureType* other);

  // implements Message ----------------------------------------------

  PressureType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PressureType& from);
  void MergeFrom(const PressureType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required double Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PressureType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PressureType* default_instance_;
};
// -------------------------------------------------------------------

class PrismaticType : public ::google::protobuf::Message {
 public:
  PrismaticType();
  virtual ~PrismaticType();

  PrismaticType(const PrismaticType& from);

  inline PrismaticType& operator=(const PrismaticType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrismaticType& default_instance();

  void Swap(PrismaticType* other);

  // implements Message ----------------------------------------------

  PrismaticType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrismaticType& from);
  void MergeFrom(const PrismaticType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
  inline int kinematicfeature_size() const;
  inline void clear_kinematicfeature();
  static const int kKinematicFeatureFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& kinematicfeature(int index) const;
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* mutable_kinematicfeature(int index);
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* add_kinematicfeature();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
      kinematicfeature() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
      mutable_kinematicfeature();

  // required double CFM = 2;
  inline bool has_cfm() const;
  inline void clear_cfm();
  static const int kCFMFieldNumber = 2;
  inline double cfm() const;
  inline void set_cfm(double value);

  // required string ConnectedComponentID = 3;
  inline bool has_connectedcomponentid() const;
  inline void clear_connectedcomponentid();
  static const int kConnectedComponentIDFieldNumber = 3;
  inline const ::std::string& connectedcomponentid() const;
  inline void set_connectedcomponentid(const ::std::string& value);
  inline void set_connectedcomponentid(const char* value);
  inline void set_connectedcomponentid(const char* value, size_t size);
  inline ::std::string* mutable_connectedcomponentid();
  inline ::std::string* release_connectedcomponentid();
  inline void set_allocated_connectedcomponentid(::std::string* connectedcomponentid);

  // required string ConnectionID = 4;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 4;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // required double ERP = 5;
  inline bool has_erp() const;
  inline void clear_erp();
  static const int kERPFieldNumber = 5;
  inline double erp() const;
  inline void set_erp(double value);

  // required string FeatureInterfaceType = 6;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 6;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PrismaticType)
 private:
  inline void set_has_cfm();
  inline void clear_has_cfm();
  inline void set_has_connectedcomponentid();
  inline void clear_has_connectedcomponentid();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_erp();
  inline void clear_has_erp();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType > kinematicfeature_;
  double cfm_;
  ::std::string* connectedcomponentid_;
  ::std::string* connectionid_;
  double erp_;
  ::std::string* featureinterfacetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PrismaticType* default_instance_;
};
// -------------------------------------------------------------------

class PropertiesType : public ::google::protobuf::Message {
 public:
  PropertiesType();
  virtual ~PropertiesType();

  PropertiesType(const PropertiesType& from);

  inline PropertiesType& operator=(const PropertiesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertiesType& default_instance();

  void Swap(PropertiesType* other);

  // implements Message ----------------------------------------------

  PropertiesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PropertiesType& from);
  void MergeFrom(const PropertiesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::UnitsType& units() const;
  inline ::edu::vanderbilt::isis::meta::UnitsType* mutable_units();
  inline ::edu::vanderbilt::isis::meta::UnitsType* release_units();
  inline void set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.PropertiesType)
 private:
  inline void set_has_units();
  inline void clear_has_units();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::UnitsType* units_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static PropertiesType* default_instance_;
};
// -------------------------------------------------------------------

class ReferencePlaneType : public ::google::protobuf::Message {
 public:
  ReferencePlaneType();
  virtual ~ReferencePlaneType();

  ReferencePlaneType(const ReferencePlaneType& from);

  inline ReferencePlaneType& operator=(const ReferencePlaneType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferencePlaneType& default_instance();

  void Swap(ReferencePlaneType* other);

  // implements Message ----------------------------------------------

  ReferencePlaneType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferencePlaneType& from);
  void MergeFrom(const ReferencePlaneType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ReferencePlaneType)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ReferencePlaneType* default_instance_;
};
// -------------------------------------------------------------------

class RevoluteType : public ::google::protobuf::Message {
 public:
  RevoluteType();
  virtual ~RevoluteType();

  RevoluteType(const RevoluteType& from);

  inline RevoluteType& operator=(const RevoluteType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevoluteType& default_instance();

  void Swap(RevoluteType* other);

  // implements Message ----------------------------------------------

  RevoluteType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevoluteType& from);
  void MergeFrom(const RevoluteType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
  inline int kinematicfeature_size() const;
  inline void clear_kinematicfeature();
  static const int kKinematicFeatureFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& kinematicfeature(int index) const;
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* mutable_kinematicfeature(int index);
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* add_kinematicfeature();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
      kinematicfeature() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
      mutable_kinematicfeature();

  // required double CFM = 2;
  inline bool has_cfm() const;
  inline void clear_cfm();
  static const int kCFMFieldNumber = 2;
  inline double cfm() const;
  inline void set_cfm(double value);

  // required string ConnectedComponentID = 3;
  inline bool has_connectedcomponentid() const;
  inline void clear_connectedcomponentid();
  static const int kConnectedComponentIDFieldNumber = 3;
  inline const ::std::string& connectedcomponentid() const;
  inline void set_connectedcomponentid(const ::std::string& value);
  inline void set_connectedcomponentid(const char* value);
  inline void set_connectedcomponentid(const char* value, size_t size);
  inline ::std::string* mutable_connectedcomponentid();
  inline ::std::string* release_connectedcomponentid();
  inline void set_allocated_connectedcomponentid(::std::string* connectedcomponentid);

  // required string ConnectionID = 4;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 4;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // required double ERP = 5;
  inline bool has_erp() const;
  inline void clear_erp();
  static const int kERPFieldNumber = 5;
  inline double erp() const;
  inline void set_erp(double value);

  // required string FeatureInterfaceType = 6;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 6;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.RevoluteType)
 private:
  inline void set_has_cfm();
  inline void clear_has_cfm();
  inline void set_has_connectedcomponentid();
  inline void clear_has_connectedcomponentid();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_erp();
  inline void clear_has_erp();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType > kinematicfeature_;
  double cfm_;
  ::std::string* connectedcomponentid_;
  ::std::string* connectionid_;
  double erp_;
  ::std::string* featureinterfacetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static RevoluteType* default_instance_;
};
// -------------------------------------------------------------------

class RotationType : public ::google::protobuf::Message {
 public:
  RotationType();
  virtual ~RotationType();

  RotationType(const RotationType& from);

  inline RotationType& operator=(const RotationType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationType& default_instance();

  void Swap(RotationType* other);

  // implements Message ----------------------------------------------

  RotationType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotationType& from);
  void MergeFrom(const RotationType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required string x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline const ::std::string& x() const;
  inline void set_x(const ::std::string& value);
  inline void set_x(const char* value);
  inline void set_x(const char* value, size_t size);
  inline ::std::string* mutable_x();
  inline ::std::string* release_x();
  inline void set_allocated_x(::std::string* x);

  // required string y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline const ::std::string& y() const;
  inline void set_y(const ::std::string& value);
  inline void set_y(const char* value);
  inline void set_y(const char* value, size_t size);
  inline ::std::string* mutable_y();
  inline ::std::string* release_y();
  inline void set_allocated_y(::std::string* y);

  // required string z = 5;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 5;
  inline const ::std::string& z() const;
  inline void set_z(const ::std::string& value);
  inline void set_z(const char* value);
  inline void set_z(const char* value, size_t size);
  inline ::std::string* mutable_z();
  inline ::std::string* release_z();
  inline void set_allocated_z(::std::string* z);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.RotationType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  ::std::string* x_;
  ::std::string* y_;
  ::std::string* z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static RotationType* default_instance_;
};
// -------------------------------------------------------------------

class STEPFormatType : public ::google::protobuf::Message {
 public:
  STEPFormatType();
  virtual ~STEPFormatType();

  STEPFormatType(const STEPFormatType& from);

  inline STEPFormatType& operator=(const STEPFormatType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const STEPFormatType& default_instance();

  void Swap(STEPFormatType* other);

  // implements Message ----------------------------------------------

  STEPFormatType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const STEPFormatType& from);
  void MergeFrom(const STEPFormatType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.STEPFormatType)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static STEPFormatType* default_instance_;
};
// -------------------------------------------------------------------

class SetOperationType : public ::google::protobuf::Message {
 public:
  SetOperationType();
  virtual ~SetOperationType();

  SetOperationType(const SetOperationType& from);

  inline SetOperationType& operator=(const SetOperationType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOperationType& default_instance();

  void Swap(SetOperationType* other);

  // implements Message ----------------------------------------------

  SetOperationType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOperationType& from);
  void MergeFrom(const SetOperationType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string FeatureID = 1;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureIDFieldNumber = 1;
  inline const ::std::string& featureid() const;
  inline void set_featureid(const ::std::string& value);
  inline void set_featureid(const char* value);
  inline void set_featureid(const char* value, size_t size);
  inline ::std::string* mutable_featureid();
  inline ::std::string* release_featureid();
  inline void set_allocated_featureid(::std::string* featureid);

  // required string Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SetOperationType)
 private:
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* featureid_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SetOperationType* default_instance_;
};
// -------------------------------------------------------------------

class ShotlineType : public ::google::protobuf::Message {
 public:
  ShotlineType();
  virtual ~ShotlineType();

  ShotlineType(const ShotlineType& from);

  inline ShotlineType& operator=(const ShotlineType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShotlineType& default_instance();

  void Swap(ShotlineType* other);

  // implements Message ----------------------------------------------

  ShotlineType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShotlineType& from);
  void MergeFrom(const ShotlineType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Azimuth = 1;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 1;
  inline double azimuth() const;
  inline void set_azimuth(double value);

  // required string BallisticThreatRef = 2;
  inline bool has_ballisticthreatref() const;
  inline void clear_ballisticthreatref();
  static const int kBallisticThreatRefFieldNumber = 2;
  inline const ::std::string& ballisticthreatref() const;
  inline void set_ballisticthreatref(const ::std::string& value);
  inline void set_ballisticthreatref(const char* value);
  inline void set_ballisticthreatref(const char* value, size_t size);
  inline ::std::string* mutable_ballisticthreatref();
  inline ::std::string* release_ballisticthreatref();
  inline void set_allocated_ballisticthreatref(::std::string* ballisticthreatref);

  // required string ComponentID = 3;
  inline bool has_componentid() const;
  inline void clear_componentid();
  static const int kComponentIDFieldNumber = 3;
  inline const ::std::string& componentid() const;
  inline void set_componentid(const ::std::string& value);
  inline void set_componentid(const char* value);
  inline void set_componentid(const char* value, size_t size);
  inline ::std::string* mutable_componentid();
  inline ::std::string* release_componentid();
  inline void set_allocated_componentid(::std::string* componentid);

  // required string DatumPoint = 4;
  inline bool has_datumpoint() const;
  inline void clear_datumpoint();
  static const int kDatumPointFieldNumber = 4;
  inline const ::std::string& datumpoint() const;
  inline void set_datumpoint(const ::std::string& value);
  inline void set_datumpoint(const char* value);
  inline void set_datumpoint(const char* value, size_t size);
  inline ::std::string* mutable_datumpoint();
  inline ::std::string* release_datumpoint();
  inline void set_allocated_datumpoint(::std::string* datumpoint);

  // required double Elevation = 5;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline double elevation() const;
  inline void set_elevation(double value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ShotlineType)
 private:
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_ballisticthreatref();
  inline void clear_has_ballisticthreatref();
  inline void set_has_componentid();
  inline void clear_has_componentid();
  inline void set_has_datumpoint();
  inline void clear_has_datumpoint();
  inline void set_has_elevation();
  inline void clear_has_elevation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double azimuth_;
  ::std::string* ballisticthreatref_;
  ::std::string* componentid_;
  ::std::string* datumpoint_;
  double elevation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ShotlineType* default_instance_;
};
// -------------------------------------------------------------------

class ShotlinesType : public ::google::protobuf::Message {
 public:
  ShotlinesType();
  virtual ~ShotlinesType();

  ShotlinesType(const ShotlinesType& from);

  inline ShotlinesType& operator=(const ShotlinesType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShotlinesType& default_instance();

  void Swap(ShotlinesType* other);

  // implements Message ----------------------------------------------

  ShotlinesType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShotlinesType& from);
  void MergeFrom(const ShotlinesType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.ShotlineType Shotline = 1;
  inline int shotline_size() const;
  inline void clear_shotline();
  static const int kShotlineFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::ShotlineType& shotline(int index) const;
  inline ::edu::vanderbilt::isis::meta::ShotlineType* mutable_shotline(int index);
  inline ::edu::vanderbilt::isis::meta::ShotlineType* add_shotline();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ShotlineType >&
      shotline() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ShotlineType >*
      mutable_shotline();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ShotlinesType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ShotlineType > shotline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ShotlinesType* default_instance_;
};
// -------------------------------------------------------------------

class SolverType : public ::google::protobuf::Message {
 public:
  SolverType();
  virtual ~SolverType();

  SolverType(const SolverType& from);

  inline SolverType& operator=(const SolverType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverType& default_instance();

  void Swap(SolverType* other);

  // implements Message ----------------------------------------------

  SolverType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverType& from);
  void MergeFrom(const SolverType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ElementShapeType = 1;
  inline bool has_elementshapetype() const;
  inline void clear_elementshapetype();
  static const int kElementShapeTypeFieldNumber = 1;
  inline const ::std::string& elementshapetype() const;
  inline void set_elementshapetype(const ::std::string& value);
  inline void set_elementshapetype(const char* value);
  inline void set_elementshapetype(const char* value, size_t size);
  inline ::std::string* mutable_elementshapetype();
  inline ::std::string* release_elementshapetype();
  inline void set_allocated_elementshapetype(::std::string* elementshapetype);

  // required string MeshType = 2;
  inline bool has_meshtype() const;
  inline void clear_meshtype();
  static const int kMeshTypeFieldNumber = 2;
  inline const ::std::string& meshtype() const;
  inline void set_meshtype(const ::std::string& value);
  inline void set_meshtype(const char* value);
  inline void set_meshtype(const char* value, size_t size);
  inline ::std::string* mutable_meshtype();
  inline ::std::string* release_meshtype();
  inline void set_allocated_meshtype(::std::string* meshtype);

  // required string ShellElementType = 3;
  inline bool has_shellelementtype() const;
  inline void clear_shellelementtype();
  static const int kShellElementTypeFieldNumber = 3;
  inline const ::std::string& shellelementtype() const;
  inline void set_shellelementtype(const ::std::string& value);
  inline void set_shellelementtype(const char* value);
  inline void set_shellelementtype(const char* value, size_t size);
  inline ::std::string* mutable_shellelementtype();
  inline ::std::string* release_shellelementtype();
  inline void set_allocated_shellelementtype(::std::string* shellelementtype);

  // required string Type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SolverType)
 private:
  inline void set_has_elementshapetype();
  inline void clear_has_elementshapetype();
  inline void set_has_meshtype();
  inline void clear_has_meshtype();
  inline void set_has_shellelementtype();
  inline void clear_has_shellelementtype();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* elementshapetype_;
  ::std::string* meshtype_;
  ::std::string* shellelementtype_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SolverType* default_instance_;
};
// -------------------------------------------------------------------

class SolversType : public ::google::protobuf::Message {
 public:
  SolversType();
  virtual ~SolversType();

  SolversType(const SolversType& from);

  inline SolversType& operator=(const SolversType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolversType& default_instance();

  void Swap(SolversType* other);

  // implements Message ----------------------------------------------

  SolversType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolversType& from);
  void MergeFrom(const SolversType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.SolverType Solver = 1;
  inline int solver_size() const;
  inline void clear_solver();
  static const int kSolverFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::SolverType& solver(int index) const;
  inline ::edu::vanderbilt::isis::meta::SolverType* mutable_solver(int index);
  inline ::edu::vanderbilt::isis::meta::SolverType* add_solver();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SolverType >&
      solver() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SolverType >*
      mutable_solver();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SolversType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SolverType > solver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SolversType* default_instance_;
};
// -------------------------------------------------------------------

class SphericalType : public ::google::protobuf::Message {
 public:
  SphericalType();
  virtual ~SphericalType();

  SphericalType(const SphericalType& from);

  inline SphericalType& operator=(const SphericalType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SphericalType& default_instance();

  void Swap(SphericalType* other);

  // implements Message ----------------------------------------------

  SphericalType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SphericalType& from);
  void MergeFrom(const SphericalType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
  inline int kinematicfeature_size() const;
  inline void clear_kinematicfeature();
  static const int kKinematicFeatureFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& kinematicfeature(int index) const;
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* mutable_kinematicfeature(int index);
  inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* add_kinematicfeature();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
      kinematicfeature() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
      mutable_kinematicfeature();

  // required double CFM = 2;
  inline bool has_cfm() const;
  inline void clear_cfm();
  static const int kCFMFieldNumber = 2;
  inline double cfm() const;
  inline void set_cfm(double value);

  // required string ConnectedComponentID = 3;
  inline bool has_connectedcomponentid() const;
  inline void clear_connectedcomponentid();
  static const int kConnectedComponentIDFieldNumber = 3;
  inline const ::std::string& connectedcomponentid() const;
  inline void set_connectedcomponentid(const ::std::string& value);
  inline void set_connectedcomponentid(const char* value);
  inline void set_connectedcomponentid(const char* value, size_t size);
  inline ::std::string* mutable_connectedcomponentid();
  inline ::std::string* release_connectedcomponentid();
  inline void set_allocated_connectedcomponentid(::std::string* connectedcomponentid);

  // required string ConnectionID = 4;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 4;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // required double ERP = 5;
  inline bool has_erp() const;
  inline void clear_erp();
  static const int kERPFieldNumber = 5;
  inline double erp() const;
  inline void set_erp(double value);

  // required string FeatureInterfaceType = 6;
  inline bool has_featureinterfacetype() const;
  inline void clear_featureinterfacetype();
  static const int kFeatureInterfaceTypeFieldNumber = 6;
  inline const ::std::string& featureinterfacetype() const;
  inline void set_featureinterfacetype(const ::std::string& value);
  inline void set_featureinterfacetype(const char* value);
  inline void set_featureinterfacetype(const char* value, size_t size);
  inline ::std::string* mutable_featureinterfacetype();
  inline ::std::string* release_featureinterfacetype();
  inline void set_allocated_featureinterfacetype(::std::string* featureinterfacetype);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SphericalType)
 private:
  inline void set_has_cfm();
  inline void clear_has_cfm();
  inline void set_has_connectedcomponentid();
  inline void clear_has_connectedcomponentid();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_erp();
  inline void clear_has_erp();
  inline void set_has_featureinterfacetype();
  inline void clear_has_featureinterfacetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType > kinematicfeature_;
  double cfm_;
  ::std::string* connectedcomponentid_;
  ::std::string* connectionid_;
  double erp_;
  ::std::string* featureinterfacetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SphericalType* default_instance_;
};
// -------------------------------------------------------------------

class SurfaceTreatmentType : public ::google::protobuf::Message {
 public:
  SurfaceTreatmentType();
  virtual ~SurfaceTreatmentType();

  SurfaceTreatmentType(const SurfaceTreatmentType& from);

  inline SurfaceTreatmentType& operator=(const SurfaceTreatmentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceTreatmentType& default_instance();

  void Swap(SurfaceTreatmentType* other);

  // implements Message ----------------------------------------------

  SurfaceTreatmentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfaceTreatmentType& from);
  void MergeFrom(const SurfaceTreatmentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::GeometryType& geometry() const;
  inline ::edu::vanderbilt::isis::meta::GeometryType* mutable_geometry();
  inline ::edu::vanderbilt::isis::meta::GeometryType* release_geometry();
  inline void set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry);

  // optional string AdjoiningParts = 2;
  inline bool has_adjoiningparts() const;
  inline void clear_adjoiningparts();
  static const int kAdjoiningPartsFieldNumber = 2;
  inline const ::std::string& adjoiningparts() const;
  inline void set_adjoiningparts(const ::std::string& value);
  inline void set_adjoiningparts(const char* value);
  inline void set_adjoiningparts(const char* value, size_t size);
  inline ::std::string* mutable_adjoiningparts();
  inline ::std::string* release_adjoiningparts();
  inline void set_allocated_adjoiningparts(::std::string* adjoiningparts);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SurfaceTreatmentType)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_adjoiningparts();
  inline void clear_has_adjoiningparts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::edu::vanderbilt::isis::meta::GeometryType* geometry_;
  ::std::string* adjoiningparts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SurfaceTreatmentType* default_instance_;
};
// -------------------------------------------------------------------

class SurfaceTreatmentsType : public ::google::protobuf::Message {
 public:
  SurfaceTreatmentsType();
  virtual ~SurfaceTreatmentsType();

  SurfaceTreatmentsType(const SurfaceTreatmentsType& from);

  inline SurfaceTreatmentsType& operator=(const SurfaceTreatmentsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceTreatmentsType& default_instance();

  void Swap(SurfaceTreatmentsType* other);

  // implements Message ----------------------------------------------

  SurfaceTreatmentsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfaceTreatmentsType& from);
  void MergeFrom(const SurfaceTreatmentsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.SurfaceTreatmentType SurfaceTreatment = 1;
  inline int surfacetreatment_size() const;
  inline void clear_surfacetreatment();
  static const int kSurfaceTreatmentFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::SurfaceTreatmentType& surfacetreatment(int index) const;
  inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentType* mutable_surfacetreatment(int index);
  inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentType* add_surfacetreatment();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentType >&
      surfacetreatment() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentType >*
      mutable_surfacetreatment();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.SurfaceTreatmentsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentType > surfacetreatment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static SurfaceTreatmentsType* default_instance_;
};
// -------------------------------------------------------------------

class ToleranceType : public ::google::protobuf::Message {
 public:
  ToleranceType();
  virtual ~ToleranceType();

  ToleranceType(const ToleranceType& from);

  inline ToleranceType& operator=(const ToleranceType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToleranceType& default_instance();

  void Swap(ToleranceType* other);

  // implements Message ----------------------------------------------

  ToleranceType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToleranceType& from);
  void MergeFrom(const ToleranceType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string AnalysisID = 1;
  inline bool has_analysisid() const;
  inline void clear_analysisid();
  static const int kAnalysisIDFieldNumber = 1;
  inline const ::std::string& analysisid() const;
  inline void set_analysisid(const ::std::string& value);
  inline void set_analysisid(const char* value);
  inline void set_analysisid(const char* value, size_t size);
  inline ::std::string* mutable_analysisid();
  inline ::std::string* release_analysisid();
  inline void set_allocated_analysisid(::std::string* analysisid);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.ToleranceType)
 private:
  inline void set_has_analysisid();
  inline void clear_has_analysisid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* analysisid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static ToleranceType* default_instance_;
};
// -------------------------------------------------------------------

class TranslationType : public ::google::protobuf::Message {
 public:
  TranslationType();
  virtual ~TranslationType();

  TranslationType(const TranslationType& from);

  inline TranslationType& operator=(const TranslationType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslationType& default_instance();

  void Swap(TranslationType* other);

  // implements Message ----------------------------------------------

  TranslationType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslationType& from);
  void MergeFrom(const TranslationType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // required string x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline const ::std::string& x() const;
  inline void set_x(const ::std::string& value);
  inline void set_x(const char* value);
  inline void set_x(const char* value, size_t size);
  inline ::std::string* mutable_x();
  inline ::std::string* release_x();
  inline void set_allocated_x(::std::string* x);

  // required string y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline const ::std::string& y() const;
  inline void set_y(const ::std::string& value);
  inline void set_y(const char* value);
  inline void set_y(const char* value, size_t size);
  inline ::std::string* mutable_y();
  inline ::std::string* release_y();
  inline void set_allocated_y(::std::string* y);

  // required string z = 5;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 5;
  inline const ::std::string& z() const;
  inline void set_z(const ::std::string& value);
  inline void set_z(const char* value);
  inline void set_z(const char* value, size_t size);
  inline ::std::string* mutable_z();
  inline ::std::string* release_z();
  inline void set_allocated_z(::std::string* z);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.TranslationType)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* units_;
  ::std::string* x_;
  ::std::string* y_;
  ::std::string* z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static TranslationType* default_instance_;
};
// -------------------------------------------------------------------

class UnassembledComponentsType : public ::google::protobuf::Message {
 public:
  UnassembledComponentsType();
  virtual ~UnassembledComponentsType();

  UnassembledComponentsType(const UnassembledComponentsType& from);

  inline UnassembledComponentsType& operator=(const UnassembledComponentsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnassembledComponentsType& default_instance();

  void Swap(UnassembledComponentsType* other);

  // implements Message ----------------------------------------------

  UnassembledComponentsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnassembledComponentsType& from);
  void MergeFrom(const UnassembledComponentsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 1;
  inline int cadcomponent_size() const;
  inline void clear_cadcomponent();
  static const int kCADComponentFieldNumber = 1;
  inline const ::edu::vanderbilt::isis::meta::CADComponentType& cadcomponent(int index) const;
  inline ::edu::vanderbilt::isis::meta::CADComponentType* mutable_cadcomponent(int index);
  inline ::edu::vanderbilt::isis::meta::CADComponentType* add_cadcomponent();
  inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >&
      cadcomponent() const;
  inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >*
      mutable_cadcomponent();

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.UnassembledComponentsType)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType > cadcomponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static UnassembledComponentsType* default_instance_;
};
// -------------------------------------------------------------------

class UnitsType : public ::google::protobuf::Message {
 public:
  UnitsType();
  virtual ~UnitsType();

  UnitsType(const UnitsType& from);

  inline UnitsType& operator=(const UnitsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitsType& default_instance();

  void Swap(UnitsType* other);

  // implements Message ----------------------------------------------

  UnitsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitsType& from);
  void MergeFrom(const UnitsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:edu.vanderbilt.isis.meta.UnitsType)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AssemblyInterface_2eproto();
  friend void protobuf_AssignDesc_AssemblyInterface_2eproto();
  friend void protobuf_ShutdownFile_AssemblyInterface_2eproto();

  void InitAsDefaultInstance();
  static UnitsType* default_instance_;
};
// ===================================================================


// ===================================================================

// AccelerationType

// required string Units = 1;
inline bool AccelerationType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& AccelerationType::units() const {
  return *units_;
}
inline void AccelerationType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void AccelerationType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void AccelerationType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccelerationType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* AccelerationType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccelerationType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double x = 3;
inline bool AccelerationType::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationType::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationType::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationType::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double AccelerationType::x() const {
  return x_;
}
inline void AccelerationType::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 4;
inline bool AccelerationType::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccelerationType::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccelerationType::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccelerationType::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double AccelerationType::y() const {
  return y_;
}
inline void AccelerationType::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 5;
inline bool AccelerationType::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccelerationType::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccelerationType::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccelerationType::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double AccelerationType::z() const {
  return z_;
}
inline void AccelerationType::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// AnalysesType

// repeated .edu.vanderbilt.isis.meta.BallisticType Ballistic = 1;
inline int AnalysesType::ballistic_size() const {
  return ballistic_.size();
}
inline void AnalysesType::clear_ballistic() {
  ballistic_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::BallisticType& AnalysesType::ballistic(int index) const {
  return ballistic_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::BallisticType* AnalysesType::mutable_ballistic(int index) {
  return ballistic_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::BallisticType* AnalysesType::add_ballistic() {
  return ballistic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BallisticType >&
AnalysesType::ballistic() const {
  return ballistic_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BallisticType >*
AnalysesType::mutable_ballistic() {
  return &ballistic_;
}

// repeated .edu.vanderbilt.isis.meta.FEAType FEA = 2;
inline int AnalysesType::fea_size() const {
  return fea_.size();
}
inline void AnalysesType::clear_fea() {
  fea_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::FEAType& AnalysesType::fea(int index) const {
  return fea_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::FEAType* AnalysesType::mutable_fea(int index) {
  return fea_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::FEAType* AnalysesType::add_fea() {
  return fea_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FEAType >&
AnalysesType::fea() const {
  return fea_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FEAType >*
AnalysesType::mutable_fea() {
  return &fea_;
}

// repeated .edu.vanderbilt.isis.meta.InterferenceType Interference = 3;
inline int AnalysesType::interference_size() const {
  return interference_.size();
}
inline void AnalysesType::clear_interference() {
  interference_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::InterferenceType& AnalysesType::interference(int index) const {
  return interference_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::InterferenceType* AnalysesType::mutable_interference(int index) {
  return interference_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::InterferenceType* AnalysesType::add_interference() {
  return interference_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::InterferenceType >&
AnalysesType::interference() const {
  return interference_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::InterferenceType >*
AnalysesType::mutable_interference() {
  return &interference_;
}

// repeated .edu.vanderbilt.isis.meta.ToleranceType Tolerance = 4;
inline int AnalysesType::tolerance_size() const {
  return tolerance_.size();
}
inline void AnalysesType::clear_tolerance() {
  tolerance_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ToleranceType& AnalysesType::tolerance(int index) const {
  return tolerance_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ToleranceType* AnalysesType::mutable_tolerance(int index) {
  return tolerance_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ToleranceType* AnalysesType::add_tolerance() {
  return tolerance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ToleranceType >&
AnalysesType::tolerance() const {
  return tolerance_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ToleranceType >*
AnalysesType::mutable_tolerance() {
  return &tolerance_;
}

// -------------------------------------------------------------------

// AnalysisComponentsType

// repeated .edu.vanderbilt.isis.meta.ComponentType Component = 1;
inline int AnalysisComponentsType::component_size() const {
  return component_.size();
}
inline void AnalysisComponentsType::clear_component() {
  component_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ComponentType& AnalysisComponentsType::component(int index) const {
  return component_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ComponentType* AnalysisComponentsType::mutable_component(int index) {
  return component_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ComponentType* AnalysisComponentsType::add_component() {
  return component_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ComponentType >&
AnalysisComponentsType::component() const {
  return component_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ComponentType >*
AnalysisComponentsType::mutable_component() {
  return &component_;
}

// -------------------------------------------------------------------

// AnalysisConstraintType

// optional .edu.vanderbilt.isis.meta.BallType Ball = 1;
inline bool AnalysisConstraintType::has_ball() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalysisConstraintType::set_has_ball() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalysisConstraintType::clear_has_ball() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalysisConstraintType::clear_ball() {
  if (ball_ != NULL) ball_->::edu::vanderbilt::isis::meta::BallType::Clear();
  clear_has_ball();
}
inline const ::edu::vanderbilt::isis::meta::BallType& AnalysisConstraintType::ball() const {
  return ball_ != NULL ? *ball_ : *default_instance_->ball_;
}
inline ::edu::vanderbilt::isis::meta::BallType* AnalysisConstraintType::mutable_ball() {
  set_has_ball();
  if (ball_ == NULL) ball_ = new ::edu::vanderbilt::isis::meta::BallType;
  return ball_;
}
inline ::edu::vanderbilt::isis::meta::BallType* AnalysisConstraintType::release_ball() {
  clear_has_ball();
  ::edu::vanderbilt::isis::meta::BallType* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void AnalysisConstraintType::set_allocated_ball(::edu::vanderbilt::isis::meta::BallType* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    set_has_ball();
  } else {
    clear_has_ball();
  }
}

// optional .edu.vanderbilt.isis.meta.DisplacementType Displacement = 2;
inline bool AnalysisConstraintType::has_displacement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalysisConstraintType::set_has_displacement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalysisConstraintType::clear_has_displacement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalysisConstraintType::clear_displacement() {
  if (displacement_ != NULL) displacement_->::edu::vanderbilt::isis::meta::DisplacementType::Clear();
  clear_has_displacement();
}
inline const ::edu::vanderbilt::isis::meta::DisplacementType& AnalysisConstraintType::displacement() const {
  return displacement_ != NULL ? *displacement_ : *default_instance_->displacement_;
}
inline ::edu::vanderbilt::isis::meta::DisplacementType* AnalysisConstraintType::mutable_displacement() {
  set_has_displacement();
  if (displacement_ == NULL) displacement_ = new ::edu::vanderbilt::isis::meta::DisplacementType;
  return displacement_;
}
inline ::edu::vanderbilt::isis::meta::DisplacementType* AnalysisConstraintType::release_displacement() {
  clear_has_displacement();
  ::edu::vanderbilt::isis::meta::DisplacementType* temp = displacement_;
  displacement_ = NULL;
  return temp;
}
inline void AnalysisConstraintType::set_allocated_displacement(::edu::vanderbilt::isis::meta::DisplacementType* displacement) {
  delete displacement_;
  displacement_ = displacement;
  if (displacement) {
    set_has_displacement();
  } else {
    clear_has_displacement();
  }
}

// optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 3;
inline bool AnalysisConstraintType::has_geometry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalysisConstraintType::set_has_geometry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalysisConstraintType::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalysisConstraintType::clear_geometry() {
  if (geometry_ != NULL) geometry_->::edu::vanderbilt::isis::meta::GeometryType::Clear();
  clear_has_geometry();
}
inline const ::edu::vanderbilt::isis::meta::GeometryType& AnalysisConstraintType::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* AnalysisConstraintType::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::edu::vanderbilt::isis::meta::GeometryType;
  return geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* AnalysisConstraintType::release_geometry() {
  clear_has_geometry();
  ::edu::vanderbilt::isis::meta::GeometryType* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void AnalysisConstraintType::set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .edu.vanderbilt.isis.meta.PinType Pin = 4;
inline bool AnalysisConstraintType::has_pin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalysisConstraintType::set_has_pin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalysisConstraintType::clear_has_pin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalysisConstraintType::clear_pin() {
  if (pin_ != NULL) pin_->::edu::vanderbilt::isis::meta::PinType::Clear();
  clear_has_pin();
}
inline const ::edu::vanderbilt::isis::meta::PinType& AnalysisConstraintType::pin() const {
  return pin_ != NULL ? *pin_ : *default_instance_->pin_;
}
inline ::edu::vanderbilt::isis::meta::PinType* AnalysisConstraintType::mutable_pin() {
  set_has_pin();
  if (pin_ == NULL) pin_ = new ::edu::vanderbilt::isis::meta::PinType;
  return pin_;
}
inline ::edu::vanderbilt::isis::meta::PinType* AnalysisConstraintType::release_pin() {
  clear_has_pin();
  ::edu::vanderbilt::isis::meta::PinType* temp = pin_;
  pin_ = NULL;
  return temp;
}
inline void AnalysisConstraintType::set_allocated_pin(::edu::vanderbilt::isis::meta::PinType* pin) {
  delete pin_;
  pin_ = pin;
  if (pin) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
}

// -------------------------------------------------------------------

// AnalysisConstraintsType

// repeated .edu.vanderbilt.isis.meta.AnalysisConstraintType AnalysisConstraint = 1;
inline int AnalysisConstraintsType::analysisconstraint_size() const {
  return analysisconstraint_.size();
}
inline void AnalysisConstraintsType::clear_analysisconstraint() {
  analysisconstraint_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::AnalysisConstraintType& AnalysisConstraintsType::analysisconstraint(int index) const {
  return analysisconstraint_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::AnalysisConstraintType* AnalysisConstraintsType::mutable_analysisconstraint(int index) {
  return analysisconstraint_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::AnalysisConstraintType* AnalysisConstraintsType::add_analysisconstraint() {
  return analysisconstraint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AnalysisConstraintType >&
AnalysisConstraintsType::analysisconstraint() const {
  return analysisconstraint_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AnalysisConstraintType >*
AnalysisConstraintsType::mutable_analysisconstraint() {
  return &analysisconstraint_;
}

// -------------------------------------------------------------------

// AssembliesType

// repeated .edu.vanderbilt.isis.meta.AssemblyType Assembly = 1;
inline int AssembliesType::assembly_size() const {
  return assembly_.size();
}
inline void AssembliesType::clear_assembly() {
  assembly_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::AssemblyType& AssembliesType::assembly(int index) const {
  return assembly_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::AssemblyType* AssembliesType::mutable_assembly(int index) {
  return assembly_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::AssemblyType* AssembliesType::add_assembly() {
  return assembly_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssemblyType >&
AssembliesType::assembly() const {
  return assembly_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssemblyType >*
AssembliesType::mutable_assembly() {
  return &assembly_;
}

// optional .edu.vanderbilt.isis.meta.DataExchangeType DataExchange = 2;
inline bool AssembliesType::has_dataexchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssembliesType::set_has_dataexchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssembliesType::clear_has_dataexchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssembliesType::clear_dataexchange() {
  if (dataexchange_ != NULL) dataexchange_->::edu::vanderbilt::isis::meta::DataExchangeType::Clear();
  clear_has_dataexchange();
}
inline const ::edu::vanderbilt::isis::meta::DataExchangeType& AssembliesType::dataexchange() const {
  return dataexchange_ != NULL ? *dataexchange_ : *default_instance_->dataexchange_;
}
inline ::edu::vanderbilt::isis::meta::DataExchangeType* AssembliesType::mutable_dataexchange() {
  set_has_dataexchange();
  if (dataexchange_ == NULL) dataexchange_ = new ::edu::vanderbilt::isis::meta::DataExchangeType;
  return dataexchange_;
}
inline ::edu::vanderbilt::isis::meta::DataExchangeType* AssembliesType::release_dataexchange() {
  clear_has_dataexchange();
  ::edu::vanderbilt::isis::meta::DataExchangeType* temp = dataexchange_;
  dataexchange_ = NULL;
  return temp;
}
inline void AssembliesType::set_allocated_dataexchange(::edu::vanderbilt::isis::meta::DataExchangeType* dataexchange) {
  delete dataexchange_;
  dataexchange_ = dataexchange;
  if (dataexchange) {
    set_has_dataexchange();
  } else {
    clear_has_dataexchange();
  }
}

// repeated .edu.vanderbilt.isis.meta.MaterialsType Materials = 3;
inline int AssembliesType::materials_size() const {
  return materials_.size();
}
inline void AssembliesType::clear_materials() {
  materials_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::MaterialsType& AssembliesType::materials(int index) const {
  return materials_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialsType* AssembliesType::mutable_materials(int index) {
  return materials_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialsType* AssembliesType::add_materials() {
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialsType >&
AssembliesType::materials() const {
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialsType >*
AssembliesType::mutable_materials() {
  return &materials_;
}

// optional .edu.vanderbilt.isis.meta.UnassembledComponentsType UnassembledComponents = 4;
inline bool AssembliesType::has_unassembledcomponents() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssembliesType::set_has_unassembledcomponents() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssembliesType::clear_has_unassembledcomponents() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssembliesType::clear_unassembledcomponents() {
  if (unassembledcomponents_ != NULL) unassembledcomponents_->::edu::vanderbilt::isis::meta::UnassembledComponentsType::Clear();
  clear_has_unassembledcomponents();
}
inline const ::edu::vanderbilt::isis::meta::UnassembledComponentsType& AssembliesType::unassembledcomponents() const {
  return unassembledcomponents_ != NULL ? *unassembledcomponents_ : *default_instance_->unassembledcomponents_;
}
inline ::edu::vanderbilt::isis::meta::UnassembledComponentsType* AssembliesType::mutable_unassembledcomponents() {
  set_has_unassembledcomponents();
  if (unassembledcomponents_ == NULL) unassembledcomponents_ = new ::edu::vanderbilt::isis::meta::UnassembledComponentsType;
  return unassembledcomponents_;
}
inline ::edu::vanderbilt::isis::meta::UnassembledComponentsType* AssembliesType::release_unassembledcomponents() {
  clear_has_unassembledcomponents();
  ::edu::vanderbilt::isis::meta::UnassembledComponentsType* temp = unassembledcomponents_;
  unassembledcomponents_ = NULL;
  return temp;
}
inline void AssembliesType::set_allocated_unassembledcomponents(::edu::vanderbilt::isis::meta::UnassembledComponentsType* unassembledcomponents) {
  delete unassembledcomponents_;
  unassembledcomponents_ = unassembledcomponents;
  if (unassembledcomponents) {
    set_has_unassembledcomponents();
  } else {
    clear_has_unassembledcomponents();
  }
}

// repeated .edu.vanderbilt.isis.meta.AssembliesType Assemblies = 5;
inline int AssembliesType::assemblies_size() const {
  return assemblies_.size();
}
inline void AssembliesType::clear_assemblies() {
  assemblies_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::AssembliesType& AssembliesType::assemblies(int index) const {
  return assemblies_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::AssembliesType* AssembliesType::mutable_assemblies(int index) {
  return assemblies_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::AssembliesType* AssembliesType::add_assemblies() {
  return assemblies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssembliesType >&
AssembliesType::assemblies() const {
  return assemblies_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::AssembliesType >*
AssembliesType::mutable_assemblies() {
  return &assemblies_;
}

// required string VersionInfo = 6;
inline bool AssembliesType::has_versioninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AssembliesType::set_has_versioninfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AssembliesType::clear_has_versioninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AssembliesType::clear_versioninfo() {
  if (versioninfo_ != &::google::protobuf::internal::kEmptyString) {
    versioninfo_->clear();
  }
  clear_has_versioninfo();
}
inline const ::std::string& AssembliesType::versioninfo() const {
  return *versioninfo_;
}
inline void AssembliesType::set_versioninfo(const ::std::string& value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void AssembliesType::set_versioninfo(const char* value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void AssembliesType::set_versioninfo(const char* value, size_t size) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssembliesType::mutable_versioninfo() {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  return versioninfo_;
}
inline ::std::string* AssembliesType::release_versioninfo() {
  clear_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versioninfo_;
    versioninfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AssembliesType::set_allocated_versioninfo(::std::string* versioninfo) {
  if (versioninfo_ != &::google::protobuf::internal::kEmptyString) {
    delete versioninfo_;
  }
  if (versioninfo) {
    set_has_versioninfo();
    versioninfo_ = versioninfo;
  } else {
    clear_has_versioninfo();
    versioninfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AssemblyType

// optional .edu.vanderbilt.isis.meta.AnalysesType Analyses = 1;
inline bool AssemblyType::has_analyses() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssemblyType::set_has_analyses() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssemblyType::clear_has_analyses() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssemblyType::clear_analyses() {
  if (analyses_ != NULL) analyses_->::edu::vanderbilt::isis::meta::AnalysesType::Clear();
  clear_has_analyses();
}
inline const ::edu::vanderbilt::isis::meta::AnalysesType& AssemblyType::analyses() const {
  return analyses_ != NULL ? *analyses_ : *default_instance_->analyses_;
}
inline ::edu::vanderbilt::isis::meta::AnalysesType* AssemblyType::mutable_analyses() {
  set_has_analyses();
  if (analyses_ == NULL) analyses_ = new ::edu::vanderbilt::isis::meta::AnalysesType;
  return analyses_;
}
inline ::edu::vanderbilt::isis::meta::AnalysesType* AssemblyType::release_analyses() {
  clear_has_analyses();
  ::edu::vanderbilt::isis::meta::AnalysesType* temp = analyses_;
  analyses_ = NULL;
  return temp;
}
inline void AssemblyType::set_allocated_analyses(::edu::vanderbilt::isis::meta::AnalysesType* analyses) {
  delete analyses_;
  analyses_ = analyses;
  if (analyses) {
    set_has_analyses();
  } else {
    clear_has_analyses();
  }
}

// optional .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 2;
inline bool AssemblyType::has_cadcomponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssemblyType::set_has_cadcomponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssemblyType::clear_has_cadcomponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssemblyType::clear_cadcomponent() {
  if (cadcomponent_ != NULL) cadcomponent_->::edu::vanderbilt::isis::meta::CADComponentType::Clear();
  clear_has_cadcomponent();
}
inline const ::edu::vanderbilt::isis::meta::CADComponentType& AssemblyType::cadcomponent() const {
  return cadcomponent_ != NULL ? *cadcomponent_ : *default_instance_->cadcomponent_;
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* AssemblyType::mutable_cadcomponent() {
  set_has_cadcomponent();
  if (cadcomponent_ == NULL) cadcomponent_ = new ::edu::vanderbilt::isis::meta::CADComponentType;
  return cadcomponent_;
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* AssemblyType::release_cadcomponent() {
  clear_has_cadcomponent();
  ::edu::vanderbilt::isis::meta::CADComponentType* temp = cadcomponent_;
  cadcomponent_ = NULL;
  return temp;
}
inline void AssemblyType::set_allocated_cadcomponent(::edu::vanderbilt::isis::meta::CADComponentType* cadcomponent) {
  delete cadcomponent_;
  cadcomponent_ = cadcomponent;
  if (cadcomponent) {
    set_has_cadcomponent();
  } else {
    clear_has_cadcomponent();
  }
}

// optional .edu.vanderbilt.isis.meta.ComputationsType Computations = 3;
inline bool AssemblyType::has_computations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssemblyType::set_has_computations() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssemblyType::clear_has_computations() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssemblyType::clear_computations() {
  if (computations_ != NULL) computations_->::edu::vanderbilt::isis::meta::ComputationsType::Clear();
  clear_has_computations();
}
inline const ::edu::vanderbilt::isis::meta::ComputationsType& AssemblyType::computations() const {
  return computations_ != NULL ? *computations_ : *default_instance_->computations_;
}
inline ::edu::vanderbilt::isis::meta::ComputationsType* AssemblyType::mutable_computations() {
  set_has_computations();
  if (computations_ == NULL) computations_ = new ::edu::vanderbilt::isis::meta::ComputationsType;
  return computations_;
}
inline ::edu::vanderbilt::isis::meta::ComputationsType* AssemblyType::release_computations() {
  clear_has_computations();
  ::edu::vanderbilt::isis::meta::ComputationsType* temp = computations_;
  computations_ = NULL;
  return temp;
}
inline void AssemblyType::set_allocated_computations(::edu::vanderbilt::isis::meta::ComputationsType* computations) {
  delete computations_;
  computations_ = computations;
  if (computations) {
    set_has_computations();
  } else {
    clear_has_computations();
  }
}

// required .edu.vanderbilt.isis.meta.PropertiesType Properties = 4;
inline bool AssemblyType::has_properties() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssemblyType::set_has_properties() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssemblyType::clear_has_properties() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssemblyType::clear_properties() {
  if (properties_ != NULL) properties_->::edu::vanderbilt::isis::meta::PropertiesType::Clear();
  clear_has_properties();
}
inline const ::edu::vanderbilt::isis::meta::PropertiesType& AssemblyType::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::edu::vanderbilt::isis::meta::PropertiesType* AssemblyType::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::edu::vanderbilt::isis::meta::PropertiesType;
  return properties_;
}
inline ::edu::vanderbilt::isis::meta::PropertiesType* AssemblyType::release_properties() {
  clear_has_properties();
  ::edu::vanderbilt::isis::meta::PropertiesType* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline void AssemblyType::set_allocated_properties(::edu::vanderbilt::isis::meta::PropertiesType* properties) {
  delete properties_;
  properties_ = properties;
  if (properties) {
    set_has_properties();
  } else {
    clear_has_properties();
  }
}

// required string ConfigurationID = 5;
inline bool AssemblyType::has_configurationid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssemblyType::set_has_configurationid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssemblyType::clear_has_configurationid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssemblyType::clear_configurationid() {
  if (configurationid_ != &::google::protobuf::internal::kEmptyString) {
    configurationid_->clear();
  }
  clear_has_configurationid();
}
inline const ::std::string& AssemblyType::configurationid() const {
  return *configurationid_;
}
inline void AssemblyType::set_configurationid(const ::std::string& value) {
  set_has_configurationid();
  if (configurationid_ == &::google::protobuf::internal::kEmptyString) {
    configurationid_ = new ::std::string;
  }
  configurationid_->assign(value);
}
inline void AssemblyType::set_configurationid(const char* value) {
  set_has_configurationid();
  if (configurationid_ == &::google::protobuf::internal::kEmptyString) {
    configurationid_ = new ::std::string;
  }
  configurationid_->assign(value);
}
inline void AssemblyType::set_configurationid(const char* value, size_t size) {
  set_has_configurationid();
  if (configurationid_ == &::google::protobuf::internal::kEmptyString) {
    configurationid_ = new ::std::string;
  }
  configurationid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssemblyType::mutable_configurationid() {
  set_has_configurationid();
  if (configurationid_ == &::google::protobuf::internal::kEmptyString) {
    configurationid_ = new ::std::string;
  }
  return configurationid_;
}
inline ::std::string* AssemblyType::release_configurationid() {
  clear_has_configurationid();
  if (configurationid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configurationid_;
    configurationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AssemblyType::set_allocated_configurationid(::std::string* configurationid) {
  if (configurationid_ != &::google::protobuf::internal::kEmptyString) {
    delete configurationid_;
  }
  if (configurationid) {
    set_has_configurationid();
    configurationid_ = configurationid;
  } else {
    clear_has_configurationid();
    configurationid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AxialDisplacementType

// required string Property = 1;
inline bool AxialDisplacementType::has_property() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxialDisplacementType::set_has_property() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxialDisplacementType::clear_has_property() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxialDisplacementType::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& AxialDisplacementType::property() const {
  return *property_;
}
inline void AxialDisplacementType::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void AxialDisplacementType::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void AxialDisplacementType::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AxialDisplacementType::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* AxialDisplacementType::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AxialDisplacementType::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AxialRotationType

// required string Property = 1;
inline bool AxialRotationType::has_property() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxialRotationType::set_has_property() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxialRotationType::clear_has_property() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxialRotationType::clear_property() {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& AxialRotationType::property() const {
  return *property_;
}
inline void AxialRotationType::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void AxialRotationType::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(value);
}
inline void AxialRotationType::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AxialRotationType::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    property_ = new ::std::string;
  }
  return property_;
}
inline ::std::string* AxialRotationType::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AxialRotationType::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::kEmptyString) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BallType

// -------------------------------------------------------------------

// BallisticType

// optional .edu.vanderbilt.isis.meta.ReferencePlaneType ReferencePlane = 1;
inline bool BallisticType::has_referenceplane() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallisticType::set_has_referenceplane() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallisticType::clear_has_referenceplane() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallisticType::clear_referenceplane() {
  if (referenceplane_ != NULL) referenceplane_->::edu::vanderbilt::isis::meta::ReferencePlaneType::Clear();
  clear_has_referenceplane();
}
inline const ::edu::vanderbilt::isis::meta::ReferencePlaneType& BallisticType::referenceplane() const {
  return referenceplane_ != NULL ? *referenceplane_ : *default_instance_->referenceplane_;
}
inline ::edu::vanderbilt::isis::meta::ReferencePlaneType* BallisticType::mutable_referenceplane() {
  set_has_referenceplane();
  if (referenceplane_ == NULL) referenceplane_ = new ::edu::vanderbilt::isis::meta::ReferencePlaneType;
  return referenceplane_;
}
inline ::edu::vanderbilt::isis::meta::ReferencePlaneType* BallisticType::release_referenceplane() {
  clear_has_referenceplane();
  ::edu::vanderbilt::isis::meta::ReferencePlaneType* temp = referenceplane_;
  referenceplane_ = NULL;
  return temp;
}
inline void BallisticType::set_allocated_referenceplane(::edu::vanderbilt::isis::meta::ReferencePlaneType* referenceplane) {
  delete referenceplane_;
  referenceplane_ = referenceplane;
  if (referenceplane) {
    set_has_referenceplane();
  } else {
    clear_has_referenceplane();
  }
}

// optional .edu.vanderbilt.isis.meta.ShotlinesType Shotlines = 2;
inline bool BallisticType::has_shotlines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallisticType::set_has_shotlines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallisticType::clear_has_shotlines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallisticType::clear_shotlines() {
  if (shotlines_ != NULL) shotlines_->::edu::vanderbilt::isis::meta::ShotlinesType::Clear();
  clear_has_shotlines();
}
inline const ::edu::vanderbilt::isis::meta::ShotlinesType& BallisticType::shotlines() const {
  return shotlines_ != NULL ? *shotlines_ : *default_instance_->shotlines_;
}
inline ::edu::vanderbilt::isis::meta::ShotlinesType* BallisticType::mutable_shotlines() {
  set_has_shotlines();
  if (shotlines_ == NULL) shotlines_ = new ::edu::vanderbilt::isis::meta::ShotlinesType;
  return shotlines_;
}
inline ::edu::vanderbilt::isis::meta::ShotlinesType* BallisticType::release_shotlines() {
  clear_has_shotlines();
  ::edu::vanderbilt::isis::meta::ShotlinesType* temp = shotlines_;
  shotlines_ = NULL;
  return temp;
}
inline void BallisticType::set_allocated_shotlines(::edu::vanderbilt::isis::meta::ShotlinesType* shotlines) {
  delete shotlines_;
  shotlines_ = shotlines;
  if (shotlines) {
    set_has_shotlines();
  } else {
    clear_has_shotlines();
  }
}

// required string AnalysisID = 3;
inline bool BallisticType::has_analysisid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallisticType::set_has_analysisid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallisticType::clear_has_analysisid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallisticType::clear_analysisid() {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    analysisid_->clear();
  }
  clear_has_analysisid();
}
inline const ::std::string& BallisticType::analysisid() const {
  return *analysisid_;
}
inline void BallisticType::set_analysisid(const ::std::string& value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void BallisticType::set_analysisid(const char* value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void BallisticType::set_analysisid(const char* value, size_t size) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BallisticType::mutable_analysisid() {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  return analysisid_;
}
inline ::std::string* BallisticType::release_analysisid() {
  clear_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = analysisid_;
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BallisticType::set_allocated_analysisid(::std::string* analysisid) {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    delete analysisid_;
  }
  if (analysisid) {
    set_has_analysisid();
    analysisid_ = analysisid;
  } else {
    clear_has_analysisid();
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BoundingBoxType

// required string ComponentID = 1;
inline bool BoundingBoxType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBoxType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBoxType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBoxType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& BoundingBoxType::componentid() const {
  return *componentid_;
}
inline void BoundingBoxType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void BoundingBoxType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void BoundingBoxType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoundingBoxType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* BoundingBoxType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoundingBoxType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MetricID = 2;
inline bool BoundingBoxType::has_metricid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBoxType::set_has_metricid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBoxType::clear_has_metricid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBoxType::clear_metricid() {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    metricid_->clear();
  }
  clear_has_metricid();
}
inline const ::std::string& BoundingBoxType::metricid() const {
  return *metricid_;
}
inline void BoundingBoxType::set_metricid(const ::std::string& value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void BoundingBoxType::set_metricid(const char* value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void BoundingBoxType::set_metricid(const char* value, size_t size) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoundingBoxType::mutable_metricid() {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  return metricid_;
}
inline ::std::string* BoundingBoxType::release_metricid() {
  clear_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metricid_;
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoundingBoxType::set_allocated_metricid(::std::string* metricid) {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    delete metricid_;
  }
  if (metricid) {
    set_has_metricid();
    metricid_ = metricid;
  } else {
    clear_has_metricid();
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RequestedValueType = 3;
inline bool BoundingBoxType::has_requestedvaluetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundingBoxType::set_has_requestedvaluetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundingBoxType::clear_has_requestedvaluetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundingBoxType::clear_requestedvaluetype() {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_->clear();
  }
  clear_has_requestedvaluetype();
}
inline const ::std::string& BoundingBoxType::requestedvaluetype() const {
  return *requestedvaluetype_;
}
inline void BoundingBoxType::set_requestedvaluetype(const ::std::string& value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void BoundingBoxType::set_requestedvaluetype(const char* value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void BoundingBoxType::set_requestedvaluetype(const char* value, size_t size) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoundingBoxType::mutable_requestedvaluetype() {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  return requestedvaluetype_;
}
inline ::std::string* BoundingBoxType::release_requestedvaluetype() {
  clear_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requestedvaluetype_;
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoundingBoxType::set_allocated_requestedvaluetype(::std::string* requestedvaluetype) {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    delete requestedvaluetype_;
  }
  if (requestedvaluetype) {
    set_has_requestedvaluetype();
    requestedvaluetype_ = requestedvaluetype;
  } else {
    clear_has_requestedvaluetype();
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CADComponentType

// repeated .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 1;
inline int CADComponentType::cadcomponent_size() const {
  return cadcomponent_.size();
}
inline void CADComponentType::clear_cadcomponent() {
  cadcomponent_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::CADComponentType& CADComponentType::cadcomponent(int index) const {
  return cadcomponent_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* CADComponentType::mutable_cadcomponent(int index) {
  return cadcomponent_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* CADComponentType::add_cadcomponent() {
  return cadcomponent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >&
CADComponentType::cadcomponent() const {
  return cadcomponent_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >*
CADComponentType::mutable_cadcomponent() {
  return &cadcomponent_;
}

// repeated .edu.vanderbilt.isis.meta.ConstraintType Constraint = 2;
inline int CADComponentType::constraint_size() const {
  return constraint_.size();
}
inline void CADComponentType::clear_constraint() {
  constraint_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ConstraintType& CADComponentType::constraint(int index) const {
  return constraint_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ConstraintType* CADComponentType::mutable_constraint(int index) {
  return constraint_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ConstraintType* CADComponentType::add_constraint() {
  return constraint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConstraintType >&
CADComponentType::constraint() const {
  return constraint_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConstraintType >*
CADComponentType::mutable_constraint() {
  return &constraint_;
}

// optional .edu.vanderbilt.isis.meta.KinematicConnectionsType KinematicConnections = 3;
inline bool CADComponentType::has_kinematicconnections() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CADComponentType::set_has_kinematicconnections() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CADComponentType::clear_has_kinematicconnections() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CADComponentType::clear_kinematicconnections() {
  if (kinematicconnections_ != NULL) kinematicconnections_->::edu::vanderbilt::isis::meta::KinematicConnectionsType::Clear();
  clear_has_kinematicconnections();
}
inline const ::edu::vanderbilt::isis::meta::KinematicConnectionsType& CADComponentType::kinematicconnections() const {
  return kinematicconnections_ != NULL ? *kinematicconnections_ : *default_instance_->kinematicconnections_;
}
inline ::edu::vanderbilt::isis::meta::KinematicConnectionsType* CADComponentType::mutable_kinematicconnections() {
  set_has_kinematicconnections();
  if (kinematicconnections_ == NULL) kinematicconnections_ = new ::edu::vanderbilt::isis::meta::KinematicConnectionsType;
  return kinematicconnections_;
}
inline ::edu::vanderbilt::isis::meta::KinematicConnectionsType* CADComponentType::release_kinematicconnections() {
  clear_has_kinematicconnections();
  ::edu::vanderbilt::isis::meta::KinematicConnectionsType* temp = kinematicconnections_;
  kinematicconnections_ = NULL;
  return temp;
}
inline void CADComponentType::set_allocated_kinematicconnections(::edu::vanderbilt::isis::meta::KinematicConnectionsType* kinematicconnections) {
  delete kinematicconnections_;
  kinematicconnections_ = kinematicconnections;
  if (kinematicconnections) {
    set_has_kinematicconnections();
  } else {
    clear_has_kinematicconnections();
  }
}

// optional .edu.vanderbilt.isis.meta.ParametricParametersType ParametricParameters = 4;
inline bool CADComponentType::has_parametricparameters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CADComponentType::set_has_parametricparameters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CADComponentType::clear_has_parametricparameters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CADComponentType::clear_parametricparameters() {
  if (parametricparameters_ != NULL) parametricparameters_->::edu::vanderbilt::isis::meta::ParametricParametersType::Clear();
  clear_has_parametricparameters();
}
inline const ::edu::vanderbilt::isis::meta::ParametricParametersType& CADComponentType::parametricparameters() const {
  return parametricparameters_ != NULL ? *parametricparameters_ : *default_instance_->parametricparameters_;
}
inline ::edu::vanderbilt::isis::meta::ParametricParametersType* CADComponentType::mutable_parametricparameters() {
  set_has_parametricparameters();
  if (parametricparameters_ == NULL) parametricparameters_ = new ::edu::vanderbilt::isis::meta::ParametricParametersType;
  return parametricparameters_;
}
inline ::edu::vanderbilt::isis::meta::ParametricParametersType* CADComponentType::release_parametricparameters() {
  clear_has_parametricparameters();
  ::edu::vanderbilt::isis::meta::ParametricParametersType* temp = parametricparameters_;
  parametricparameters_ = NULL;
  return temp;
}
inline void CADComponentType::set_allocated_parametricparameters(::edu::vanderbilt::isis::meta::ParametricParametersType* parametricparameters) {
  delete parametricparameters_;
  parametricparameters_ = parametricparameters;
  if (parametricparameters) {
    set_has_parametricparameters();
  } else {
    clear_has_parametricparameters();
  }
}

// repeated .edu.vanderbilt.isis.meta.ConnectorType Connectors = 14;
inline int CADComponentType::connectors_size() const {
  return connectors_.size();
}
inline void CADComponentType::clear_connectors() {
  connectors_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ConnectorType& CADComponentType::connectors(int index) const {
  return connectors_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorType* CADComponentType::mutable_connectors(int index) {
  return connectors_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorType* CADComponentType::add_connectors() {
  return connectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorType >&
CADComponentType::connectors() const {
  return connectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorType >*
CADComponentType::mutable_connectors() {
  return &connectors_;
}

// repeated .edu.vanderbilt.isis.meta.ConnectorDatumType Datums = 15;
inline int CADComponentType::datums_size() const {
  return datums_.size();
}
inline void CADComponentType::clear_datums() {
  datums_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ConnectorDatumType& CADComponentType::datums(int index) const {
  return datums_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* CADComponentType::mutable_datums(int index) {
  return datums_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* CADComponentType::add_datums() {
  return datums_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >&
CADComponentType::datums() const {
  return datums_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >*
CADComponentType::mutable_datums() {
  return &datums_;
}

// optional string ComponentID = 5;
inline bool CADComponentType::has_componentid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CADComponentType::set_has_componentid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CADComponentType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CADComponentType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& CADComponentType::componentid() const {
  return *componentid_;
}
inline void CADComponentType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void CADComponentType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void CADComponentType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* CADComponentType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AvmComponentID = 11;
inline bool CADComponentType::has_avmcomponentid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CADComponentType::set_has_avmcomponentid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CADComponentType::clear_has_avmcomponentid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CADComponentType::clear_avmcomponentid() {
  if (avmcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    avmcomponentid_->clear();
  }
  clear_has_avmcomponentid();
}
inline const ::std::string& CADComponentType::avmcomponentid() const {
  return *avmcomponentid_;
}
inline void CADComponentType::set_avmcomponentid(const ::std::string& value) {
  set_has_avmcomponentid();
  if (avmcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    avmcomponentid_ = new ::std::string;
  }
  avmcomponentid_->assign(value);
}
inline void CADComponentType::set_avmcomponentid(const char* value) {
  set_has_avmcomponentid();
  if (avmcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    avmcomponentid_ = new ::std::string;
  }
  avmcomponentid_->assign(value);
}
inline void CADComponentType::set_avmcomponentid(const char* value, size_t size) {
  set_has_avmcomponentid();
  if (avmcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    avmcomponentid_ = new ::std::string;
  }
  avmcomponentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_avmcomponentid() {
  set_has_avmcomponentid();
  if (avmcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    avmcomponentid_ = new ::std::string;
  }
  return avmcomponentid_;
}
inline ::std::string* CADComponentType::release_avmcomponentid() {
  clear_has_avmcomponentid();
  if (avmcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avmcomponentid_;
    avmcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_avmcomponentid(::std::string* avmcomponentid) {
  if (avmcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    delete avmcomponentid_;
  }
  if (avmcomponentid) {
    set_has_avmcomponentid();
    avmcomponentid_ = avmcomponentid;
  } else {
    clear_has_avmcomponentid();
    avmcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MaterialID = 6;
inline bool CADComponentType::has_materialid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CADComponentType::set_has_materialid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CADComponentType::clear_has_materialid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CADComponentType::clear_materialid() {
  if (materialid_ != &::google::protobuf::internal::kEmptyString) {
    materialid_->clear();
  }
  clear_has_materialid();
}
inline const ::std::string& CADComponentType::materialid() const {
  return *materialid_;
}
inline void CADComponentType::set_materialid(const ::std::string& value) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(value);
}
inline void CADComponentType::set_materialid(const char* value) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(value);
}
inline void CADComponentType::set_materialid(const char* value, size_t size) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_materialid() {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  return materialid_;
}
inline ::std::string* CADComponentType::release_materialid() {
  clear_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = materialid_;
    materialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_materialid(::std::string* materialid) {
  if (materialid_ != &::google::protobuf::internal::kEmptyString) {
    delete materialid_;
  }
  if (materialid) {
    set_has_materialid();
    materialid_ = materialid;
  } else {
    clear_has_materialid();
    materialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Name = 7;
inline bool CADComponentType::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CADComponentType::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CADComponentType::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CADComponentType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CADComponentType::name() const {
  return *name_;
}
inline void CADComponentType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CADComponentType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CADComponentType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CADComponentType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SpecialInstruction = 8;
inline bool CADComponentType::has_specialinstruction() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CADComponentType::set_has_specialinstruction() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CADComponentType::clear_has_specialinstruction() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CADComponentType::clear_specialinstruction() {
  if (specialinstruction_ != &::google::protobuf::internal::kEmptyString) {
    specialinstruction_->clear();
  }
  clear_has_specialinstruction();
}
inline const ::std::string& CADComponentType::specialinstruction() const {
  return *specialinstruction_;
}
inline void CADComponentType::set_specialinstruction(const ::std::string& value) {
  set_has_specialinstruction();
  if (specialinstruction_ == &::google::protobuf::internal::kEmptyString) {
    specialinstruction_ = new ::std::string;
  }
  specialinstruction_->assign(value);
}
inline void CADComponentType::set_specialinstruction(const char* value) {
  set_has_specialinstruction();
  if (specialinstruction_ == &::google::protobuf::internal::kEmptyString) {
    specialinstruction_ = new ::std::string;
  }
  specialinstruction_->assign(value);
}
inline void CADComponentType::set_specialinstruction(const char* value, size_t size) {
  set_has_specialinstruction();
  if (specialinstruction_ == &::google::protobuf::internal::kEmptyString) {
    specialinstruction_ = new ::std::string;
  }
  specialinstruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_specialinstruction() {
  set_has_specialinstruction();
  if (specialinstruction_ == &::google::protobuf::internal::kEmptyString) {
    specialinstruction_ = new ::std::string;
  }
  return specialinstruction_;
}
inline ::std::string* CADComponentType::release_specialinstruction() {
  clear_has_specialinstruction();
  if (specialinstruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = specialinstruction_;
    specialinstruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_specialinstruction(::std::string* specialinstruction) {
  if (specialinstruction_ != &::google::protobuf::internal::kEmptyString) {
    delete specialinstruction_;
  }
  if (specialinstruction) {
    set_has_specialinstruction();
    specialinstruction_ = specialinstruction;
  } else {
    clear_has_specialinstruction();
    specialinstruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool Standalone = 9;
inline bool CADComponentType::has_standalone() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CADComponentType::set_has_standalone() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CADComponentType::clear_has_standalone() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CADComponentType::clear_standalone() {
  standalone_ = false;
  clear_has_standalone();
}
inline bool CADComponentType::standalone() const {
  return standalone_;
}
inline void CADComponentType::set_standalone(bool value) {
  set_has_standalone();
  standalone_ = value;
}

// optional string Type = 10;
inline bool CADComponentType::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CADComponentType::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CADComponentType::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CADComponentType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CADComponentType::type() const {
  return *type_;
}
inline void CADComponentType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CADComponentType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CADComponentType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* CADComponentType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CADModelID = 12;
inline bool CADComponentType::has_cadmodelid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CADComponentType::set_has_cadmodelid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CADComponentType::clear_has_cadmodelid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CADComponentType::clear_cadmodelid() {
  if (cadmodelid_ != &::google::protobuf::internal::kEmptyString) {
    cadmodelid_->clear();
  }
  clear_has_cadmodelid();
}
inline const ::std::string& CADComponentType::cadmodelid() const {
  return *cadmodelid_;
}
inline void CADComponentType::set_cadmodelid(const ::std::string& value) {
  set_has_cadmodelid();
  if (cadmodelid_ == &::google::protobuf::internal::kEmptyString) {
    cadmodelid_ = new ::std::string;
  }
  cadmodelid_->assign(value);
}
inline void CADComponentType::set_cadmodelid(const char* value) {
  set_has_cadmodelid();
  if (cadmodelid_ == &::google::protobuf::internal::kEmptyString) {
    cadmodelid_ = new ::std::string;
  }
  cadmodelid_->assign(value);
}
inline void CADComponentType::set_cadmodelid(const char* value, size_t size) {
  set_has_cadmodelid();
  if (cadmodelid_ == &::google::protobuf::internal::kEmptyString) {
    cadmodelid_ = new ::std::string;
  }
  cadmodelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_cadmodelid() {
  set_has_cadmodelid();
  if (cadmodelid_ == &::google::protobuf::internal::kEmptyString) {
    cadmodelid_ = new ::std::string;
  }
  return cadmodelid_;
}
inline ::std::string* CADComponentType::release_cadmodelid() {
  clear_has_cadmodelid();
  if (cadmodelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cadmodelid_;
    cadmodelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_cadmodelid(::std::string* cadmodelid) {
  if (cadmodelid_ != &::google::protobuf::internal::kEmptyString) {
    delete cadmodelid_;
  }
  if (cadmodelid) {
    set_has_cadmodelid();
    cadmodelid_ = cadmodelid;
  } else {
    clear_has_cadmodelid();
    cadmodelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DisplayName = 13;
inline bool CADComponentType::has_displayname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CADComponentType::set_has_displayname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CADComponentType::clear_has_displayname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CADComponentType::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& CADComponentType::displayname() const {
  return *displayname_;
}
inline void CADComponentType::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void CADComponentType::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void CADComponentType::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADComponentType::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* CADComponentType::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADComponentType::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CADParameterType

// optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
inline bool CADParameterType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CADParameterType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CADParameterType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CADParameterType::clear_units() {
  if (units_ != NULL) units_->::edu::vanderbilt::isis::meta::UnitsType::Clear();
  clear_has_units();
}
inline const ::edu::vanderbilt::isis::meta::UnitsType& CADParameterType::units() const {
  return units_ != NULL ? *units_ : *default_instance_->units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* CADParameterType::mutable_units() {
  set_has_units();
  if (units_ == NULL) units_ = new ::edu::vanderbilt::isis::meta::UnitsType;
  return units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* CADParameterType::release_units() {
  clear_has_units();
  ::edu::vanderbilt::isis::meta::UnitsType* temp = units_;
  units_ = NULL;
  return temp;
}
inline void CADParameterType::set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units) {
  delete units_;
  units_ = units;
  if (units) {
    set_has_units();
  } else {
    clear_has_units();
  }
}

// required string Name = 2;
inline bool CADParameterType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CADParameterType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CADParameterType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CADParameterType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CADParameterType::name() const {
  return *name_;
}
inline void CADParameterType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CADParameterType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CADParameterType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADParameterType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CADParameterType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADParameterType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 3;
inline bool CADParameterType::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CADParameterType::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CADParameterType::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CADParameterType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CADParameterType::type() const {
  return *type_;
}
inline void CADParameterType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CADParameterType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CADParameterType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADParameterType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* CADParameterType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADParameterType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Value = 4;
inline bool CADParameterType::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CADParameterType::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CADParameterType::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CADParameterType::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CADParameterType::value() const {
  return *value_;
}
inline void CADParameterType::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CADParameterType::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CADParameterType::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CADParameterType::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CADParameterType::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CADParameterType::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CenterOfGravityType

// required string ComponentID = 1;
inline bool CenterOfGravityType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterOfGravityType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterOfGravityType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterOfGravityType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& CenterOfGravityType::componentid() const {
  return *componentid_;
}
inline void CenterOfGravityType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void CenterOfGravityType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void CenterOfGravityType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterOfGravityType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* CenterOfGravityType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterOfGravityType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MetricID = 2;
inline bool CenterOfGravityType::has_metricid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterOfGravityType::set_has_metricid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterOfGravityType::clear_has_metricid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterOfGravityType::clear_metricid() {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    metricid_->clear();
  }
  clear_has_metricid();
}
inline const ::std::string& CenterOfGravityType::metricid() const {
  return *metricid_;
}
inline void CenterOfGravityType::set_metricid(const ::std::string& value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void CenterOfGravityType::set_metricid(const char* value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void CenterOfGravityType::set_metricid(const char* value, size_t size) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterOfGravityType::mutable_metricid() {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  return metricid_;
}
inline ::std::string* CenterOfGravityType::release_metricid() {
  clear_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metricid_;
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterOfGravityType::set_allocated_metricid(::std::string* metricid) {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    delete metricid_;
  }
  if (metricid) {
    set_has_metricid();
    metricid_ = metricid;
  } else {
    clear_has_metricid();
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RequestedValueType = 3;
inline bool CenterOfGravityType::has_requestedvaluetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CenterOfGravityType::set_has_requestedvaluetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CenterOfGravityType::clear_has_requestedvaluetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CenterOfGravityType::clear_requestedvaluetype() {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_->clear();
  }
  clear_has_requestedvaluetype();
}
inline const ::std::string& CenterOfGravityType::requestedvaluetype() const {
  return *requestedvaluetype_;
}
inline void CenterOfGravityType::set_requestedvaluetype(const ::std::string& value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void CenterOfGravityType::set_requestedvaluetype(const char* value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void CenterOfGravityType::set_requestedvaluetype(const char* value, size_t size) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterOfGravityType::mutable_requestedvaluetype() {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  return requestedvaluetype_;
}
inline ::std::string* CenterOfGravityType::release_requestedvaluetype() {
  clear_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requestedvaluetype_;
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterOfGravityType::set_allocated_requestedvaluetype(::std::string* requestedvaluetype) {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    delete requestedvaluetype_;
  }
  if (requestedvaluetype) {
    set_has_requestedvaluetype();
    requestedvaluetype_ = requestedvaluetype;
  } else {
    clear_has_requestedvaluetype();
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ComponentType

// optional .edu.vanderbilt.isis.meta.MetricsType Metrics = 1;
inline bool ComponentType::has_metrics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComponentType::set_has_metrics() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComponentType::clear_has_metrics() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComponentType::clear_metrics() {
  if (metrics_ != NULL) metrics_->::edu::vanderbilt::isis::meta::MetricsType::Clear();
  clear_has_metrics();
}
inline const ::edu::vanderbilt::isis::meta::MetricsType& ComponentType::metrics() const {
  return metrics_ != NULL ? *metrics_ : *default_instance_->metrics_;
}
inline ::edu::vanderbilt::isis::meta::MetricsType* ComponentType::mutable_metrics() {
  set_has_metrics();
  if (metrics_ == NULL) metrics_ = new ::edu::vanderbilt::isis::meta::MetricsType;
  return metrics_;
}
inline ::edu::vanderbilt::isis::meta::MetricsType* ComponentType::release_metrics() {
  clear_has_metrics();
  ::edu::vanderbilt::isis::meta::MetricsType* temp = metrics_;
  metrics_ = NULL;
  return temp;
}
inline void ComponentType::set_allocated_metrics(::edu::vanderbilt::isis::meta::MetricsType* metrics) {
  delete metrics_;
  metrics_ = metrics;
  if (metrics) {
    set_has_metrics();
  } else {
    clear_has_metrics();
  }
}

// required string ComponentID = 2;
inline bool ComponentType::has_componentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComponentType::set_has_componentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComponentType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComponentType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& ComponentType::componentid() const {
  return *componentid_;
}
inline void ComponentType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ComponentType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ComponentType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComponentType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* ComponentType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ComponentType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool InfiniteCycle = 3;
inline bool ComponentType::has_infinitecycle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComponentType::set_has_infinitecycle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComponentType::clear_has_infinitecycle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComponentType::clear_infinitecycle() {
  infinitecycle_ = false;
  clear_has_infinitecycle();
}
inline bool ComponentType::infinitecycle() const {
  return infinitecycle_;
}
inline void ComponentType::set_infinitecycle(bool value) {
  set_has_infinitecycle();
  infinitecycle_ = value;
}

// -------------------------------------------------------------------

// ComputationsType

// repeated .edu.vanderbilt.isis.meta.BoundingBoxType BoundingBox = 1;
inline int ComputationsType::boundingbox_size() const {
  return boundingbox_.size();
}
inline void ComputationsType::clear_boundingbox() {
  boundingbox_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::BoundingBoxType& ComputationsType::boundingbox(int index) const {
  return boundingbox_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::BoundingBoxType* ComputationsType::mutable_boundingbox(int index) {
  return boundingbox_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::BoundingBoxType* ComputationsType::add_boundingbox() {
  return boundingbox_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BoundingBoxType >&
ComputationsType::boundingbox() const {
  return boundingbox_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::BoundingBoxType >*
ComputationsType::mutable_boundingbox() {
  return &boundingbox_;
}

// repeated .edu.vanderbilt.isis.meta.CenterOfGravityType CenterOfGravity = 2;
inline int ComputationsType::centerofgravity_size() const {
  return centerofgravity_.size();
}
inline void ComputationsType::clear_centerofgravity() {
  centerofgravity_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::CenterOfGravityType& ComputationsType::centerofgravity(int index) const {
  return centerofgravity_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::CenterOfGravityType* ComputationsType::mutable_centerofgravity(int index) {
  return centerofgravity_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::CenterOfGravityType* ComputationsType::add_centerofgravity() {
  return centerofgravity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CenterOfGravityType >&
ComputationsType::centerofgravity() const {
  return centerofgravity_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CenterOfGravityType >*
ComputationsType::mutable_centerofgravity() {
  return &centerofgravity_;
}

// repeated .edu.vanderbilt.isis.meta.MassType Mass = 3;
inline int ComputationsType::mass_size() const {
  return mass_.size();
}
inline void ComputationsType::clear_mass() {
  mass_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::MassType& ComputationsType::mass(int index) const {
  return mass_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::MassType* ComputationsType::mutable_mass(int index) {
  return mass_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::MassType* ComputationsType::add_mass() {
  return mass_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MassType >&
ComputationsType::mass() const {
  return mass_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MassType >*
ComputationsType::mutable_mass() {
  return &mass_;
}

// repeated .edu.vanderbilt.isis.meta.PointCoordinatesType PointCoordinates = 4;
inline int ComputationsType::pointcoordinates_size() const {
  return pointcoordinates_.size();
}
inline void ComputationsType::clear_pointcoordinates() {
  pointcoordinates_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::PointCoordinatesType& ComputationsType::pointcoordinates(int index) const {
  return pointcoordinates_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::PointCoordinatesType* ComputationsType::mutable_pointcoordinates(int index) {
  return pointcoordinates_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::PointCoordinatesType* ComputationsType::add_pointcoordinates() {
  return pointcoordinates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PointCoordinatesType >&
ComputationsType::pointcoordinates() const {
  return pointcoordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PointCoordinatesType >*
ComputationsType::mutable_pointcoordinates() {
  return &pointcoordinates_;
}

// -------------------------------------------------------------------

// ConditionType

// required string Name = 1;
inline bool ConditionType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConditionType::name() const {
  return *name_;
}
inline void ConditionType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConditionType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConditionType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConditionType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConditionType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConditionType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Units = 2;
inline bool ConditionType::has_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionType::set_has_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionType::clear_has_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& ConditionType::units() const {
  return *units_;
}
inline void ConditionType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void ConditionType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void ConditionType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConditionType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* ConditionType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConditionType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double Value = 3;
inline bool ConditionType::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConditionType::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConditionType::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConditionType::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double ConditionType::value() const {
  return value_;
}
inline void ConditionType::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ConditionsType

// repeated .edu.vanderbilt.isis.meta.ConditionType Condition = 1;
inline int ConditionsType::condition_size() const {
  return condition_.size();
}
inline void ConditionsType::clear_condition() {
  condition_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ConditionType& ConditionsType::condition(int index) const {
  return condition_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ConditionType* ConditionsType::mutable_condition(int index) {
  return condition_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ConditionType* ConditionsType::add_condition() {
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConditionType >&
ConditionsType::condition() const {
  return condition_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConditionType >*
ConditionsType::mutable_condition() {
  return &condition_;
}

// -------------------------------------------------------------------

// ConnectorDatumType

// optional .edu.vanderbilt.isis.meta.ConnectorDatumType.AlignType Alignment = 3;
inline bool ConnectorDatumType::has_alignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectorDatumType::set_has_alignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectorDatumType::clear_has_alignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectorDatumType::clear_alignment() {
  alignment_ = 0;
  clear_has_alignment();
}
inline ::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType ConnectorDatumType::alignment() const {
  return static_cast< ::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType >(alignment_);
}
inline void ConnectorDatumType::set_alignment(::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType value) {
  assert(::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType_IsValid(value));
  set_has_alignment();
  alignment_ = value;
}

// optional string ID = 1;
inline bool ConnectorDatumType::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectorDatumType::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectorDatumType::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectorDatumType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConnectorDatumType::id() const {
  return *id_;
}
inline void ConnectorDatumType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConnectorDatumType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConnectorDatumType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectorDatumType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConnectorDatumType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectorDatumType::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DisplayName = 2;
inline bool ConnectorDatumType::has_displayname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectorDatumType::set_has_displayname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectorDatumType::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectorDatumType::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ConnectorDatumType::displayname() const {
  return *displayname_;
}
inline void ConnectorDatumType::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ConnectorDatumType::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ConnectorDatumType::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectorDatumType::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ConnectorDatumType::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectorDatumType::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectorType

// required string ID = 1;
inline bool ConnectorType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectorType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectorType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectorType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConnectorType::id() const {
  return *id_;
}
inline void ConnectorType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConnectorType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConnectorType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectorType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConnectorType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectorType::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DisplayName = 2;
inline bool ConnectorType::has_displayname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectorType::set_has_displayname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectorType::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectorType::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ConnectorType::displayname() const {
  return *displayname_;
}
inline void ConnectorType::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ConnectorType::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ConnectorType::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectorType::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ConnectorType::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectorType::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .edu.vanderbilt.isis.meta.ConnectorDatumType Datums = 3;
inline int ConnectorType::datums_size() const {
  return datums_.size();
}
inline void ConnectorType::clear_datums() {
  datums_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ConnectorDatumType& ConnectorType::datums(int index) const {
  return datums_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* ConnectorType::mutable_datums(int index) {
  return datums_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ConnectorDatumType* ConnectorType::add_datums() {
  return datums_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >&
ConnectorType::datums() const {
  return datums_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ConnectorDatumType >*
ConnectorType::mutable_datums() {
  return &datums_;
}

// -------------------------------------------------------------------

// ConstraintFeatureType

// required string ComponentID = 1;
inline bool ConstraintFeatureType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstraintFeatureType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstraintFeatureType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstraintFeatureType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& ConstraintFeatureType::componentid() const {
  return *componentid_;
}
inline void ConstraintFeatureType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ConstraintFeatureType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ConstraintFeatureType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConstraintFeatureType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* ConstraintFeatureType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConstraintFeatureType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureName = 2;
inline bool ConstraintFeatureType::has_featurename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstraintFeatureType::set_has_featurename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstraintFeatureType::clear_has_featurename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConstraintFeatureType::clear_featurename() {
  if (featurename_ != &::google::protobuf::internal::kEmptyString) {
    featurename_->clear();
  }
  clear_has_featurename();
}
inline const ::std::string& ConstraintFeatureType::featurename() const {
  return *featurename_;
}
inline void ConstraintFeatureType::set_featurename(const ::std::string& value) {
  set_has_featurename();
  if (featurename_ == &::google::protobuf::internal::kEmptyString) {
    featurename_ = new ::std::string;
  }
  featurename_->assign(value);
}
inline void ConstraintFeatureType::set_featurename(const char* value) {
  set_has_featurename();
  if (featurename_ == &::google::protobuf::internal::kEmptyString) {
    featurename_ = new ::std::string;
  }
  featurename_->assign(value);
}
inline void ConstraintFeatureType::set_featurename(const char* value, size_t size) {
  set_has_featurename();
  if (featurename_ == &::google::protobuf::internal::kEmptyString) {
    featurename_ = new ::std::string;
  }
  featurename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConstraintFeatureType::mutable_featurename() {
  set_has_featurename();
  if (featurename_ == &::google::protobuf::internal::kEmptyString) {
    featurename_ = new ::std::string;
  }
  return featurename_;
}
inline ::std::string* ConstraintFeatureType::release_featurename() {
  clear_has_featurename();
  if (featurename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featurename_;
    featurename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConstraintFeatureType::set_allocated_featurename(::std::string* featurename) {
  if (featurename_ != &::google::protobuf::internal::kEmptyString) {
    delete featurename_;
  }
  if (featurename) {
    set_has_featurename();
    featurename_ = featurename;
  } else {
    clear_has_featurename();
    featurename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureOrientationType = 3;
inline bool ConstraintFeatureType::has_featureorientationtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConstraintFeatureType::set_has_featureorientationtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConstraintFeatureType::clear_has_featureorientationtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConstraintFeatureType::clear_featureorientationtype() {
  if (featureorientationtype_ != &::google::protobuf::internal::kEmptyString) {
    featureorientationtype_->clear();
  }
  clear_has_featureorientationtype();
}
inline const ::std::string& ConstraintFeatureType::featureorientationtype() const {
  return *featureorientationtype_;
}
inline void ConstraintFeatureType::set_featureorientationtype(const ::std::string& value) {
  set_has_featureorientationtype();
  if (featureorientationtype_ == &::google::protobuf::internal::kEmptyString) {
    featureorientationtype_ = new ::std::string;
  }
  featureorientationtype_->assign(value);
}
inline void ConstraintFeatureType::set_featureorientationtype(const char* value) {
  set_has_featureorientationtype();
  if (featureorientationtype_ == &::google::protobuf::internal::kEmptyString) {
    featureorientationtype_ = new ::std::string;
  }
  featureorientationtype_->assign(value);
}
inline void ConstraintFeatureType::set_featureorientationtype(const char* value, size_t size) {
  set_has_featureorientationtype();
  if (featureorientationtype_ == &::google::protobuf::internal::kEmptyString) {
    featureorientationtype_ = new ::std::string;
  }
  featureorientationtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConstraintFeatureType::mutable_featureorientationtype() {
  set_has_featureorientationtype();
  if (featureorientationtype_ == &::google::protobuf::internal::kEmptyString) {
    featureorientationtype_ = new ::std::string;
  }
  return featureorientationtype_;
}
inline ::std::string* ConstraintFeatureType::release_featureorientationtype() {
  clear_has_featureorientationtype();
  if (featureorientationtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureorientationtype_;
    featureorientationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConstraintFeatureType::set_allocated_featureorientationtype(::std::string* featureorientationtype) {
  if (featureorientationtype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureorientationtype_;
  }
  if (featureorientationtype) {
    set_has_featureorientationtype();
    featureorientationtype_ = featureorientationtype;
  } else {
    clear_has_featureorientationtype();
    featureorientationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConstraintOffsetType

// optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
inline bool ConstraintOffsetType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstraintOffsetType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstraintOffsetType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstraintOffsetType::clear_units() {
  if (units_ != NULL) units_->::edu::vanderbilt::isis::meta::UnitsType::Clear();
  clear_has_units();
}
inline const ::edu::vanderbilt::isis::meta::UnitsType& ConstraintOffsetType::units() const {
  return units_ != NULL ? *units_ : *default_instance_->units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* ConstraintOffsetType::mutable_units() {
  set_has_units();
  if (units_ == NULL) units_ = new ::edu::vanderbilt::isis::meta::UnitsType;
  return units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* ConstraintOffsetType::release_units() {
  clear_has_units();
  ::edu::vanderbilt::isis::meta::UnitsType* temp = units_;
  units_ = NULL;
  return temp;
}
inline void ConstraintOffsetType::set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units) {
  delete units_;
  units_ = units;
  if (units) {
    set_has_units();
  } else {
    clear_has_units();
  }
}

// required string OffsetAlignmentType = 2;
inline bool ConstraintOffsetType::has_offsetalignmenttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstraintOffsetType::set_has_offsetalignmenttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstraintOffsetType::clear_has_offsetalignmenttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConstraintOffsetType::clear_offsetalignmenttype() {
  if (offsetalignmenttype_ != &::google::protobuf::internal::kEmptyString) {
    offsetalignmenttype_->clear();
  }
  clear_has_offsetalignmenttype();
}
inline const ::std::string& ConstraintOffsetType::offsetalignmenttype() const {
  return *offsetalignmenttype_;
}
inline void ConstraintOffsetType::set_offsetalignmenttype(const ::std::string& value) {
  set_has_offsetalignmenttype();
  if (offsetalignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    offsetalignmenttype_ = new ::std::string;
  }
  offsetalignmenttype_->assign(value);
}
inline void ConstraintOffsetType::set_offsetalignmenttype(const char* value) {
  set_has_offsetalignmenttype();
  if (offsetalignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    offsetalignmenttype_ = new ::std::string;
  }
  offsetalignmenttype_->assign(value);
}
inline void ConstraintOffsetType::set_offsetalignmenttype(const char* value, size_t size) {
  set_has_offsetalignmenttype();
  if (offsetalignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    offsetalignmenttype_ = new ::std::string;
  }
  offsetalignmenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConstraintOffsetType::mutable_offsetalignmenttype() {
  set_has_offsetalignmenttype();
  if (offsetalignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    offsetalignmenttype_ = new ::std::string;
  }
  return offsetalignmenttype_;
}
inline ::std::string* ConstraintOffsetType::release_offsetalignmenttype() {
  clear_has_offsetalignmenttype();
  if (offsetalignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offsetalignmenttype_;
    offsetalignmenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConstraintOffsetType::set_allocated_offsetalignmenttype(::std::string* offsetalignmenttype) {
  if (offsetalignmenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete offsetalignmenttype_;
  }
  if (offsetalignmenttype) {
    set_has_offsetalignmenttype();
    offsetalignmenttype_ = offsetalignmenttype;
  } else {
    clear_has_offsetalignmenttype();
    offsetalignmenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double Value = 3;
inline bool ConstraintOffsetType::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConstraintOffsetType::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConstraintOffsetType::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConstraintOffsetType::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double ConstraintOffsetType::value() const {
  return value_;
}
inline void ConstraintOffsetType::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ConstraintType

// repeated .edu.vanderbilt.isis.meta.PairType Pair = 1;
inline int ConstraintType::pair_size() const {
  return pair_.size();
}
inline void ConstraintType::clear_pair() {
  pair_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::PairType& ConstraintType::pair(int index) const {
  return pair_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::PairType* ConstraintType::mutable_pair(int index) {
  return pair_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::PairType* ConstraintType::add_pair() {
  return pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PairType >&
ConstraintType::pair() const {
  return pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PairType >*
ConstraintType::mutable_pair() {
  return &pair_;
}

// optional string ComponentID = 2;
inline bool ConstraintType::has_componentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstraintType::set_has_componentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstraintType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConstraintType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& ConstraintType::componentid() const {
  return *componentid_;
}
inline void ConstraintType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ConstraintType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ConstraintType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConstraintType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* ConstraintType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConstraintType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DataExchangeType

// repeated .edu.vanderbilt.isis.meta.STEPFormatType STEPFormat = 1;
inline int DataExchangeType::stepformat_size() const {
  return stepformat_.size();
}
inline void DataExchangeType::clear_stepformat() {
  stepformat_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::STEPFormatType& DataExchangeType::stepformat(int index) const {
  return stepformat_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::STEPFormatType* DataExchangeType::mutable_stepformat(int index) {
  return stepformat_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::STEPFormatType* DataExchangeType::add_stepformat() {
  return stepformat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::STEPFormatType >&
DataExchangeType::stepformat() const {
  return stepformat_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::STEPFormatType >*
DataExchangeType::mutable_stepformat() {
  return &stepformat_;
}

// -------------------------------------------------------------------

// DisplacementType

// required .edu.vanderbilt.isis.meta.RotationType Rotation = 1;
inline bool DisplacementType::has_rotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplacementType::set_has_rotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisplacementType::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisplacementType::clear_rotation() {
  if (rotation_ != NULL) rotation_->::edu::vanderbilt::isis::meta::RotationType::Clear();
  clear_has_rotation();
}
inline const ::edu::vanderbilt::isis::meta::RotationType& DisplacementType::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::edu::vanderbilt::isis::meta::RotationType* DisplacementType::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::edu::vanderbilt::isis::meta::RotationType;
  return rotation_;
}
inline ::edu::vanderbilt::isis::meta::RotationType* DisplacementType::release_rotation() {
  clear_has_rotation();
  ::edu::vanderbilt::isis::meta::RotationType* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void DisplacementType::set_allocated_rotation(::edu::vanderbilt::isis::meta::RotationType* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
}

// required .edu.vanderbilt.isis.meta.TranslationType Translation = 2;
inline bool DisplacementType::has_translation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplacementType::set_has_translation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplacementType::clear_has_translation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplacementType::clear_translation() {
  if (translation_ != NULL) translation_->::edu::vanderbilt::isis::meta::TranslationType::Clear();
  clear_has_translation();
}
inline const ::edu::vanderbilt::isis::meta::TranslationType& DisplacementType::translation() const {
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
}
inline ::edu::vanderbilt::isis::meta::TranslationType* DisplacementType::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::edu::vanderbilt::isis::meta::TranslationType;
  return translation_;
}
inline ::edu::vanderbilt::isis::meta::TranslationType* DisplacementType::release_translation() {
  clear_has_translation();
  ::edu::vanderbilt::isis::meta::TranslationType* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void DisplacementType::set_allocated_translation(::edu::vanderbilt::isis::meta::TranslationType* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
}

// -------------------------------------------------------------------

// FEAType

// optional .edu.vanderbilt.isis.meta.AnalysisComponentsType AnalysisComponents = 1;
inline bool FEAType::has_analysiscomponents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FEAType::set_has_analysiscomponents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FEAType::clear_has_analysiscomponents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FEAType::clear_analysiscomponents() {
  if (analysiscomponents_ != NULL) analysiscomponents_->::edu::vanderbilt::isis::meta::AnalysisComponentsType::Clear();
  clear_has_analysiscomponents();
}
inline const ::edu::vanderbilt::isis::meta::AnalysisComponentsType& FEAType::analysiscomponents() const {
  return analysiscomponents_ != NULL ? *analysiscomponents_ : *default_instance_->analysiscomponents_;
}
inline ::edu::vanderbilt::isis::meta::AnalysisComponentsType* FEAType::mutable_analysiscomponents() {
  set_has_analysiscomponents();
  if (analysiscomponents_ == NULL) analysiscomponents_ = new ::edu::vanderbilt::isis::meta::AnalysisComponentsType;
  return analysiscomponents_;
}
inline ::edu::vanderbilt::isis::meta::AnalysisComponentsType* FEAType::release_analysiscomponents() {
  clear_has_analysiscomponents();
  ::edu::vanderbilt::isis::meta::AnalysisComponentsType* temp = analysiscomponents_;
  analysiscomponents_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_analysiscomponents(::edu::vanderbilt::isis::meta::AnalysisComponentsType* analysiscomponents) {
  delete analysiscomponents_;
  analysiscomponents_ = analysiscomponents;
  if (analysiscomponents) {
    set_has_analysiscomponents();
  } else {
    clear_has_analysiscomponents();
  }
}

// optional .edu.vanderbilt.isis.meta.AnalysisConstraintsType AnalysisConstraints = 2;
inline bool FEAType::has_analysisconstraints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FEAType::set_has_analysisconstraints() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FEAType::clear_has_analysisconstraints() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FEAType::clear_analysisconstraints() {
  if (analysisconstraints_ != NULL) analysisconstraints_->::edu::vanderbilt::isis::meta::AnalysisConstraintsType::Clear();
  clear_has_analysisconstraints();
}
inline const ::edu::vanderbilt::isis::meta::AnalysisConstraintsType& FEAType::analysisconstraints() const {
  return analysisconstraints_ != NULL ? *analysisconstraints_ : *default_instance_->analysisconstraints_;
}
inline ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* FEAType::mutable_analysisconstraints() {
  set_has_analysisconstraints();
  if (analysisconstraints_ == NULL) analysisconstraints_ = new ::edu::vanderbilt::isis::meta::AnalysisConstraintsType;
  return analysisconstraints_;
}
inline ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* FEAType::release_analysisconstraints() {
  clear_has_analysisconstraints();
  ::edu::vanderbilt::isis::meta::AnalysisConstraintsType* temp = analysisconstraints_;
  analysisconstraints_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_analysisconstraints(::edu::vanderbilt::isis::meta::AnalysisConstraintsType* analysisconstraints) {
  delete analysisconstraints_;
  analysisconstraints_ = analysisconstraints;
  if (analysisconstraints) {
    set_has_analysisconstraints();
  } else {
    clear_has_analysisconstraints();
  }
}

// optional .edu.vanderbilt.isis.meta.ConditionsType Conditions = 3;
inline bool FEAType::has_conditions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FEAType::set_has_conditions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FEAType::clear_has_conditions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FEAType::clear_conditions() {
  if (conditions_ != NULL) conditions_->::edu::vanderbilt::isis::meta::ConditionsType::Clear();
  clear_has_conditions();
}
inline const ::edu::vanderbilt::isis::meta::ConditionsType& FEAType::conditions() const {
  return conditions_ != NULL ? *conditions_ : *default_instance_->conditions_;
}
inline ::edu::vanderbilt::isis::meta::ConditionsType* FEAType::mutable_conditions() {
  set_has_conditions();
  if (conditions_ == NULL) conditions_ = new ::edu::vanderbilt::isis::meta::ConditionsType;
  return conditions_;
}
inline ::edu::vanderbilt::isis::meta::ConditionsType* FEAType::release_conditions() {
  clear_has_conditions();
  ::edu::vanderbilt::isis::meta::ConditionsType* temp = conditions_;
  conditions_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_conditions(::edu::vanderbilt::isis::meta::ConditionsType* conditions) {
  delete conditions_;
  conditions_ = conditions;
  if (conditions) {
    set_has_conditions();
  } else {
    clear_has_conditions();
  }
}

// optional .edu.vanderbilt.isis.meta.LoadsType Loads = 4;
inline bool FEAType::has_loads() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FEAType::set_has_loads() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FEAType::clear_has_loads() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FEAType::clear_loads() {
  if (loads_ != NULL) loads_->::edu::vanderbilt::isis::meta::LoadsType::Clear();
  clear_has_loads();
}
inline const ::edu::vanderbilt::isis::meta::LoadsType& FEAType::loads() const {
  return loads_ != NULL ? *loads_ : *default_instance_->loads_;
}
inline ::edu::vanderbilt::isis::meta::LoadsType* FEAType::mutable_loads() {
  set_has_loads();
  if (loads_ == NULL) loads_ = new ::edu::vanderbilt::isis::meta::LoadsType;
  return loads_;
}
inline ::edu::vanderbilt::isis::meta::LoadsType* FEAType::release_loads() {
  clear_has_loads();
  ::edu::vanderbilt::isis::meta::LoadsType* temp = loads_;
  loads_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_loads(::edu::vanderbilt::isis::meta::LoadsType* loads) {
  delete loads_;
  loads_ = loads;
  if (loads) {
    set_has_loads();
  } else {
    clear_has_loads();
  }
}

// optional .edu.vanderbilt.isis.meta.PartInterfacesType PartInterfaces = 5;
inline bool FEAType::has_partinterfaces() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FEAType::set_has_partinterfaces() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FEAType::clear_has_partinterfaces() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FEAType::clear_partinterfaces() {
  if (partinterfaces_ != NULL) partinterfaces_->::edu::vanderbilt::isis::meta::PartInterfacesType::Clear();
  clear_has_partinterfaces();
}
inline const ::edu::vanderbilt::isis::meta::PartInterfacesType& FEAType::partinterfaces() const {
  return partinterfaces_ != NULL ? *partinterfaces_ : *default_instance_->partinterfaces_;
}
inline ::edu::vanderbilt::isis::meta::PartInterfacesType* FEAType::mutable_partinterfaces() {
  set_has_partinterfaces();
  if (partinterfaces_ == NULL) partinterfaces_ = new ::edu::vanderbilt::isis::meta::PartInterfacesType;
  return partinterfaces_;
}
inline ::edu::vanderbilt::isis::meta::PartInterfacesType* FEAType::release_partinterfaces() {
  clear_has_partinterfaces();
  ::edu::vanderbilt::isis::meta::PartInterfacesType* temp = partinterfaces_;
  partinterfaces_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_partinterfaces(::edu::vanderbilt::isis::meta::PartInterfacesType* partinterfaces) {
  delete partinterfaces_;
  partinterfaces_ = partinterfaces;
  if (partinterfaces) {
    set_has_partinterfaces();
  } else {
    clear_has_partinterfaces();
  }
}

// required .edu.vanderbilt.isis.meta.SolversType Solvers = 6;
inline bool FEAType::has_solvers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FEAType::set_has_solvers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FEAType::clear_has_solvers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FEAType::clear_solvers() {
  if (solvers_ != NULL) solvers_->::edu::vanderbilt::isis::meta::SolversType::Clear();
  clear_has_solvers();
}
inline const ::edu::vanderbilt::isis::meta::SolversType& FEAType::solvers() const {
  return solvers_ != NULL ? *solvers_ : *default_instance_->solvers_;
}
inline ::edu::vanderbilt::isis::meta::SolversType* FEAType::mutable_solvers() {
  set_has_solvers();
  if (solvers_ == NULL) solvers_ = new ::edu::vanderbilt::isis::meta::SolversType;
  return solvers_;
}
inline ::edu::vanderbilt::isis::meta::SolversType* FEAType::release_solvers() {
  clear_has_solvers();
  ::edu::vanderbilt::isis::meta::SolversType* temp = solvers_;
  solvers_ = NULL;
  return temp;
}
inline void FEAType::set_allocated_solvers(::edu::vanderbilt::isis::meta::SolversType* solvers) {
  delete solvers_;
  solvers_ = solvers;
  if (solvers) {
    set_has_solvers();
  } else {
    clear_has_solvers();
  }
}

// repeated .edu.vanderbilt.isis.meta.SurfaceTreatmentsType SurfaceTreatments = 7;
inline int FEAType::surfacetreatments_size() const {
  return surfacetreatments_.size();
}
inline void FEAType::clear_surfacetreatments() {
  surfacetreatments_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType& FEAType::surfacetreatments(int index) const {
  return surfacetreatments_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType* FEAType::mutable_surfacetreatments(int index) {
  return surfacetreatments_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType* FEAType::add_surfacetreatments() {
  return surfacetreatments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType >&
FEAType::surfacetreatments() const {
  return surfacetreatments_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentsType >*
FEAType::mutable_surfacetreatments() {
  return &surfacetreatments_;
}

// required string AnalysisID = 8;
inline bool FEAType::has_analysisid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FEAType::set_has_analysisid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FEAType::clear_has_analysisid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FEAType::clear_analysisid() {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    analysisid_->clear();
  }
  clear_has_analysisid();
}
inline const ::std::string& FEAType::analysisid() const {
  return *analysisid_;
}
inline void FEAType::set_analysisid(const ::std::string& value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void FEAType::set_analysisid(const char* value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void FEAType::set_analysisid(const char* value, size_t size) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEAType::mutable_analysisid() {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  return analysisid_;
}
inline ::std::string* FEAType::release_analysisid() {
  clear_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = analysisid_;
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEAType::set_allocated_analysisid(::std::string* analysisid) {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    delete analysisid_;
  }
  if (analysisid) {
    set_has_analysisid();
    analysisid_ = analysisid;
  } else {
    clear_has_analysisid();
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 9;
inline bool FEAType::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FEAType::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FEAType::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FEAType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& FEAType::type() const {
  return *type_;
}
inline void FEAType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FEAType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FEAType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FEAType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* FEAType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FEAType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FeatureType

// required string ComponentID = 1;
inline bool FeatureType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& FeatureType::componentid() const {
  return *componentid_;
}
inline void FeatureType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void FeatureType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void FeatureType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* FeatureType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeatureType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Name = 2;
inline bool FeatureType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FeatureType::name() const {
  return *name_;
}
inline void FeatureType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FeatureType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeatureType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FeaturesType

// repeated .edu.vanderbilt.isis.meta.FeatureType Feature = 1;
inline int FeaturesType::feature_size() const {
  return feature_.size();
}
inline void FeaturesType::clear_feature() {
  feature_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::FeatureType& FeaturesType::feature(int index) const {
  return feature_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::FeatureType* FeaturesType::mutable_feature(int index) {
  return feature_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::FeatureType* FeaturesType::add_feature() {
  return feature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeatureType >&
FeaturesType::feature() const {
  return feature_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeatureType >*
FeaturesType::mutable_feature() {
  return &feature_;
}

// required string FeatureGeometryType = 2;
inline bool FeaturesType::has_featuregeometrytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeaturesType::set_has_featuregeometrytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeaturesType::clear_has_featuregeometrytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeaturesType::clear_featuregeometrytype() {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_->clear();
  }
  clear_has_featuregeometrytype();
}
inline const ::std::string& FeaturesType::featuregeometrytype() const {
  return *featuregeometrytype_;
}
inline void FeaturesType::set_featuregeometrytype(const ::std::string& value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void FeaturesType::set_featuregeometrytype(const char* value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void FeaturesType::set_featuregeometrytype(const char* value, size_t size) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_featuregeometrytype() {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  return featuregeometrytype_;
}
inline ::std::string* FeaturesType::release_featuregeometrytype() {
  clear_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featuregeometrytype_;
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_featuregeometrytype(::std::string* featuregeometrytype) {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    delete featuregeometrytype_;
  }
  if (featuregeometrytype) {
    set_has_featuregeometrytype();
    featuregeometrytype_ = featuregeometrytype;
  } else {
    clear_has_featuregeometrytype();
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureID = 3;
inline bool FeaturesType::has_featureid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeaturesType::set_has_featureid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeaturesType::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeaturesType::clear_featureid() {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    featureid_->clear();
  }
  clear_has_featureid();
}
inline const ::std::string& FeaturesType::featureid() const {
  return *featureid_;
}
inline void FeaturesType::set_featureid(const ::std::string& value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void FeaturesType::set_featureid(const char* value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void FeaturesType::set_featureid(const char* value, size_t size) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_featureid() {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  return featureid_;
}
inline ::std::string* FeaturesType::release_featureid() {
  clear_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureid_;
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_featureid(::std::string* featureid) {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    delete featureid_;
  }
  if (featureid) {
    set_has_featureid();
    featureid_ = featureid;
  } else {
    clear_has_featureid();
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureInterfaceType = 4;
inline bool FeaturesType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeaturesType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeaturesType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeaturesType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& FeaturesType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void FeaturesType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void FeaturesType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void FeaturesType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* FeaturesType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string GeometryType = 5;
inline bool FeaturesType::has_geometrytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeaturesType::set_has_geometrytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeaturesType::clear_has_geometrytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeaturesType::clear_geometrytype() {
  if (geometrytype_ != &::google::protobuf::internal::kEmptyString) {
    geometrytype_->clear();
  }
  clear_has_geometrytype();
}
inline const ::std::string& FeaturesType::geometrytype() const {
  return *geometrytype_;
}
inline void FeaturesType::set_geometrytype(const ::std::string& value) {
  set_has_geometrytype();
  if (geometrytype_ == &::google::protobuf::internal::kEmptyString) {
    geometrytype_ = new ::std::string;
  }
  geometrytype_->assign(value);
}
inline void FeaturesType::set_geometrytype(const char* value) {
  set_has_geometrytype();
  if (geometrytype_ == &::google::protobuf::internal::kEmptyString) {
    geometrytype_ = new ::std::string;
  }
  geometrytype_->assign(value);
}
inline void FeaturesType::set_geometrytype(const char* value, size_t size) {
  set_has_geometrytype();
  if (geometrytype_ == &::google::protobuf::internal::kEmptyString) {
    geometrytype_ = new ::std::string;
  }
  geometrytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_geometrytype() {
  set_has_geometrytype();
  if (geometrytype_ == &::google::protobuf::internal::kEmptyString) {
    geometrytype_ = new ::std::string;
  }
  return geometrytype_;
}
inline ::std::string* FeaturesType::release_geometrytype() {
  clear_has_geometrytype();
  if (geometrytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geometrytype_;
    geometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_geometrytype(::std::string* geometrytype) {
  if (geometrytype_ != &::google::protobuf::internal::kEmptyString) {
    delete geometrytype_;
  }
  if (geometrytype) {
    set_has_geometrytype();
    geometrytype_ = geometrytype;
  } else {
    clear_has_geometrytype();
    geometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string PrimaryGeometryQualifier = 6;
inline bool FeaturesType::has_primarygeometryqualifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeaturesType::set_has_primarygeometryqualifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeaturesType::clear_has_primarygeometryqualifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeaturesType::clear_primarygeometryqualifier() {
  if (primarygeometryqualifier_ != &::google::protobuf::internal::kEmptyString) {
    primarygeometryqualifier_->clear();
  }
  clear_has_primarygeometryqualifier();
}
inline const ::std::string& FeaturesType::primarygeometryqualifier() const {
  return *primarygeometryqualifier_;
}
inline void FeaturesType::set_primarygeometryqualifier(const ::std::string& value) {
  set_has_primarygeometryqualifier();
  if (primarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    primarygeometryqualifier_ = new ::std::string;
  }
  primarygeometryqualifier_->assign(value);
}
inline void FeaturesType::set_primarygeometryqualifier(const char* value) {
  set_has_primarygeometryqualifier();
  if (primarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    primarygeometryqualifier_ = new ::std::string;
  }
  primarygeometryqualifier_->assign(value);
}
inline void FeaturesType::set_primarygeometryqualifier(const char* value, size_t size) {
  set_has_primarygeometryqualifier();
  if (primarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    primarygeometryqualifier_ = new ::std::string;
  }
  primarygeometryqualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_primarygeometryqualifier() {
  set_has_primarygeometryqualifier();
  if (primarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    primarygeometryqualifier_ = new ::std::string;
  }
  return primarygeometryqualifier_;
}
inline ::std::string* FeaturesType::release_primarygeometryqualifier() {
  clear_has_primarygeometryqualifier();
  if (primarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primarygeometryqualifier_;
    primarygeometryqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_primarygeometryqualifier(::std::string* primarygeometryqualifier) {
  if (primarygeometryqualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete primarygeometryqualifier_;
  }
  if (primarygeometryqualifier) {
    set_has_primarygeometryqualifier();
    primarygeometryqualifier_ = primarygeometryqualifier;
  } else {
    clear_has_primarygeometryqualifier();
    primarygeometryqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string SecondaryGeometryQualifier = 7;
inline bool FeaturesType::has_secondarygeometryqualifier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeaturesType::set_has_secondarygeometryqualifier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeaturesType::clear_has_secondarygeometryqualifier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FeaturesType::clear_secondarygeometryqualifier() {
  if (secondarygeometryqualifier_ != &::google::protobuf::internal::kEmptyString) {
    secondarygeometryqualifier_->clear();
  }
  clear_has_secondarygeometryqualifier();
}
inline const ::std::string& FeaturesType::secondarygeometryqualifier() const {
  return *secondarygeometryqualifier_;
}
inline void FeaturesType::set_secondarygeometryqualifier(const ::std::string& value) {
  set_has_secondarygeometryqualifier();
  if (secondarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    secondarygeometryqualifier_ = new ::std::string;
  }
  secondarygeometryqualifier_->assign(value);
}
inline void FeaturesType::set_secondarygeometryqualifier(const char* value) {
  set_has_secondarygeometryqualifier();
  if (secondarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    secondarygeometryqualifier_ = new ::std::string;
  }
  secondarygeometryqualifier_->assign(value);
}
inline void FeaturesType::set_secondarygeometryqualifier(const char* value, size_t size) {
  set_has_secondarygeometryqualifier();
  if (secondarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    secondarygeometryqualifier_ = new ::std::string;
  }
  secondarygeometryqualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeaturesType::mutable_secondarygeometryqualifier() {
  set_has_secondarygeometryqualifier();
  if (secondarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    secondarygeometryqualifier_ = new ::std::string;
  }
  return secondarygeometryqualifier_;
}
inline ::std::string* FeaturesType::release_secondarygeometryqualifier() {
  clear_has_secondarygeometryqualifier();
  if (secondarygeometryqualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondarygeometryqualifier_;
    secondarygeometryqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeaturesType::set_allocated_secondarygeometryqualifier(::std::string* secondarygeometryqualifier) {
  if (secondarygeometryqualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete secondarygeometryqualifier_;
  }
  if (secondarygeometryqualifier) {
    set_has_secondarygeometryqualifier();
    secondarygeometryqualifier_ = secondarygeometryqualifier;
  } else {
    clear_has_secondarygeometryqualifier();
    secondarygeometryqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FixedType

// repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
inline int FixedType::kinematicfeature_size() const {
  return kinematicfeature_.size();
}
inline void FixedType::clear_kinematicfeature() {
  kinematicfeature_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& FixedType::kinematicfeature(int index) const {
  return kinematicfeature_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* FixedType::mutable_kinematicfeature(int index) {
  return kinematicfeature_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* FixedType::add_kinematicfeature() {
  return kinematicfeature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
FixedType::kinematicfeature() const {
  return kinematicfeature_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
FixedType::mutable_kinematicfeature() {
  return &kinematicfeature_;
}

// required double CFM = 2;
inline bool FixedType::has_cfm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixedType::set_has_cfm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixedType::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixedType::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
inline double FixedType::cfm() const {
  return cfm_;
}
inline void FixedType::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
}

// required string ConnectedComponentID = 3;
inline bool FixedType::has_connectedcomponentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixedType::set_has_connectedcomponentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixedType::clear_has_connectedcomponentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixedType::clear_connectedcomponentid() {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_->clear();
  }
  clear_has_connectedcomponentid();
}
inline const ::std::string& FixedType::connectedcomponentid() const {
  return *connectedcomponentid_;
}
inline void FixedType::set_connectedcomponentid(const ::std::string& value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void FixedType::set_connectedcomponentid(const char* value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void FixedType::set_connectedcomponentid(const char* value, size_t size) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixedType::mutable_connectedcomponentid() {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  return connectedcomponentid_;
}
inline ::std::string* FixedType::release_connectedcomponentid() {
  clear_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectedcomponentid_;
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FixedType::set_allocated_connectedcomponentid(::std::string* connectedcomponentid) {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectedcomponentid_;
  }
  if (connectedcomponentid) {
    set_has_connectedcomponentid();
    connectedcomponentid_ = connectedcomponentid;
  } else {
    clear_has_connectedcomponentid();
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ConnectionID = 4;
inline bool FixedType::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FixedType::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FixedType::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FixedType::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& FixedType::connectionid() const {
  return *connectionid_;
}
inline void FixedType::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void FixedType::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void FixedType::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixedType::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* FixedType::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FixedType::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double ERP = 5;
inline bool FixedType::has_erp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FixedType::set_has_erp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FixedType::clear_has_erp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FixedType::clear_erp() {
  erp_ = 0;
  clear_has_erp();
}
inline double FixedType::erp() const {
  return erp_;
}
inline void FixedType::set_erp(double value) {
  set_has_erp();
  erp_ = value;
}

// required string FeatureInterfaceType = 6;
inline bool FixedType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FixedType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FixedType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FixedType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& FixedType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void FixedType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void FixedType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void FixedType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixedType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* FixedType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FixedType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ForceMomentType

// required .edu.vanderbilt.isis.meta.ForceType Force = 1;
inline bool ForceMomentType::has_force() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForceMomentType::set_has_force() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForceMomentType::clear_has_force() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForceMomentType::clear_force() {
  if (force_ != NULL) force_->::edu::vanderbilt::isis::meta::ForceType::Clear();
  clear_has_force();
}
inline const ::edu::vanderbilt::isis::meta::ForceType& ForceMomentType::force() const {
  return force_ != NULL ? *force_ : *default_instance_->force_;
}
inline ::edu::vanderbilt::isis::meta::ForceType* ForceMomentType::mutable_force() {
  set_has_force();
  if (force_ == NULL) force_ = new ::edu::vanderbilt::isis::meta::ForceType;
  return force_;
}
inline ::edu::vanderbilt::isis::meta::ForceType* ForceMomentType::release_force() {
  clear_has_force();
  ::edu::vanderbilt::isis::meta::ForceType* temp = force_;
  force_ = NULL;
  return temp;
}
inline void ForceMomentType::set_allocated_force(::edu::vanderbilt::isis::meta::ForceType* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
}

// required .edu.vanderbilt.isis.meta.MomentType Moment = 2;
inline bool ForceMomentType::has_moment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForceMomentType::set_has_moment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForceMomentType::clear_has_moment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForceMomentType::clear_moment() {
  if (moment_ != NULL) moment_->::edu::vanderbilt::isis::meta::MomentType::Clear();
  clear_has_moment();
}
inline const ::edu::vanderbilt::isis::meta::MomentType& ForceMomentType::moment() const {
  return moment_ != NULL ? *moment_ : *default_instance_->moment_;
}
inline ::edu::vanderbilt::isis::meta::MomentType* ForceMomentType::mutable_moment() {
  set_has_moment();
  if (moment_ == NULL) moment_ = new ::edu::vanderbilt::isis::meta::MomentType;
  return moment_;
}
inline ::edu::vanderbilt::isis::meta::MomentType* ForceMomentType::release_moment() {
  clear_has_moment();
  ::edu::vanderbilt::isis::meta::MomentType* temp = moment_;
  moment_ = NULL;
  return temp;
}
inline void ForceMomentType::set_allocated_moment(::edu::vanderbilt::isis::meta::MomentType* moment) {
  delete moment_;
  moment_ = moment;
  if (moment) {
    set_has_moment();
  } else {
    clear_has_moment();
  }
}

// -------------------------------------------------------------------

// ForceType

// required string Units = 1;
inline bool ForceType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForceType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForceType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForceType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& ForceType::units() const {
  return *units_;
}
inline void ForceType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void ForceType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void ForceType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForceType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* ForceType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ForceType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double x = 3;
inline bool ForceType::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForceType::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForceType::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForceType::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double ForceType::x() const {
  return x_;
}
inline void ForceType::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 4;
inline bool ForceType::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForceType::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForceType::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForceType::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double ForceType::y() const {
  return y_;
}
inline void ForceType::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 5;
inline bool ForceType::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ForceType::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ForceType::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ForceType::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double ForceType::z() const {
  return z_;
}
inline void ForceType::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// GeometryType

// repeated .edu.vanderbilt.isis.meta.FeaturesType Features = 1;
inline int GeometryType::features_size() const {
  return features_.size();
}
inline void GeometryType::clear_features() {
  features_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::FeaturesType& GeometryType::features(int index) const {
  return features_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::FeaturesType* GeometryType::mutable_features(int index) {
  return features_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::FeaturesType* GeometryType::add_features() {
  return features_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeaturesType >&
GeometryType::features() const {
  return features_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FeaturesType >*
GeometryType::mutable_features() {
  return &features_;
}

// repeated .edu.vanderbilt.isis.meta.SetOperationType SetOperation = 2;
inline int GeometryType::setoperation_size() const {
  return setoperation_.size();
}
inline void GeometryType::clear_setoperation() {
  setoperation_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::SetOperationType& GeometryType::setoperation(int index) const {
  return setoperation_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::SetOperationType* GeometryType::mutable_setoperation(int index) {
  return setoperation_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::SetOperationType* GeometryType::add_setoperation() {
  return setoperation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SetOperationType >&
GeometryType::setoperation() const {
  return setoperation_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SetOperationType >*
GeometryType::mutable_setoperation() {
  return &setoperation_;
}

// -------------------------------------------------------------------

// InterferenceType

// required string AnalysisID = 1;
inline bool InterferenceType::has_analysisid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterferenceType::set_has_analysisid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterferenceType::clear_has_analysisid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterferenceType::clear_analysisid() {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    analysisid_->clear();
  }
  clear_has_analysisid();
}
inline const ::std::string& InterferenceType::analysisid() const {
  return *analysisid_;
}
inline void InterferenceType::set_analysisid(const ::std::string& value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void InterferenceType::set_analysisid(const char* value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void InterferenceType::set_analysisid(const char* value, size_t size) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterferenceType::mutable_analysisid() {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  return analysisid_;
}
inline ::std::string* InterferenceType::release_analysisid() {
  clear_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = analysisid_;
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterferenceType::set_allocated_analysisid(::std::string* analysisid) {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    delete analysisid_;
  }
  if (analysisid) {
    set_has_analysisid();
    analysisid_ = analysisid;
  } else {
    clear_has_analysisid();
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KinematicConnectionsType

// repeated .edu.vanderbilt.isis.meta.FixedType Fixed = 1;
inline int KinematicConnectionsType::fixed_size() const {
  return fixed_.size();
}
inline void KinematicConnectionsType::clear_fixed() {
  fixed_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::FixedType& KinematicConnectionsType::fixed(int index) const {
  return fixed_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::FixedType* KinematicConnectionsType::mutable_fixed(int index) {
  return fixed_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::FixedType* KinematicConnectionsType::add_fixed() {
  return fixed_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FixedType >&
KinematicConnectionsType::fixed() const {
  return fixed_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::FixedType >*
KinematicConnectionsType::mutable_fixed() {
  return &fixed_;
}

// repeated .edu.vanderbilt.isis.meta.PrismaticType Prismatic = 2;
inline int KinematicConnectionsType::prismatic_size() const {
  return prismatic_.size();
}
inline void KinematicConnectionsType::clear_prismatic() {
  prismatic_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::PrismaticType& KinematicConnectionsType::prismatic(int index) const {
  return prismatic_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::PrismaticType* KinematicConnectionsType::mutable_prismatic(int index) {
  return prismatic_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::PrismaticType* KinematicConnectionsType::add_prismatic() {
  return prismatic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PrismaticType >&
KinematicConnectionsType::prismatic() const {
  return prismatic_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PrismaticType >*
KinematicConnectionsType::mutable_prismatic() {
  return &prismatic_;
}

// repeated .edu.vanderbilt.isis.meta.RevoluteType Revolute = 3;
inline int KinematicConnectionsType::revolute_size() const {
  return revolute_.size();
}
inline void KinematicConnectionsType::clear_revolute() {
  revolute_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::RevoluteType& KinematicConnectionsType::revolute(int index) const {
  return revolute_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::RevoluteType* KinematicConnectionsType::mutable_revolute(int index) {
  return revolute_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::RevoluteType* KinematicConnectionsType::add_revolute() {
  return revolute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::RevoluteType >&
KinematicConnectionsType::revolute() const {
  return revolute_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::RevoluteType >*
KinematicConnectionsType::mutable_revolute() {
  return &revolute_;
}

// repeated .edu.vanderbilt.isis.meta.SphericalType Spherical = 4;
inline int KinematicConnectionsType::spherical_size() const {
  return spherical_.size();
}
inline void KinematicConnectionsType::clear_spherical() {
  spherical_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::SphericalType& KinematicConnectionsType::spherical(int index) const {
  return spherical_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::SphericalType* KinematicConnectionsType::mutable_spherical(int index) {
  return spherical_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::SphericalType* KinematicConnectionsType::add_spherical() {
  return spherical_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SphericalType >&
KinematicConnectionsType::spherical() const {
  return spherical_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SphericalType >*
KinematicConnectionsType::mutable_spherical() {
  return &spherical_;
}

// -------------------------------------------------------------------

// KinematicFeatureType

// required string ComponentID = 1;
inline bool KinematicFeatureType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KinematicFeatureType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KinematicFeatureType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KinematicFeatureType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& KinematicFeatureType::componentid() const {
  return *componentid_;
}
inline void KinematicFeatureType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void KinematicFeatureType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void KinematicFeatureType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KinematicFeatureType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* KinematicFeatureType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KinematicFeatureType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DatumName = 2;
inline bool KinematicFeatureType::has_datumname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KinematicFeatureType::set_has_datumname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KinematicFeatureType::clear_has_datumname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KinematicFeatureType::clear_datumname() {
  if (datumname_ != &::google::protobuf::internal::kEmptyString) {
    datumname_->clear();
  }
  clear_has_datumname();
}
inline const ::std::string& KinematicFeatureType::datumname() const {
  return *datumname_;
}
inline void KinematicFeatureType::set_datumname(const ::std::string& value) {
  set_has_datumname();
  if (datumname_ == &::google::protobuf::internal::kEmptyString) {
    datumname_ = new ::std::string;
  }
  datumname_->assign(value);
}
inline void KinematicFeatureType::set_datumname(const char* value) {
  set_has_datumname();
  if (datumname_ == &::google::protobuf::internal::kEmptyString) {
    datumname_ = new ::std::string;
  }
  datumname_->assign(value);
}
inline void KinematicFeatureType::set_datumname(const char* value, size_t size) {
  set_has_datumname();
  if (datumname_ == &::google::protobuf::internal::kEmptyString) {
    datumname_ = new ::std::string;
  }
  datumname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KinematicFeatureType::mutable_datumname() {
  set_has_datumname();
  if (datumname_ == &::google::protobuf::internal::kEmptyString) {
    datumname_ = new ::std::string;
  }
  return datumname_;
}
inline ::std::string* KinematicFeatureType::release_datumname() {
  clear_has_datumname();
  if (datumname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datumname_;
    datumname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KinematicFeatureType::set_allocated_datumname(::std::string* datumname) {
  if (datumname_ != &::google::protobuf::internal::kEmptyString) {
    delete datumname_;
  }
  if (datumname) {
    set_has_datumname();
    datumname_ = datumname;
  } else {
    clear_has_datumname();
    datumname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureGeometryType = 3;
inline bool KinematicFeatureType::has_featuregeometrytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KinematicFeatureType::set_has_featuregeometrytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KinematicFeatureType::clear_has_featuregeometrytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KinematicFeatureType::clear_featuregeometrytype() {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_->clear();
  }
  clear_has_featuregeometrytype();
}
inline const ::std::string& KinematicFeatureType::featuregeometrytype() const {
  return *featuregeometrytype_;
}
inline void KinematicFeatureType::set_featuregeometrytype(const ::std::string& value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void KinematicFeatureType::set_featuregeometrytype(const char* value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void KinematicFeatureType::set_featuregeometrytype(const char* value, size_t size) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KinematicFeatureType::mutable_featuregeometrytype() {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  return featuregeometrytype_;
}
inline ::std::string* KinematicFeatureType::release_featuregeometrytype() {
  clear_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featuregeometrytype_;
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KinematicFeatureType::set_allocated_featuregeometrytype(::std::string* featuregeometrytype) {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    delete featuregeometrytype_;
  }
  if (featuregeometrytype) {
    set_has_featuregeometrytype();
    featuregeometrytype_ = featuregeometrytype;
  } else {
    clear_has_featuregeometrytype();
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadType

// optional .edu.vanderbilt.isis.meta.AccelerationType Acceleration = 1;
inline bool LoadType::has_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadType::set_has_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadType::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadType::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::edu::vanderbilt::isis::meta::AccelerationType::Clear();
  clear_has_acceleration();
}
inline const ::edu::vanderbilt::isis::meta::AccelerationType& LoadType::acceleration() const {
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::edu::vanderbilt::isis::meta::AccelerationType* LoadType::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) acceleration_ = new ::edu::vanderbilt::isis::meta::AccelerationType;
  return acceleration_;
}
inline ::edu::vanderbilt::isis::meta::AccelerationType* LoadType::release_acceleration() {
  clear_has_acceleration();
  ::edu::vanderbilt::isis::meta::AccelerationType* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void LoadType::set_allocated_acceleration(::edu::vanderbilt::isis::meta::AccelerationType* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
}

// optional .edu.vanderbilt.isis.meta.ForceMomentType ForceMoment = 2;
inline bool LoadType::has_forcemoment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadType::set_has_forcemoment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadType::clear_has_forcemoment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadType::clear_forcemoment() {
  if (forcemoment_ != NULL) forcemoment_->::edu::vanderbilt::isis::meta::ForceMomentType::Clear();
  clear_has_forcemoment();
}
inline const ::edu::vanderbilt::isis::meta::ForceMomentType& LoadType::forcemoment() const {
  return forcemoment_ != NULL ? *forcemoment_ : *default_instance_->forcemoment_;
}
inline ::edu::vanderbilt::isis::meta::ForceMomentType* LoadType::mutable_forcemoment() {
  set_has_forcemoment();
  if (forcemoment_ == NULL) forcemoment_ = new ::edu::vanderbilt::isis::meta::ForceMomentType;
  return forcemoment_;
}
inline ::edu::vanderbilt::isis::meta::ForceMomentType* LoadType::release_forcemoment() {
  clear_has_forcemoment();
  ::edu::vanderbilt::isis::meta::ForceMomentType* temp = forcemoment_;
  forcemoment_ = NULL;
  return temp;
}
inline void LoadType::set_allocated_forcemoment(::edu::vanderbilt::isis::meta::ForceMomentType* forcemoment) {
  delete forcemoment_;
  forcemoment_ = forcemoment;
  if (forcemoment) {
    set_has_forcemoment();
  } else {
    clear_has_forcemoment();
  }
}

// optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 3;
inline bool LoadType::has_geometry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadType::set_has_geometry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadType::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadType::clear_geometry() {
  if (geometry_ != NULL) geometry_->::edu::vanderbilt::isis::meta::GeometryType::Clear();
  clear_has_geometry();
}
inline const ::edu::vanderbilt::isis::meta::GeometryType& LoadType::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* LoadType::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::edu::vanderbilt::isis::meta::GeometryType;
  return geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* LoadType::release_geometry() {
  clear_has_geometry();
  ::edu::vanderbilt::isis::meta::GeometryType* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void LoadType::set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .edu.vanderbilt.isis.meta.PressureType Pressure = 4;
inline bool LoadType::has_pressure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadType::set_has_pressure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadType::clear_has_pressure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadType::clear_pressure() {
  if (pressure_ != NULL) pressure_->::edu::vanderbilt::isis::meta::PressureType::Clear();
  clear_has_pressure();
}
inline const ::edu::vanderbilt::isis::meta::PressureType& LoadType::pressure() const {
  return pressure_ != NULL ? *pressure_ : *default_instance_->pressure_;
}
inline ::edu::vanderbilt::isis::meta::PressureType* LoadType::mutable_pressure() {
  set_has_pressure();
  if (pressure_ == NULL) pressure_ = new ::edu::vanderbilt::isis::meta::PressureType;
  return pressure_;
}
inline ::edu::vanderbilt::isis::meta::PressureType* LoadType::release_pressure() {
  clear_has_pressure();
  ::edu::vanderbilt::isis::meta::PressureType* temp = pressure_;
  pressure_ = NULL;
  return temp;
}
inline void LoadType::set_allocated_pressure(::edu::vanderbilt::isis::meta::PressureType* pressure) {
  delete pressure_;
  pressure_ = pressure;
  if (pressure) {
    set_has_pressure();
  } else {
    clear_has_pressure();
  }
}

// -------------------------------------------------------------------

// LoadsType

// repeated .edu.vanderbilt.isis.meta.LoadType Load = 1;
inline int LoadsType::load_size() const {
  return load_.size();
}
inline void LoadsType::clear_load() {
  load_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::LoadType& LoadsType::load(int index) const {
  return load_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::LoadType* LoadsType::mutable_load(int index) {
  return load_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::LoadType* LoadsType::add_load() {
  return load_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::LoadType >&
LoadsType::load() const {
  return load_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::LoadType >*
LoadsType::mutable_load() {
  return &load_;
}

// -------------------------------------------------------------------

// MassType

// required string ComponentID = 1;
inline bool MassType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& MassType::componentid() const {
  return *componentid_;
}
inline void MassType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void MassType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void MassType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MassType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* MassType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MassType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MetricID = 2;
inline bool MassType::has_metricid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassType::set_has_metricid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassType::clear_has_metricid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassType::clear_metricid() {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    metricid_->clear();
  }
  clear_has_metricid();
}
inline const ::std::string& MassType::metricid() const {
  return *metricid_;
}
inline void MassType::set_metricid(const ::std::string& value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void MassType::set_metricid(const char* value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void MassType::set_metricid(const char* value, size_t size) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MassType::mutable_metricid() {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  return metricid_;
}
inline ::std::string* MassType::release_metricid() {
  clear_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metricid_;
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MassType::set_allocated_metricid(::std::string* metricid) {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    delete metricid_;
  }
  if (metricid) {
    set_has_metricid();
    metricid_ = metricid;
  } else {
    clear_has_metricid();
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RequestedValueType = 3;
inline bool MassType::has_requestedvaluetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassType::set_has_requestedvaluetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassType::clear_has_requestedvaluetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassType::clear_requestedvaluetype() {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_->clear();
  }
  clear_has_requestedvaluetype();
}
inline const ::std::string& MassType::requestedvaluetype() const {
  return *requestedvaluetype_;
}
inline void MassType::set_requestedvaluetype(const ::std::string& value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void MassType::set_requestedvaluetype(const char* value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void MassType::set_requestedvaluetype(const char* value, size_t size) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MassType::mutable_requestedvaluetype() {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  return requestedvaluetype_;
}
inline ::std::string* MassType::release_requestedvaluetype() {
  clear_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requestedvaluetype_;
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MassType::set_allocated_requestedvaluetype(::std::string* requestedvaluetype) {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    delete requestedvaluetype_;
  }
  if (requestedvaluetype) {
    set_has_requestedvaluetype();
    requestedvaluetype_ = requestedvaluetype;
  } else {
    clear_has_requestedvaluetype();
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MaterialPropertyType

// required string PropertyName = 1;
inline bool MaterialPropertyType::has_propertyname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaterialPropertyType::set_has_propertyname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaterialPropertyType::clear_has_propertyname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaterialPropertyType::clear_propertyname() {
  if (propertyname_ != &::google::protobuf::internal::kEmptyString) {
    propertyname_->clear();
  }
  clear_has_propertyname();
}
inline const ::std::string& MaterialPropertyType::propertyname() const {
  return *propertyname_;
}
inline void MaterialPropertyType::set_propertyname(const ::std::string& value) {
  set_has_propertyname();
  if (propertyname_ == &::google::protobuf::internal::kEmptyString) {
    propertyname_ = new ::std::string;
  }
  propertyname_->assign(value);
}
inline void MaterialPropertyType::set_propertyname(const char* value) {
  set_has_propertyname();
  if (propertyname_ == &::google::protobuf::internal::kEmptyString) {
    propertyname_ = new ::std::string;
  }
  propertyname_->assign(value);
}
inline void MaterialPropertyType::set_propertyname(const char* value, size_t size) {
  set_has_propertyname();
  if (propertyname_ == &::google::protobuf::internal::kEmptyString) {
    propertyname_ = new ::std::string;
  }
  propertyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialPropertyType::mutable_propertyname() {
  set_has_propertyname();
  if (propertyname_ == &::google::protobuf::internal::kEmptyString) {
    propertyname_ = new ::std::string;
  }
  return propertyname_;
}
inline ::std::string* MaterialPropertyType::release_propertyname() {
  clear_has_propertyname();
  if (propertyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = propertyname_;
    propertyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialPropertyType::set_allocated_propertyname(::std::string* propertyname) {
  if (propertyname_ != &::google::protobuf::internal::kEmptyString) {
    delete propertyname_;
  }
  if (propertyname) {
    set_has_propertyname();
    propertyname_ = propertyname;
  } else {
    clear_has_propertyname();
    propertyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Units = 2;
inline bool MaterialPropertyType::has_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaterialPropertyType::set_has_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaterialPropertyType::clear_has_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaterialPropertyType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& MaterialPropertyType::units() const {
  return *units_;
}
inline void MaterialPropertyType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void MaterialPropertyType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void MaterialPropertyType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialPropertyType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* MaterialPropertyType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialPropertyType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double Value = 3;
inline bool MaterialPropertyType::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MaterialPropertyType::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MaterialPropertyType::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MaterialPropertyType::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double MaterialPropertyType::value() const {
  return value_;
}
inline void MaterialPropertyType::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// MaterialType

// repeated .edu.vanderbilt.isis.meta.MaterialPropertyType MaterialProperty = 1;
inline int MaterialType::materialproperty_size() const {
  return materialproperty_.size();
}
inline void MaterialType::clear_materialproperty() {
  materialproperty_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::MaterialPropertyType& MaterialType::materialproperty(int index) const {
  return materialproperty_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialPropertyType* MaterialType::mutable_materialproperty(int index) {
  return materialproperty_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialPropertyType* MaterialType::add_materialproperty() {
  return materialproperty_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialPropertyType >&
MaterialType::materialproperty() const {
  return materialproperty_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialPropertyType >*
MaterialType::mutable_materialproperty() {
  return &materialproperty_;
}

// required string MaterialID = 2;
inline bool MaterialType::has_materialid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaterialType::set_has_materialid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaterialType::clear_has_materialid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaterialType::clear_materialid() {
  if (materialid_ != &::google::protobuf::internal::kEmptyString) {
    materialid_->clear();
  }
  clear_has_materialid();
}
inline const ::std::string& MaterialType::materialid() const {
  return *materialid_;
}
inline void MaterialType::set_materialid(const ::std::string& value) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(value);
}
inline void MaterialType::set_materialid(const char* value) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(value);
}
inline void MaterialType::set_materialid(const char* value, size_t size) {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  materialid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialType::mutable_materialid() {
  set_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    materialid_ = new ::std::string;
  }
  return materialid_;
}
inline ::std::string* MaterialType::release_materialid() {
  clear_has_materialid();
  if (materialid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = materialid_;
    materialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialType::set_allocated_materialid(::std::string* materialid) {
  if (materialid_ != &::google::protobuf::internal::kEmptyString) {
    delete materialid_;
  }
  if (materialid) {
    set_has_materialid();
    materialid_ = materialid;
  } else {
    clear_has_materialid();
    materialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MaterialName = 3;
inline bool MaterialType::has_materialname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MaterialType::set_has_materialname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MaterialType::clear_has_materialname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MaterialType::clear_materialname() {
  if (materialname_ != &::google::protobuf::internal::kEmptyString) {
    materialname_->clear();
  }
  clear_has_materialname();
}
inline const ::std::string& MaterialType::materialname() const {
  return *materialname_;
}
inline void MaterialType::set_materialname(const ::std::string& value) {
  set_has_materialname();
  if (materialname_ == &::google::protobuf::internal::kEmptyString) {
    materialname_ = new ::std::string;
  }
  materialname_->assign(value);
}
inline void MaterialType::set_materialname(const char* value) {
  set_has_materialname();
  if (materialname_ == &::google::protobuf::internal::kEmptyString) {
    materialname_ = new ::std::string;
  }
  materialname_->assign(value);
}
inline void MaterialType::set_materialname(const char* value, size_t size) {
  set_has_materialname();
  if (materialname_ == &::google::protobuf::internal::kEmptyString) {
    materialname_ = new ::std::string;
  }
  materialname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialType::mutable_materialname() {
  set_has_materialname();
  if (materialname_ == &::google::protobuf::internal::kEmptyString) {
    materialname_ = new ::std::string;
  }
  return materialname_;
}
inline ::std::string* MaterialType::release_materialname() {
  clear_has_materialname();
  if (materialname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = materialname_;
    materialname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialType::set_allocated_materialname(::std::string* materialname) {
  if (materialname_ != &::google::protobuf::internal::kEmptyString) {
    delete materialname_;
  }
  if (materialname) {
    set_has_materialname();
    materialname_ = materialname;
  } else {
    clear_has_materialname();
    materialname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 4;
inline bool MaterialType::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MaterialType::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MaterialType::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MaterialType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MaterialType::type() const {
  return *type_;
}
inline void MaterialType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MaterialType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MaterialType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* MaterialType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MaterialsType

// repeated .edu.vanderbilt.isis.meta.MaterialType Material = 1;
inline int MaterialsType::material_size() const {
  return material_.size();
}
inline void MaterialsType::clear_material() {
  material_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::MaterialType& MaterialsType::material(int index) const {
  return material_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialType* MaterialsType::mutable_material(int index) {
  return material_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::MaterialType* MaterialsType::add_material() {
  return material_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialType >&
MaterialsType::material() const {
  return material_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MaterialType >*
MaterialsType::mutable_material() {
  return &material_;
}

// -------------------------------------------------------------------

// MetricType

// required string ID = 1;
inline bool MetricType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetricType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetricType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetricType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MetricType::id() const {
  return *id_;
}
inline void MetricType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MetricType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MetricType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetricType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MetricType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetricType::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 2;
inline bool MetricType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetricType::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetricType::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetricType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MetricType::type() const {
  return *type_;
}
inline void MetricType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MetricType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MetricType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetricType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* MetricType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetricType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MetricsType

// repeated .edu.vanderbilt.isis.meta.MetricType Metric = 1;
inline int MetricsType::metric_size() const {
  return metric_.size();
}
inline void MetricsType::clear_metric() {
  metric_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::MetricType& MetricsType::metric(int index) const {
  return metric_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::MetricType* MetricsType::mutable_metric(int index) {
  return metric_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::MetricType* MetricsType::add_metric() {
  return metric_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MetricType >&
MetricsType::metric() const {
  return metric_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::MetricType >*
MetricsType::mutable_metric() {
  return &metric_;
}

// -------------------------------------------------------------------

// MomentType

// required string Units = 1;
inline bool MomentType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MomentType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MomentType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MomentType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& MomentType::units() const {
  return *units_;
}
inline void MomentType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void MomentType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void MomentType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MomentType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* MomentType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MomentType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double x = 3;
inline bool MomentType::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MomentType::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MomentType::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MomentType::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double MomentType::x() const {
  return x_;
}
inline void MomentType::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 4;
inline bool MomentType::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MomentType::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MomentType::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MomentType::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double MomentType::y() const {
  return y_;
}
inline void MomentType::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 5;
inline bool MomentType::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MomentType::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MomentType::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MomentType::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double MomentType::z() const {
  return z_;
}
inline void MomentType::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// PairType

// required .edu.vanderbilt.isis.meta.ConstraintFeatureType ConstraintFeatureA = 1;
inline bool PairType::has_constraintfeaturea() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairType::set_has_constraintfeaturea() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PairType::clear_has_constraintfeaturea() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PairType::clear_constraintfeaturea() {
  if (constraintfeaturea_ != NULL) constraintfeaturea_->::edu::vanderbilt::isis::meta::ConstraintFeatureType::Clear();
  clear_has_constraintfeaturea();
}
inline const ::edu::vanderbilt::isis::meta::ConstraintFeatureType& PairType::constraintfeaturea() const {
  return constraintfeaturea_ != NULL ? *constraintfeaturea_ : *default_instance_->constraintfeaturea_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* PairType::mutable_constraintfeaturea() {
  set_has_constraintfeaturea();
  if (constraintfeaturea_ == NULL) constraintfeaturea_ = new ::edu::vanderbilt::isis::meta::ConstraintFeatureType;
  return constraintfeaturea_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* PairType::release_constraintfeaturea() {
  clear_has_constraintfeaturea();
  ::edu::vanderbilt::isis::meta::ConstraintFeatureType* temp = constraintfeaturea_;
  constraintfeaturea_ = NULL;
  return temp;
}
inline void PairType::set_allocated_constraintfeaturea(::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeaturea) {
  delete constraintfeaturea_;
  constraintfeaturea_ = constraintfeaturea;
  if (constraintfeaturea) {
    set_has_constraintfeaturea();
  } else {
    clear_has_constraintfeaturea();
  }
}

// required .edu.vanderbilt.isis.meta.ConstraintFeatureType ConstraintFeatureB = 2;
inline bool PairType::has_constraintfeatureb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PairType::set_has_constraintfeatureb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PairType::clear_has_constraintfeatureb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PairType::clear_constraintfeatureb() {
  if (constraintfeatureb_ != NULL) constraintfeatureb_->::edu::vanderbilt::isis::meta::ConstraintFeatureType::Clear();
  clear_has_constraintfeatureb();
}
inline const ::edu::vanderbilt::isis::meta::ConstraintFeatureType& PairType::constraintfeatureb() const {
  return constraintfeatureb_ != NULL ? *constraintfeatureb_ : *default_instance_->constraintfeatureb_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* PairType::mutable_constraintfeatureb() {
  set_has_constraintfeatureb();
  if (constraintfeatureb_ == NULL) constraintfeatureb_ = new ::edu::vanderbilt::isis::meta::ConstraintFeatureType;
  return constraintfeatureb_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintFeatureType* PairType::release_constraintfeatureb() {
  clear_has_constraintfeatureb();
  ::edu::vanderbilt::isis::meta::ConstraintFeatureType* temp = constraintfeatureb_;
  constraintfeatureb_ = NULL;
  return temp;
}
inline void PairType::set_allocated_constraintfeatureb(::edu::vanderbilt::isis::meta::ConstraintFeatureType* constraintfeatureb) {
  delete constraintfeatureb_;
  constraintfeatureb_ = constraintfeatureb;
  if (constraintfeatureb) {
    set_has_constraintfeatureb();
  } else {
    clear_has_constraintfeatureb();
  }
}

// optional .edu.vanderbilt.isis.meta.ConstraintOffsetType ConstraintOffset = 3;
inline bool PairType::has_constraintoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PairType::set_has_constraintoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PairType::clear_has_constraintoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PairType::clear_constraintoffset() {
  if (constraintoffset_ != NULL) constraintoffset_->::edu::vanderbilt::isis::meta::ConstraintOffsetType::Clear();
  clear_has_constraintoffset();
}
inline const ::edu::vanderbilt::isis::meta::ConstraintOffsetType& PairType::constraintoffset() const {
  return constraintoffset_ != NULL ? *constraintoffset_ : *default_instance_->constraintoffset_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintOffsetType* PairType::mutable_constraintoffset() {
  set_has_constraintoffset();
  if (constraintoffset_ == NULL) constraintoffset_ = new ::edu::vanderbilt::isis::meta::ConstraintOffsetType;
  return constraintoffset_;
}
inline ::edu::vanderbilt::isis::meta::ConstraintOffsetType* PairType::release_constraintoffset() {
  clear_has_constraintoffset();
  ::edu::vanderbilt::isis::meta::ConstraintOffsetType* temp = constraintoffset_;
  constraintoffset_ = NULL;
  return temp;
}
inline void PairType::set_allocated_constraintoffset(::edu::vanderbilt::isis::meta::ConstraintOffsetType* constraintoffset) {
  delete constraintoffset_;
  constraintoffset_ = constraintoffset;
  if (constraintoffset) {
    set_has_constraintoffset();
  } else {
    clear_has_constraintoffset();
  }
}

// required string FeatureAlignmentType = 4;
inline bool PairType::has_featurealignmenttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PairType::set_has_featurealignmenttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PairType::clear_has_featurealignmenttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PairType::clear_featurealignmenttype() {
  if (featurealignmenttype_ != &::google::protobuf::internal::kEmptyString) {
    featurealignmenttype_->clear();
  }
  clear_has_featurealignmenttype();
}
inline const ::std::string& PairType::featurealignmenttype() const {
  return *featurealignmenttype_;
}
inline void PairType::set_featurealignmenttype(const ::std::string& value) {
  set_has_featurealignmenttype();
  if (featurealignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    featurealignmenttype_ = new ::std::string;
  }
  featurealignmenttype_->assign(value);
}
inline void PairType::set_featurealignmenttype(const char* value) {
  set_has_featurealignmenttype();
  if (featurealignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    featurealignmenttype_ = new ::std::string;
  }
  featurealignmenttype_->assign(value);
}
inline void PairType::set_featurealignmenttype(const char* value, size_t size) {
  set_has_featurealignmenttype();
  if (featurealignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    featurealignmenttype_ = new ::std::string;
  }
  featurealignmenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PairType::mutable_featurealignmenttype() {
  set_has_featurealignmenttype();
  if (featurealignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    featurealignmenttype_ = new ::std::string;
  }
  return featurealignmenttype_;
}
inline ::std::string* PairType::release_featurealignmenttype() {
  clear_has_featurealignmenttype();
  if (featurealignmenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featurealignmenttype_;
    featurealignmenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PairType::set_allocated_featurealignmenttype(::std::string* featurealignmenttype) {
  if (featurealignmenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete featurealignmenttype_;
  }
  if (featurealignmenttype) {
    set_has_featurealignmenttype();
    featurealignmenttype_ = featurealignmenttype;
  } else {
    clear_has_featurealignmenttype();
    featurealignmenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureGeometryType = 5;
inline bool PairType::has_featuregeometrytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PairType::set_has_featuregeometrytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PairType::clear_has_featuregeometrytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PairType::clear_featuregeometrytype() {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_->clear();
  }
  clear_has_featuregeometrytype();
}
inline const ::std::string& PairType::featuregeometrytype() const {
  return *featuregeometrytype_;
}
inline void PairType::set_featuregeometrytype(const ::std::string& value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void PairType::set_featuregeometrytype(const char* value) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(value);
}
inline void PairType::set_featuregeometrytype(const char* value, size_t size) {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  featuregeometrytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PairType::mutable_featuregeometrytype() {
  set_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    featuregeometrytype_ = new ::std::string;
  }
  return featuregeometrytype_;
}
inline ::std::string* PairType::release_featuregeometrytype() {
  clear_has_featuregeometrytype();
  if (featuregeometrytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featuregeometrytype_;
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PairType::set_allocated_featuregeometrytype(::std::string* featuregeometrytype) {
  if (featuregeometrytype_ != &::google::protobuf::internal::kEmptyString) {
    delete featuregeometrytype_;
  }
  if (featuregeometrytype) {
    set_has_featuregeometrytype();
    featuregeometrytype_ = featuregeometrytype;
  } else {
    clear_has_featuregeometrytype();
    featuregeometrytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureInterfaceType = 6;
inline bool PairType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PairType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PairType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PairType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& PairType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void PairType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void PairType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void PairType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PairType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* PairType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PairType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ParametricParametersType

// repeated .edu.vanderbilt.isis.meta.CADParameterType CADParameter = 1;
inline int ParametricParametersType::cadparameter_size() const {
  return cadparameter_.size();
}
inline void ParametricParametersType::clear_cadparameter() {
  cadparameter_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::CADParameterType& ParametricParametersType::cadparameter(int index) const {
  return cadparameter_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::CADParameterType* ParametricParametersType::mutable_cadparameter(int index) {
  return cadparameter_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::CADParameterType* ParametricParametersType::add_cadparameter() {
  return cadparameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADParameterType >&
ParametricParametersType::cadparameter() const {
  return cadparameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADParameterType >*
ParametricParametersType::mutable_cadparameter() {
  return &cadparameter_;
}

// optional string ComponentID = 2;
inline bool ParametricParametersType::has_componentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParametricParametersType::set_has_componentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParametricParametersType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParametricParametersType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& ParametricParametersType::componentid() const {
  return *componentid_;
}
inline void ParametricParametersType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ParametricParametersType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ParametricParametersType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParametricParametersType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* ParametricParametersType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParametricParametersType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PartInterfaceType

// required string ComponentID_1 = 1;
inline bool PartInterfaceType::has_componentid_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartInterfaceType::set_has_componentid_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartInterfaceType::clear_has_componentid_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartInterfaceType::clear_componentid_1() {
  if (componentid_1_ != &::google::protobuf::internal::kEmptyString) {
    componentid_1_->clear();
  }
  clear_has_componentid_1();
}
inline const ::std::string& PartInterfaceType::componentid_1() const {
  return *componentid_1_;
}
inline void PartInterfaceType::set_componentid_1(const ::std::string& value) {
  set_has_componentid_1();
  if (componentid_1_ == &::google::protobuf::internal::kEmptyString) {
    componentid_1_ = new ::std::string;
  }
  componentid_1_->assign(value);
}
inline void PartInterfaceType::set_componentid_1(const char* value) {
  set_has_componentid_1();
  if (componentid_1_ == &::google::protobuf::internal::kEmptyString) {
    componentid_1_ = new ::std::string;
  }
  componentid_1_->assign(value);
}
inline void PartInterfaceType::set_componentid_1(const char* value, size_t size) {
  set_has_componentid_1();
  if (componentid_1_ == &::google::protobuf::internal::kEmptyString) {
    componentid_1_ = new ::std::string;
  }
  componentid_1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PartInterfaceType::mutable_componentid_1() {
  set_has_componentid_1();
  if (componentid_1_ == &::google::protobuf::internal::kEmptyString) {
    componentid_1_ = new ::std::string;
  }
  return componentid_1_;
}
inline ::std::string* PartInterfaceType::release_componentid_1() {
  clear_has_componentid_1();
  if (componentid_1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_1_;
    componentid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PartInterfaceType::set_allocated_componentid_1(::std::string* componentid_1) {
  if (componentid_1_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_1_;
  }
  if (componentid_1) {
    set_has_componentid_1();
    componentid_1_ = componentid_1;
  } else {
    clear_has_componentid_1();
    componentid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ComponentID_2 = 2;
inline bool PartInterfaceType::has_componentid_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartInterfaceType::set_has_componentid_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartInterfaceType::clear_has_componentid_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartInterfaceType::clear_componentid_2() {
  if (componentid_2_ != &::google::protobuf::internal::kEmptyString) {
    componentid_2_->clear();
  }
  clear_has_componentid_2();
}
inline const ::std::string& PartInterfaceType::componentid_2() const {
  return *componentid_2_;
}
inline void PartInterfaceType::set_componentid_2(const ::std::string& value) {
  set_has_componentid_2();
  if (componentid_2_ == &::google::protobuf::internal::kEmptyString) {
    componentid_2_ = new ::std::string;
  }
  componentid_2_->assign(value);
}
inline void PartInterfaceType::set_componentid_2(const char* value) {
  set_has_componentid_2();
  if (componentid_2_ == &::google::protobuf::internal::kEmptyString) {
    componentid_2_ = new ::std::string;
  }
  componentid_2_->assign(value);
}
inline void PartInterfaceType::set_componentid_2(const char* value, size_t size) {
  set_has_componentid_2();
  if (componentid_2_ == &::google::protobuf::internal::kEmptyString) {
    componentid_2_ = new ::std::string;
  }
  componentid_2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PartInterfaceType::mutable_componentid_2() {
  set_has_componentid_2();
  if (componentid_2_ == &::google::protobuf::internal::kEmptyString) {
    componentid_2_ = new ::std::string;
  }
  return componentid_2_;
}
inline ::std::string* PartInterfaceType::release_componentid_2() {
  clear_has_componentid_2();
  if (componentid_2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_2_;
    componentid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PartInterfaceType::set_allocated_componentid_2(::std::string* componentid_2) {
  if (componentid_2_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_2_;
  }
  if (componentid_2) {
    set_has_componentid_2();
    componentid_2_ = componentid_2;
  } else {
    clear_has_componentid_2();
    componentid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 3;
inline bool PartInterfaceType::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartInterfaceType::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartInterfaceType::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartInterfaceType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& PartInterfaceType::type() const {
  return *type_;
}
inline void PartInterfaceType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PartInterfaceType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PartInterfaceType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PartInterfaceType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* PartInterfaceType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PartInterfaceType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PartInterfacesType

// repeated .edu.vanderbilt.isis.meta.PartInterfaceType PartInterface = 1;
inline int PartInterfacesType::partinterface_size() const {
  return partinterface_.size();
}
inline void PartInterfacesType::clear_partinterface() {
  partinterface_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::PartInterfaceType& PartInterfacesType::partinterface(int index) const {
  return partinterface_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::PartInterfaceType* PartInterfacesType::mutable_partinterface(int index) {
  return partinterface_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::PartInterfaceType* PartInterfacesType::add_partinterface() {
  return partinterface_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PartInterfaceType >&
PartInterfacesType::partinterface() const {
  return partinterface_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::PartInterfaceType >*
PartInterfacesType::mutable_partinterface() {
  return &partinterface_;
}

// -------------------------------------------------------------------

// PinType

// required .edu.vanderbilt.isis.meta.AxialDisplacementType AxialDisplacement = 1;
inline bool PinType::has_axialdisplacement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinType::set_has_axialdisplacement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinType::clear_has_axialdisplacement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinType::clear_axialdisplacement() {
  if (axialdisplacement_ != NULL) axialdisplacement_->::edu::vanderbilt::isis::meta::AxialDisplacementType::Clear();
  clear_has_axialdisplacement();
}
inline const ::edu::vanderbilt::isis::meta::AxialDisplacementType& PinType::axialdisplacement() const {
  return axialdisplacement_ != NULL ? *axialdisplacement_ : *default_instance_->axialdisplacement_;
}
inline ::edu::vanderbilt::isis::meta::AxialDisplacementType* PinType::mutable_axialdisplacement() {
  set_has_axialdisplacement();
  if (axialdisplacement_ == NULL) axialdisplacement_ = new ::edu::vanderbilt::isis::meta::AxialDisplacementType;
  return axialdisplacement_;
}
inline ::edu::vanderbilt::isis::meta::AxialDisplacementType* PinType::release_axialdisplacement() {
  clear_has_axialdisplacement();
  ::edu::vanderbilt::isis::meta::AxialDisplacementType* temp = axialdisplacement_;
  axialdisplacement_ = NULL;
  return temp;
}
inline void PinType::set_allocated_axialdisplacement(::edu::vanderbilt::isis::meta::AxialDisplacementType* axialdisplacement) {
  delete axialdisplacement_;
  axialdisplacement_ = axialdisplacement;
  if (axialdisplacement) {
    set_has_axialdisplacement();
  } else {
    clear_has_axialdisplacement();
  }
}

// required .edu.vanderbilt.isis.meta.AxialRotationType AxialRotation = 2;
inline bool PinType::has_axialrotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PinType::set_has_axialrotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PinType::clear_has_axialrotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PinType::clear_axialrotation() {
  if (axialrotation_ != NULL) axialrotation_->::edu::vanderbilt::isis::meta::AxialRotationType::Clear();
  clear_has_axialrotation();
}
inline const ::edu::vanderbilt::isis::meta::AxialRotationType& PinType::axialrotation() const {
  return axialrotation_ != NULL ? *axialrotation_ : *default_instance_->axialrotation_;
}
inline ::edu::vanderbilt::isis::meta::AxialRotationType* PinType::mutable_axialrotation() {
  set_has_axialrotation();
  if (axialrotation_ == NULL) axialrotation_ = new ::edu::vanderbilt::isis::meta::AxialRotationType;
  return axialrotation_;
}
inline ::edu::vanderbilt::isis::meta::AxialRotationType* PinType::release_axialrotation() {
  clear_has_axialrotation();
  ::edu::vanderbilt::isis::meta::AxialRotationType* temp = axialrotation_;
  axialrotation_ = NULL;
  return temp;
}
inline void PinType::set_allocated_axialrotation(::edu::vanderbilt::isis::meta::AxialRotationType* axialrotation) {
  delete axialrotation_;
  axialrotation_ = axialrotation;
  if (axialrotation) {
    set_has_axialrotation();
  } else {
    clear_has_axialrotation();
  }
}

// -------------------------------------------------------------------

// PointCoordinatesType

// required string ComponentID = 1;
inline bool PointCoordinatesType::has_componentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCoordinatesType::set_has_componentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCoordinatesType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCoordinatesType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& PointCoordinatesType::componentid() const {
  return *componentid_;
}
inline void PointCoordinatesType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void PointCoordinatesType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void PointCoordinatesType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointCoordinatesType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* PointCoordinatesType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointCoordinatesType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FeatureDatumName = 2;
inline bool PointCoordinatesType::has_featuredatumname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointCoordinatesType::set_has_featuredatumname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointCoordinatesType::clear_has_featuredatumname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointCoordinatesType::clear_featuredatumname() {
  if (featuredatumname_ != &::google::protobuf::internal::kEmptyString) {
    featuredatumname_->clear();
  }
  clear_has_featuredatumname();
}
inline const ::std::string& PointCoordinatesType::featuredatumname() const {
  return *featuredatumname_;
}
inline void PointCoordinatesType::set_featuredatumname(const ::std::string& value) {
  set_has_featuredatumname();
  if (featuredatumname_ == &::google::protobuf::internal::kEmptyString) {
    featuredatumname_ = new ::std::string;
  }
  featuredatumname_->assign(value);
}
inline void PointCoordinatesType::set_featuredatumname(const char* value) {
  set_has_featuredatumname();
  if (featuredatumname_ == &::google::protobuf::internal::kEmptyString) {
    featuredatumname_ = new ::std::string;
  }
  featuredatumname_->assign(value);
}
inline void PointCoordinatesType::set_featuredatumname(const char* value, size_t size) {
  set_has_featuredatumname();
  if (featuredatumname_ == &::google::protobuf::internal::kEmptyString) {
    featuredatumname_ = new ::std::string;
  }
  featuredatumname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointCoordinatesType::mutable_featuredatumname() {
  set_has_featuredatumname();
  if (featuredatumname_ == &::google::protobuf::internal::kEmptyString) {
    featuredatumname_ = new ::std::string;
  }
  return featuredatumname_;
}
inline ::std::string* PointCoordinatesType::release_featuredatumname() {
  clear_has_featuredatumname();
  if (featuredatumname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featuredatumname_;
    featuredatumname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointCoordinatesType::set_allocated_featuredatumname(::std::string* featuredatumname) {
  if (featuredatumname_ != &::google::protobuf::internal::kEmptyString) {
    delete featuredatumname_;
  }
  if (featuredatumname) {
    set_has_featuredatumname();
    featuredatumname_ = featuredatumname;
  } else {
    clear_has_featuredatumname();
    featuredatumname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MetricID = 3;
inline bool PointCoordinatesType::has_metricid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointCoordinatesType::set_has_metricid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointCoordinatesType::clear_has_metricid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointCoordinatesType::clear_metricid() {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    metricid_->clear();
  }
  clear_has_metricid();
}
inline const ::std::string& PointCoordinatesType::metricid() const {
  return *metricid_;
}
inline void PointCoordinatesType::set_metricid(const ::std::string& value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void PointCoordinatesType::set_metricid(const char* value) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(value);
}
inline void PointCoordinatesType::set_metricid(const char* value, size_t size) {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  metricid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointCoordinatesType::mutable_metricid() {
  set_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    metricid_ = new ::std::string;
  }
  return metricid_;
}
inline ::std::string* PointCoordinatesType::release_metricid() {
  clear_has_metricid();
  if (metricid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metricid_;
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointCoordinatesType::set_allocated_metricid(::std::string* metricid) {
  if (metricid_ != &::google::protobuf::internal::kEmptyString) {
    delete metricid_;
  }
  if (metricid) {
    set_has_metricid();
    metricid_ = metricid;
  } else {
    clear_has_metricid();
    metricid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RequestedValueType = 4;
inline bool PointCoordinatesType::has_requestedvaluetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointCoordinatesType::set_has_requestedvaluetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointCoordinatesType::clear_has_requestedvaluetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointCoordinatesType::clear_requestedvaluetype() {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_->clear();
  }
  clear_has_requestedvaluetype();
}
inline const ::std::string& PointCoordinatesType::requestedvaluetype() const {
  return *requestedvaluetype_;
}
inline void PointCoordinatesType::set_requestedvaluetype(const ::std::string& value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void PointCoordinatesType::set_requestedvaluetype(const char* value) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(value);
}
inline void PointCoordinatesType::set_requestedvaluetype(const char* value, size_t size) {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  requestedvaluetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointCoordinatesType::mutable_requestedvaluetype() {
  set_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    requestedvaluetype_ = new ::std::string;
  }
  return requestedvaluetype_;
}
inline ::std::string* PointCoordinatesType::release_requestedvaluetype() {
  clear_has_requestedvaluetype();
  if (requestedvaluetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requestedvaluetype_;
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointCoordinatesType::set_allocated_requestedvaluetype(::std::string* requestedvaluetype) {
  if (requestedvaluetype_ != &::google::protobuf::internal::kEmptyString) {
    delete requestedvaluetype_;
  }
  if (requestedvaluetype) {
    set_has_requestedvaluetype();
    requestedvaluetype_ = requestedvaluetype;
  } else {
    clear_has_requestedvaluetype();
    requestedvaluetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PressureType

// required string Units = 1;
inline bool PressureType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PressureType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PressureType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PressureType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& PressureType::units() const {
  return *units_;
}
inline void PressureType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void PressureType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void PressureType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PressureType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* PressureType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PressureType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double Value = 2;
inline bool PressureType::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PressureType::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PressureType::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PressureType::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double PressureType::value() const {
  return value_;
}
inline void PressureType::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PrismaticType

// repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
inline int PrismaticType::kinematicfeature_size() const {
  return kinematicfeature_.size();
}
inline void PrismaticType::clear_kinematicfeature() {
  kinematicfeature_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& PrismaticType::kinematicfeature(int index) const {
  return kinematicfeature_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* PrismaticType::mutable_kinematicfeature(int index) {
  return kinematicfeature_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* PrismaticType::add_kinematicfeature() {
  return kinematicfeature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
PrismaticType::kinematicfeature() const {
  return kinematicfeature_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
PrismaticType::mutable_kinematicfeature() {
  return &kinematicfeature_;
}

// required double CFM = 2;
inline bool PrismaticType::has_cfm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrismaticType::set_has_cfm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrismaticType::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrismaticType::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
inline double PrismaticType::cfm() const {
  return cfm_;
}
inline void PrismaticType::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
}

// required string ConnectedComponentID = 3;
inline bool PrismaticType::has_connectedcomponentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrismaticType::set_has_connectedcomponentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrismaticType::clear_has_connectedcomponentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrismaticType::clear_connectedcomponentid() {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_->clear();
  }
  clear_has_connectedcomponentid();
}
inline const ::std::string& PrismaticType::connectedcomponentid() const {
  return *connectedcomponentid_;
}
inline void PrismaticType::set_connectedcomponentid(const ::std::string& value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void PrismaticType::set_connectedcomponentid(const char* value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void PrismaticType::set_connectedcomponentid(const char* value, size_t size) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrismaticType::mutable_connectedcomponentid() {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  return connectedcomponentid_;
}
inline ::std::string* PrismaticType::release_connectedcomponentid() {
  clear_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectedcomponentid_;
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrismaticType::set_allocated_connectedcomponentid(::std::string* connectedcomponentid) {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectedcomponentid_;
  }
  if (connectedcomponentid) {
    set_has_connectedcomponentid();
    connectedcomponentid_ = connectedcomponentid;
  } else {
    clear_has_connectedcomponentid();
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ConnectionID = 4;
inline bool PrismaticType::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrismaticType::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrismaticType::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrismaticType::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& PrismaticType::connectionid() const {
  return *connectionid_;
}
inline void PrismaticType::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void PrismaticType::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void PrismaticType::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrismaticType::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* PrismaticType::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrismaticType::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double ERP = 5;
inline bool PrismaticType::has_erp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrismaticType::set_has_erp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrismaticType::clear_has_erp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrismaticType::clear_erp() {
  erp_ = 0;
  clear_has_erp();
}
inline double PrismaticType::erp() const {
  return erp_;
}
inline void PrismaticType::set_erp(double value) {
  set_has_erp();
  erp_ = value;
}

// required string FeatureInterfaceType = 6;
inline bool PrismaticType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrismaticType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrismaticType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrismaticType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& PrismaticType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void PrismaticType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void PrismaticType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void PrismaticType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrismaticType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* PrismaticType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrismaticType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PropertiesType

// optional .edu.vanderbilt.isis.meta.UnitsType Units = 1;
inline bool PropertiesType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertiesType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertiesType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertiesType::clear_units() {
  if (units_ != NULL) units_->::edu::vanderbilt::isis::meta::UnitsType::Clear();
  clear_has_units();
}
inline const ::edu::vanderbilt::isis::meta::UnitsType& PropertiesType::units() const {
  return units_ != NULL ? *units_ : *default_instance_->units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* PropertiesType::mutable_units() {
  set_has_units();
  if (units_ == NULL) units_ = new ::edu::vanderbilt::isis::meta::UnitsType;
  return units_;
}
inline ::edu::vanderbilt::isis::meta::UnitsType* PropertiesType::release_units() {
  clear_has_units();
  ::edu::vanderbilt::isis::meta::UnitsType* temp = units_;
  units_ = NULL;
  return temp;
}
inline void PropertiesType::set_allocated_units(::edu::vanderbilt::isis::meta::UnitsType* units) {
  delete units_;
  units_ = units;
  if (units) {
    set_has_units();
  } else {
    clear_has_units();
  }
}

// -------------------------------------------------------------------

// ReferencePlaneType

// required string Type = 1;
inline bool ReferencePlaneType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferencePlaneType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferencePlaneType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferencePlaneType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReferencePlaneType::type() const {
  return *type_;
}
inline void ReferencePlaneType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReferencePlaneType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReferencePlaneType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReferencePlaneType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ReferencePlaneType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReferencePlaneType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RevoluteType

// repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
inline int RevoluteType::kinematicfeature_size() const {
  return kinematicfeature_.size();
}
inline void RevoluteType::clear_kinematicfeature() {
  kinematicfeature_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& RevoluteType::kinematicfeature(int index) const {
  return kinematicfeature_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* RevoluteType::mutable_kinematicfeature(int index) {
  return kinematicfeature_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* RevoluteType::add_kinematicfeature() {
  return kinematicfeature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
RevoluteType::kinematicfeature() const {
  return kinematicfeature_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
RevoluteType::mutable_kinematicfeature() {
  return &kinematicfeature_;
}

// required double CFM = 2;
inline bool RevoluteType::has_cfm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RevoluteType::set_has_cfm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RevoluteType::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RevoluteType::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
inline double RevoluteType::cfm() const {
  return cfm_;
}
inline void RevoluteType::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
}

// required string ConnectedComponentID = 3;
inline bool RevoluteType::has_connectedcomponentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RevoluteType::set_has_connectedcomponentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RevoluteType::clear_has_connectedcomponentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RevoluteType::clear_connectedcomponentid() {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_->clear();
  }
  clear_has_connectedcomponentid();
}
inline const ::std::string& RevoluteType::connectedcomponentid() const {
  return *connectedcomponentid_;
}
inline void RevoluteType::set_connectedcomponentid(const ::std::string& value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void RevoluteType::set_connectedcomponentid(const char* value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void RevoluteType::set_connectedcomponentid(const char* value, size_t size) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RevoluteType::mutable_connectedcomponentid() {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  return connectedcomponentid_;
}
inline ::std::string* RevoluteType::release_connectedcomponentid() {
  clear_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectedcomponentid_;
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RevoluteType::set_allocated_connectedcomponentid(::std::string* connectedcomponentid) {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectedcomponentid_;
  }
  if (connectedcomponentid) {
    set_has_connectedcomponentid();
    connectedcomponentid_ = connectedcomponentid;
  } else {
    clear_has_connectedcomponentid();
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ConnectionID = 4;
inline bool RevoluteType::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RevoluteType::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RevoluteType::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RevoluteType::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& RevoluteType::connectionid() const {
  return *connectionid_;
}
inline void RevoluteType::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void RevoluteType::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void RevoluteType::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RevoluteType::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* RevoluteType::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RevoluteType::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double ERP = 5;
inline bool RevoluteType::has_erp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RevoluteType::set_has_erp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RevoluteType::clear_has_erp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RevoluteType::clear_erp() {
  erp_ = 0;
  clear_has_erp();
}
inline double RevoluteType::erp() const {
  return erp_;
}
inline void RevoluteType::set_erp(double value) {
  set_has_erp();
  erp_ = value;
}

// required string FeatureInterfaceType = 6;
inline bool RevoluteType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RevoluteType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RevoluteType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RevoluteType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& RevoluteType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void RevoluteType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void RevoluteType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void RevoluteType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RevoluteType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* RevoluteType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RevoluteType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RotationType

// required string Units = 1;
inline bool RotationType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotationType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotationType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotationType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& RotationType::units() const {
  return *units_;
}
inline void RotationType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void RotationType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void RotationType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotationType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* RotationType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotationType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string x = 3;
inline bool RotationType::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotationType::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotationType::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotationType::clear_x() {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    x_->clear();
  }
  clear_has_x();
}
inline const ::std::string& RotationType::x() const {
  return *x_;
}
inline void RotationType::set_x(const ::std::string& value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void RotationType::set_x(const char* value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void RotationType::set_x(const char* value, size_t size) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotationType::mutable_x() {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  return x_;
}
inline ::std::string* RotationType::release_x() {
  clear_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_;
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotationType::set_allocated_x(::std::string* x) {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    delete x_;
  }
  if (x) {
    set_has_x();
    x_ = x;
  } else {
    clear_has_x();
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string y = 4;
inline bool RotationType::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotationType::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotationType::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotationType::clear_y() {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    y_->clear();
  }
  clear_has_y();
}
inline const ::std::string& RotationType::y() const {
  return *y_;
}
inline void RotationType::set_y(const ::std::string& value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void RotationType::set_y(const char* value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void RotationType::set_y(const char* value, size_t size) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotationType::mutable_y() {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  return y_;
}
inline ::std::string* RotationType::release_y() {
  clear_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_;
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotationType::set_allocated_y(::std::string* y) {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    delete y_;
  }
  if (y) {
    set_has_y();
    y_ = y;
  } else {
    clear_has_y();
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string z = 5;
inline bool RotationType::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotationType::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotationType::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotationType::clear_z() {
  if (z_ != &::google::protobuf::internal::kEmptyString) {
    z_->clear();
  }
  clear_has_z();
}
inline const ::std::string& RotationType::z() const {
  return *z_;
}
inline void RotationType::set_z(const ::std::string& value) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(value);
}
inline void RotationType::set_z(const char* value) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(value);
}
inline void RotationType::set_z(const char* value, size_t size) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotationType::mutable_z() {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  return z_;
}
inline ::std::string* RotationType::release_z() {
  clear_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = z_;
    z_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotationType::set_allocated_z(::std::string* z) {
  if (z_ != &::google::protobuf::internal::kEmptyString) {
    delete z_;
  }
  if (z) {
    set_has_z();
    z_ = z;
  } else {
    clear_has_z();
    z_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// STEPFormatType

// required string Name = 1;
inline bool STEPFormatType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void STEPFormatType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void STEPFormatType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void STEPFormatType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& STEPFormatType::name() const {
  return *name_;
}
inline void STEPFormatType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void STEPFormatType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void STEPFormatType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* STEPFormatType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* STEPFormatType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void STEPFormatType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SetOperationType

// required string FeatureID = 1;
inline bool SetOperationType::has_featureid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetOperationType::set_has_featureid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetOperationType::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetOperationType::clear_featureid() {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    featureid_->clear();
  }
  clear_has_featureid();
}
inline const ::std::string& SetOperationType::featureid() const {
  return *featureid_;
}
inline void SetOperationType::set_featureid(const ::std::string& value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void SetOperationType::set_featureid(const char* value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void SetOperationType::set_featureid(const char* value, size_t size) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetOperationType::mutable_featureid() {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  return featureid_;
}
inline ::std::string* SetOperationType::release_featureid() {
  clear_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureid_;
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetOperationType::set_allocated_featureid(::std::string* featureid) {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    delete featureid_;
  }
  if (featureid) {
    set_has_featureid();
    featureid_ = featureid;
  } else {
    clear_has_featureid();
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 2;
inline bool SetOperationType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetOperationType::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetOperationType::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetOperationType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SetOperationType::type() const {
  return *type_;
}
inline void SetOperationType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SetOperationType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SetOperationType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetOperationType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SetOperationType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetOperationType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ShotlineType

// required double Azimuth = 1;
inline bool ShotlineType::has_azimuth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShotlineType::set_has_azimuth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShotlineType::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShotlineType::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline double ShotlineType::azimuth() const {
  return azimuth_;
}
inline void ShotlineType::set_azimuth(double value) {
  set_has_azimuth();
  azimuth_ = value;
}

// required string BallisticThreatRef = 2;
inline bool ShotlineType::has_ballisticthreatref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShotlineType::set_has_ballisticthreatref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShotlineType::clear_has_ballisticthreatref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShotlineType::clear_ballisticthreatref() {
  if (ballisticthreatref_ != &::google::protobuf::internal::kEmptyString) {
    ballisticthreatref_->clear();
  }
  clear_has_ballisticthreatref();
}
inline const ::std::string& ShotlineType::ballisticthreatref() const {
  return *ballisticthreatref_;
}
inline void ShotlineType::set_ballisticthreatref(const ::std::string& value) {
  set_has_ballisticthreatref();
  if (ballisticthreatref_ == &::google::protobuf::internal::kEmptyString) {
    ballisticthreatref_ = new ::std::string;
  }
  ballisticthreatref_->assign(value);
}
inline void ShotlineType::set_ballisticthreatref(const char* value) {
  set_has_ballisticthreatref();
  if (ballisticthreatref_ == &::google::protobuf::internal::kEmptyString) {
    ballisticthreatref_ = new ::std::string;
  }
  ballisticthreatref_->assign(value);
}
inline void ShotlineType::set_ballisticthreatref(const char* value, size_t size) {
  set_has_ballisticthreatref();
  if (ballisticthreatref_ == &::google::protobuf::internal::kEmptyString) {
    ballisticthreatref_ = new ::std::string;
  }
  ballisticthreatref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShotlineType::mutable_ballisticthreatref() {
  set_has_ballisticthreatref();
  if (ballisticthreatref_ == &::google::protobuf::internal::kEmptyString) {
    ballisticthreatref_ = new ::std::string;
  }
  return ballisticthreatref_;
}
inline ::std::string* ShotlineType::release_ballisticthreatref() {
  clear_has_ballisticthreatref();
  if (ballisticthreatref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ballisticthreatref_;
    ballisticthreatref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShotlineType::set_allocated_ballisticthreatref(::std::string* ballisticthreatref) {
  if (ballisticthreatref_ != &::google::protobuf::internal::kEmptyString) {
    delete ballisticthreatref_;
  }
  if (ballisticthreatref) {
    set_has_ballisticthreatref();
    ballisticthreatref_ = ballisticthreatref;
  } else {
    clear_has_ballisticthreatref();
    ballisticthreatref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ComponentID = 3;
inline bool ShotlineType::has_componentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShotlineType::set_has_componentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShotlineType::clear_has_componentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShotlineType::clear_componentid() {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    componentid_->clear();
  }
  clear_has_componentid();
}
inline const ::std::string& ShotlineType::componentid() const {
  return *componentid_;
}
inline void ShotlineType::set_componentid(const ::std::string& value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ShotlineType::set_componentid(const char* value) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(value);
}
inline void ShotlineType::set_componentid(const char* value, size_t size) {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  componentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShotlineType::mutable_componentid() {
  set_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    componentid_ = new ::std::string;
  }
  return componentid_;
}
inline ::std::string* ShotlineType::release_componentid() {
  clear_has_componentid();
  if (componentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = componentid_;
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShotlineType::set_allocated_componentid(::std::string* componentid) {
  if (componentid_ != &::google::protobuf::internal::kEmptyString) {
    delete componentid_;
  }
  if (componentid) {
    set_has_componentid();
    componentid_ = componentid;
  } else {
    clear_has_componentid();
    componentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DatumPoint = 4;
inline bool ShotlineType::has_datumpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShotlineType::set_has_datumpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShotlineType::clear_has_datumpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShotlineType::clear_datumpoint() {
  if (datumpoint_ != &::google::protobuf::internal::kEmptyString) {
    datumpoint_->clear();
  }
  clear_has_datumpoint();
}
inline const ::std::string& ShotlineType::datumpoint() const {
  return *datumpoint_;
}
inline void ShotlineType::set_datumpoint(const ::std::string& value) {
  set_has_datumpoint();
  if (datumpoint_ == &::google::protobuf::internal::kEmptyString) {
    datumpoint_ = new ::std::string;
  }
  datumpoint_->assign(value);
}
inline void ShotlineType::set_datumpoint(const char* value) {
  set_has_datumpoint();
  if (datumpoint_ == &::google::protobuf::internal::kEmptyString) {
    datumpoint_ = new ::std::string;
  }
  datumpoint_->assign(value);
}
inline void ShotlineType::set_datumpoint(const char* value, size_t size) {
  set_has_datumpoint();
  if (datumpoint_ == &::google::protobuf::internal::kEmptyString) {
    datumpoint_ = new ::std::string;
  }
  datumpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShotlineType::mutable_datumpoint() {
  set_has_datumpoint();
  if (datumpoint_ == &::google::protobuf::internal::kEmptyString) {
    datumpoint_ = new ::std::string;
  }
  return datumpoint_;
}
inline ::std::string* ShotlineType::release_datumpoint() {
  clear_has_datumpoint();
  if (datumpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datumpoint_;
    datumpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShotlineType::set_allocated_datumpoint(::std::string* datumpoint) {
  if (datumpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete datumpoint_;
  }
  if (datumpoint) {
    set_has_datumpoint();
    datumpoint_ = datumpoint;
  } else {
    clear_has_datumpoint();
    datumpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double Elevation = 5;
inline bool ShotlineType::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShotlineType::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShotlineType::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShotlineType::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double ShotlineType::elevation() const {
  return elevation_;
}
inline void ShotlineType::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// -------------------------------------------------------------------

// ShotlinesType

// repeated .edu.vanderbilt.isis.meta.ShotlineType Shotline = 1;
inline int ShotlinesType::shotline_size() const {
  return shotline_.size();
}
inline void ShotlinesType::clear_shotline() {
  shotline_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::ShotlineType& ShotlinesType::shotline(int index) const {
  return shotline_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::ShotlineType* ShotlinesType::mutable_shotline(int index) {
  return shotline_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::ShotlineType* ShotlinesType::add_shotline() {
  return shotline_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ShotlineType >&
ShotlinesType::shotline() const {
  return shotline_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::ShotlineType >*
ShotlinesType::mutable_shotline() {
  return &shotline_;
}

// -------------------------------------------------------------------

// SolverType

// required string ElementShapeType = 1;
inline bool SolverType::has_elementshapetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverType::set_has_elementshapetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverType::clear_has_elementshapetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverType::clear_elementshapetype() {
  if (elementshapetype_ != &::google::protobuf::internal::kEmptyString) {
    elementshapetype_->clear();
  }
  clear_has_elementshapetype();
}
inline const ::std::string& SolverType::elementshapetype() const {
  return *elementshapetype_;
}
inline void SolverType::set_elementshapetype(const ::std::string& value) {
  set_has_elementshapetype();
  if (elementshapetype_ == &::google::protobuf::internal::kEmptyString) {
    elementshapetype_ = new ::std::string;
  }
  elementshapetype_->assign(value);
}
inline void SolverType::set_elementshapetype(const char* value) {
  set_has_elementshapetype();
  if (elementshapetype_ == &::google::protobuf::internal::kEmptyString) {
    elementshapetype_ = new ::std::string;
  }
  elementshapetype_->assign(value);
}
inline void SolverType::set_elementshapetype(const char* value, size_t size) {
  set_has_elementshapetype();
  if (elementshapetype_ == &::google::protobuf::internal::kEmptyString) {
    elementshapetype_ = new ::std::string;
  }
  elementshapetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverType::mutable_elementshapetype() {
  set_has_elementshapetype();
  if (elementshapetype_ == &::google::protobuf::internal::kEmptyString) {
    elementshapetype_ = new ::std::string;
  }
  return elementshapetype_;
}
inline ::std::string* SolverType::release_elementshapetype() {
  clear_has_elementshapetype();
  if (elementshapetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = elementshapetype_;
    elementshapetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverType::set_allocated_elementshapetype(::std::string* elementshapetype) {
  if (elementshapetype_ != &::google::protobuf::internal::kEmptyString) {
    delete elementshapetype_;
  }
  if (elementshapetype) {
    set_has_elementshapetype();
    elementshapetype_ = elementshapetype;
  } else {
    clear_has_elementshapetype();
    elementshapetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MeshType = 2;
inline bool SolverType::has_meshtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverType::set_has_meshtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverType::clear_has_meshtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverType::clear_meshtype() {
  if (meshtype_ != &::google::protobuf::internal::kEmptyString) {
    meshtype_->clear();
  }
  clear_has_meshtype();
}
inline const ::std::string& SolverType::meshtype() const {
  return *meshtype_;
}
inline void SolverType::set_meshtype(const ::std::string& value) {
  set_has_meshtype();
  if (meshtype_ == &::google::protobuf::internal::kEmptyString) {
    meshtype_ = new ::std::string;
  }
  meshtype_->assign(value);
}
inline void SolverType::set_meshtype(const char* value) {
  set_has_meshtype();
  if (meshtype_ == &::google::protobuf::internal::kEmptyString) {
    meshtype_ = new ::std::string;
  }
  meshtype_->assign(value);
}
inline void SolverType::set_meshtype(const char* value, size_t size) {
  set_has_meshtype();
  if (meshtype_ == &::google::protobuf::internal::kEmptyString) {
    meshtype_ = new ::std::string;
  }
  meshtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverType::mutable_meshtype() {
  set_has_meshtype();
  if (meshtype_ == &::google::protobuf::internal::kEmptyString) {
    meshtype_ = new ::std::string;
  }
  return meshtype_;
}
inline ::std::string* SolverType::release_meshtype() {
  clear_has_meshtype();
  if (meshtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meshtype_;
    meshtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverType::set_allocated_meshtype(::std::string* meshtype) {
  if (meshtype_ != &::google::protobuf::internal::kEmptyString) {
    delete meshtype_;
  }
  if (meshtype) {
    set_has_meshtype();
    meshtype_ = meshtype;
  } else {
    clear_has_meshtype();
    meshtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ShellElementType = 3;
inline bool SolverType::has_shellelementtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverType::set_has_shellelementtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverType::clear_has_shellelementtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverType::clear_shellelementtype() {
  if (shellelementtype_ != &::google::protobuf::internal::kEmptyString) {
    shellelementtype_->clear();
  }
  clear_has_shellelementtype();
}
inline const ::std::string& SolverType::shellelementtype() const {
  return *shellelementtype_;
}
inline void SolverType::set_shellelementtype(const ::std::string& value) {
  set_has_shellelementtype();
  if (shellelementtype_ == &::google::protobuf::internal::kEmptyString) {
    shellelementtype_ = new ::std::string;
  }
  shellelementtype_->assign(value);
}
inline void SolverType::set_shellelementtype(const char* value) {
  set_has_shellelementtype();
  if (shellelementtype_ == &::google::protobuf::internal::kEmptyString) {
    shellelementtype_ = new ::std::string;
  }
  shellelementtype_->assign(value);
}
inline void SolverType::set_shellelementtype(const char* value, size_t size) {
  set_has_shellelementtype();
  if (shellelementtype_ == &::google::protobuf::internal::kEmptyString) {
    shellelementtype_ = new ::std::string;
  }
  shellelementtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverType::mutable_shellelementtype() {
  set_has_shellelementtype();
  if (shellelementtype_ == &::google::protobuf::internal::kEmptyString) {
    shellelementtype_ = new ::std::string;
  }
  return shellelementtype_;
}
inline ::std::string* SolverType::release_shellelementtype() {
  clear_has_shellelementtype();
  if (shellelementtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shellelementtype_;
    shellelementtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverType::set_allocated_shellelementtype(::std::string* shellelementtype) {
  if (shellelementtype_ != &::google::protobuf::internal::kEmptyString) {
    delete shellelementtype_;
  }
  if (shellelementtype) {
    set_has_shellelementtype();
    shellelementtype_ = shellelementtype;
  } else {
    clear_has_shellelementtype();
    shellelementtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Type = 4;
inline bool SolverType::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverType::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverType::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SolverType::type() const {
  return *type_;
}
inline void SolverType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SolverType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SolverType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SolverType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverType::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SolversType

// repeated .edu.vanderbilt.isis.meta.SolverType Solver = 1;
inline int SolversType::solver_size() const {
  return solver_.size();
}
inline void SolversType::clear_solver() {
  solver_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::SolverType& SolversType::solver(int index) const {
  return solver_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::SolverType* SolversType::mutable_solver(int index) {
  return solver_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::SolverType* SolversType::add_solver() {
  return solver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SolverType >&
SolversType::solver() const {
  return solver_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SolverType >*
SolversType::mutable_solver() {
  return &solver_;
}

// -------------------------------------------------------------------

// SphericalType

// repeated .edu.vanderbilt.isis.meta.KinematicFeatureType KinematicFeature = 1;
inline int SphericalType::kinematicfeature_size() const {
  return kinematicfeature_.size();
}
inline void SphericalType::clear_kinematicfeature() {
  kinematicfeature_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::KinematicFeatureType& SphericalType::kinematicfeature(int index) const {
  return kinematicfeature_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* SphericalType::mutable_kinematicfeature(int index) {
  return kinematicfeature_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::KinematicFeatureType* SphericalType::add_kinematicfeature() {
  return kinematicfeature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >&
SphericalType::kinematicfeature() const {
  return kinematicfeature_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::KinematicFeatureType >*
SphericalType::mutable_kinematicfeature() {
  return &kinematicfeature_;
}

// required double CFM = 2;
inline bool SphericalType::has_cfm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SphericalType::set_has_cfm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SphericalType::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SphericalType::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
inline double SphericalType::cfm() const {
  return cfm_;
}
inline void SphericalType::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
}

// required string ConnectedComponentID = 3;
inline bool SphericalType::has_connectedcomponentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SphericalType::set_has_connectedcomponentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SphericalType::clear_has_connectedcomponentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SphericalType::clear_connectedcomponentid() {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_->clear();
  }
  clear_has_connectedcomponentid();
}
inline const ::std::string& SphericalType::connectedcomponentid() const {
  return *connectedcomponentid_;
}
inline void SphericalType::set_connectedcomponentid(const ::std::string& value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void SphericalType::set_connectedcomponentid(const char* value) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(value);
}
inline void SphericalType::set_connectedcomponentid(const char* value, size_t size) {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  connectedcomponentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SphericalType::mutable_connectedcomponentid() {
  set_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    connectedcomponentid_ = new ::std::string;
  }
  return connectedcomponentid_;
}
inline ::std::string* SphericalType::release_connectedcomponentid() {
  clear_has_connectedcomponentid();
  if (connectedcomponentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectedcomponentid_;
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SphericalType::set_allocated_connectedcomponentid(::std::string* connectedcomponentid) {
  if (connectedcomponentid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectedcomponentid_;
  }
  if (connectedcomponentid) {
    set_has_connectedcomponentid();
    connectedcomponentid_ = connectedcomponentid;
  } else {
    clear_has_connectedcomponentid();
    connectedcomponentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ConnectionID = 4;
inline bool SphericalType::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SphericalType::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SphericalType::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SphericalType::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& SphericalType::connectionid() const {
  return *connectionid_;
}
inline void SphericalType::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void SphericalType::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void SphericalType::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SphericalType::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* SphericalType::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SphericalType::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double ERP = 5;
inline bool SphericalType::has_erp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SphericalType::set_has_erp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SphericalType::clear_has_erp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SphericalType::clear_erp() {
  erp_ = 0;
  clear_has_erp();
}
inline double SphericalType::erp() const {
  return erp_;
}
inline void SphericalType::set_erp(double value) {
  set_has_erp();
  erp_ = value;
}

// required string FeatureInterfaceType = 6;
inline bool SphericalType::has_featureinterfacetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SphericalType::set_has_featureinterfacetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SphericalType::clear_has_featureinterfacetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SphericalType::clear_featureinterfacetype() {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_->clear();
  }
  clear_has_featureinterfacetype();
}
inline const ::std::string& SphericalType::featureinterfacetype() const {
  return *featureinterfacetype_;
}
inline void SphericalType::set_featureinterfacetype(const ::std::string& value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void SphericalType::set_featureinterfacetype(const char* value) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(value);
}
inline void SphericalType::set_featureinterfacetype(const char* value, size_t size) {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  featureinterfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SphericalType::mutable_featureinterfacetype() {
  set_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    featureinterfacetype_ = new ::std::string;
  }
  return featureinterfacetype_;
}
inline ::std::string* SphericalType::release_featureinterfacetype() {
  clear_has_featureinterfacetype();
  if (featureinterfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureinterfacetype_;
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SphericalType::set_allocated_featureinterfacetype(::std::string* featureinterfacetype) {
  if (featureinterfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete featureinterfacetype_;
  }
  if (featureinterfacetype) {
    set_has_featureinterfacetype();
    featureinterfacetype_ = featureinterfacetype;
  } else {
    clear_has_featureinterfacetype();
    featureinterfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SurfaceTreatmentType

// optional .edu.vanderbilt.isis.meta.GeometryType Geometry = 1;
inline bool SurfaceTreatmentType::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SurfaceTreatmentType::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SurfaceTreatmentType::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SurfaceTreatmentType::clear_geometry() {
  if (geometry_ != NULL) geometry_->::edu::vanderbilt::isis::meta::GeometryType::Clear();
  clear_has_geometry();
}
inline const ::edu::vanderbilt::isis::meta::GeometryType& SurfaceTreatmentType::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* SurfaceTreatmentType::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::edu::vanderbilt::isis::meta::GeometryType;
  return geometry_;
}
inline ::edu::vanderbilt::isis::meta::GeometryType* SurfaceTreatmentType::release_geometry() {
  clear_has_geometry();
  ::edu::vanderbilt::isis::meta::GeometryType* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void SurfaceTreatmentType::set_allocated_geometry(::edu::vanderbilt::isis::meta::GeometryType* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional string AdjoiningParts = 2;
inline bool SurfaceTreatmentType::has_adjoiningparts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SurfaceTreatmentType::set_has_adjoiningparts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SurfaceTreatmentType::clear_has_adjoiningparts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SurfaceTreatmentType::clear_adjoiningparts() {
  if (adjoiningparts_ != &::google::protobuf::internal::kEmptyString) {
    adjoiningparts_->clear();
  }
  clear_has_adjoiningparts();
}
inline const ::std::string& SurfaceTreatmentType::adjoiningparts() const {
  return *adjoiningparts_;
}
inline void SurfaceTreatmentType::set_adjoiningparts(const ::std::string& value) {
  set_has_adjoiningparts();
  if (adjoiningparts_ == &::google::protobuf::internal::kEmptyString) {
    adjoiningparts_ = new ::std::string;
  }
  adjoiningparts_->assign(value);
}
inline void SurfaceTreatmentType::set_adjoiningparts(const char* value) {
  set_has_adjoiningparts();
  if (adjoiningparts_ == &::google::protobuf::internal::kEmptyString) {
    adjoiningparts_ = new ::std::string;
  }
  adjoiningparts_->assign(value);
}
inline void SurfaceTreatmentType::set_adjoiningparts(const char* value, size_t size) {
  set_has_adjoiningparts();
  if (adjoiningparts_ == &::google::protobuf::internal::kEmptyString) {
    adjoiningparts_ = new ::std::string;
  }
  adjoiningparts_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SurfaceTreatmentType::mutable_adjoiningparts() {
  set_has_adjoiningparts();
  if (adjoiningparts_ == &::google::protobuf::internal::kEmptyString) {
    adjoiningparts_ = new ::std::string;
  }
  return adjoiningparts_;
}
inline ::std::string* SurfaceTreatmentType::release_adjoiningparts() {
  clear_has_adjoiningparts();
  if (adjoiningparts_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adjoiningparts_;
    adjoiningparts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SurfaceTreatmentType::set_allocated_adjoiningparts(::std::string* adjoiningparts) {
  if (adjoiningparts_ != &::google::protobuf::internal::kEmptyString) {
    delete adjoiningparts_;
  }
  if (adjoiningparts) {
    set_has_adjoiningparts();
    adjoiningparts_ = adjoiningparts;
  } else {
    clear_has_adjoiningparts();
    adjoiningparts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SurfaceTreatmentsType

// repeated .edu.vanderbilt.isis.meta.SurfaceTreatmentType SurfaceTreatment = 1;
inline int SurfaceTreatmentsType::surfacetreatment_size() const {
  return surfacetreatment_.size();
}
inline void SurfaceTreatmentsType::clear_surfacetreatment() {
  surfacetreatment_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::SurfaceTreatmentType& SurfaceTreatmentsType::surfacetreatment(int index) const {
  return surfacetreatment_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentType* SurfaceTreatmentsType::mutable_surfacetreatment(int index) {
  return surfacetreatment_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::SurfaceTreatmentType* SurfaceTreatmentsType::add_surfacetreatment() {
  return surfacetreatment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentType >&
SurfaceTreatmentsType::surfacetreatment() const {
  return surfacetreatment_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::SurfaceTreatmentType >*
SurfaceTreatmentsType::mutable_surfacetreatment() {
  return &surfacetreatment_;
}

// -------------------------------------------------------------------

// ToleranceType

// required string AnalysisID = 1;
inline bool ToleranceType::has_analysisid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToleranceType::set_has_analysisid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToleranceType::clear_has_analysisid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToleranceType::clear_analysisid() {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    analysisid_->clear();
  }
  clear_has_analysisid();
}
inline const ::std::string& ToleranceType::analysisid() const {
  return *analysisid_;
}
inline void ToleranceType::set_analysisid(const ::std::string& value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void ToleranceType::set_analysisid(const char* value) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(value);
}
inline void ToleranceType::set_analysisid(const char* value, size_t size) {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  analysisid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ToleranceType::mutable_analysisid() {
  set_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    analysisid_ = new ::std::string;
  }
  return analysisid_;
}
inline ::std::string* ToleranceType::release_analysisid() {
  clear_has_analysisid();
  if (analysisid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = analysisid_;
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ToleranceType::set_allocated_analysisid(::std::string* analysisid) {
  if (analysisid_ != &::google::protobuf::internal::kEmptyString) {
    delete analysisid_;
  }
  if (analysisid) {
    set_has_analysisid();
    analysisid_ = analysisid;
  } else {
    clear_has_analysisid();
    analysisid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TranslationType

// required string Units = 1;
inline bool TranslationType::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslationType::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslationType::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslationType::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& TranslationType::units() const {
  return *units_;
}
inline void TranslationType::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void TranslationType::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void TranslationType::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslationType::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* TranslationType::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslationType::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string x = 3;
inline bool TranslationType::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranslationType::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranslationType::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranslationType::clear_x() {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    x_->clear();
  }
  clear_has_x();
}
inline const ::std::string& TranslationType::x() const {
  return *x_;
}
inline void TranslationType::set_x(const ::std::string& value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void TranslationType::set_x(const char* value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void TranslationType::set_x(const char* value, size_t size) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslationType::mutable_x() {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  return x_;
}
inline ::std::string* TranslationType::release_x() {
  clear_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_;
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslationType::set_allocated_x(::std::string* x) {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    delete x_;
  }
  if (x) {
    set_has_x();
    x_ = x;
  } else {
    clear_has_x();
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string y = 4;
inline bool TranslationType::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranslationType::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranslationType::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranslationType::clear_y() {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    y_->clear();
  }
  clear_has_y();
}
inline const ::std::string& TranslationType::y() const {
  return *y_;
}
inline void TranslationType::set_y(const ::std::string& value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void TranslationType::set_y(const char* value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void TranslationType::set_y(const char* value, size_t size) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslationType::mutable_y() {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  return y_;
}
inline ::std::string* TranslationType::release_y() {
  clear_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_;
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslationType::set_allocated_y(::std::string* y) {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    delete y_;
  }
  if (y) {
    set_has_y();
    y_ = y;
  } else {
    clear_has_y();
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string z = 5;
inline bool TranslationType::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranslationType::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TranslationType::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TranslationType::clear_z() {
  if (z_ != &::google::protobuf::internal::kEmptyString) {
    z_->clear();
  }
  clear_has_z();
}
inline const ::std::string& TranslationType::z() const {
  return *z_;
}
inline void TranslationType::set_z(const ::std::string& value) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(value);
}
inline void TranslationType::set_z(const char* value) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(value);
}
inline void TranslationType::set_z(const char* value, size_t size) {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  z_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslationType::mutable_z() {
  set_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    z_ = new ::std::string;
  }
  return z_;
}
inline ::std::string* TranslationType::release_z() {
  clear_has_z();
  if (z_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = z_;
    z_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslationType::set_allocated_z(::std::string* z) {
  if (z_ != &::google::protobuf::internal::kEmptyString) {
    delete z_;
  }
  if (z) {
    set_has_z();
    z_ = z;
  } else {
    clear_has_z();
    z_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnassembledComponentsType

// repeated .edu.vanderbilt.isis.meta.CADComponentType CADComponent = 1;
inline int UnassembledComponentsType::cadcomponent_size() const {
  return cadcomponent_.size();
}
inline void UnassembledComponentsType::clear_cadcomponent() {
  cadcomponent_.Clear();
}
inline const ::edu::vanderbilt::isis::meta::CADComponentType& UnassembledComponentsType::cadcomponent(int index) const {
  return cadcomponent_.Get(index);
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* UnassembledComponentsType::mutable_cadcomponent(int index) {
  return cadcomponent_.Mutable(index);
}
inline ::edu::vanderbilt::isis::meta::CADComponentType* UnassembledComponentsType::add_cadcomponent() {
  return cadcomponent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >&
UnassembledComponentsType::cadcomponent() const {
  return cadcomponent_;
}
inline ::google::protobuf::RepeatedPtrField< ::edu::vanderbilt::isis::meta::CADComponentType >*
UnassembledComponentsType::mutable_cadcomponent() {
  return &cadcomponent_;
}

// -------------------------------------------------------------------

// UnitsType

// required string Value = 1;
inline bool UnitsType::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitsType::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitsType::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitsType::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UnitsType::value() const {
  return *value_;
}
inline void UnitsType::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UnitsType::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UnitsType::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnitsType::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* UnitsType::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnitsType::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace isis
}  // namespace vanderbilt
}  // namespace edu

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType>() {
  return ::edu::vanderbilt::isis::meta::ConnectorDatumType_AlignType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AssemblyInterface_2eproto__INCLUDED
