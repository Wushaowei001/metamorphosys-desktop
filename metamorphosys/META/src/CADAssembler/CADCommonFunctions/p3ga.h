/*
Gaigen 2.5 Test Suite
*/
/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage p3ga documentation
 *
 * p3ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _P3GA_H_
#define _P3GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <time.h> /* used to seed random generator */
namespace p3ga {

// group: 1
#define GROUP_0 1
// group: e1, e2, e3, e0
#define GROUP_1 2
// group: e1^e2, e1^e3, e2^e3, e1^e0, e2^e0, e3^e0
#define GROUP_2 4
// group: e1^e2^e3, e1^e2^e0, e1^e3^e0, e2^e3^e0
#define GROUP_3 8
// group: e1^e2^e3^e0
#define GROUP_4 16
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16


/// The dimension of the space:
extern const int p3ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int p3ga_nbGroups;

/// The constants for the groups in an array:
extern const int p3ga_groups[];

/// The constants for the grades in an array:
extern const int p3ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool p3ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int p3ga_groupSize[5];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int p3ga_mvSize[32];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *p3ga_basisVectorNames[4];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int p3ga_basisElements[16][5];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double p3ga_basisElementSignByIndex[16];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double p3ga_basisElementSignByBitmap[16];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int p3ga_basisElementIndexByBitmap[16];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int p3ga_basisElementBitmapByIndex[16];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int p3ga_basisElementGradeByBitmap[16];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int p3ga_basisElementGroupByBitmap[16];
class mv;
class e1_t;
class e2_t;
class e3_t;
class e0_t;
class I4_t;
class I4i_t;
class vector;
class point;
class normalizedPoint;
class bivector;
class line;
class plane;
class pseudoscalar;
class oddVersor;
class evenVersor;
class rotor;
class om;
class grade1OM;
class grade2OM;
class grade3OM;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:e1, e2, e3, e0  (grade 1).
/// group 2:e1^e2, e1^e3, e2^e3, e1^e0, e2^e0, e3^e0  (grade 2).
/// group 3:e1^e2^e3, e1^e2^e0, e1^e3^e0, e2^e3^e0  (grade 3).
/// group 4:e1^e2^e3^e0  (grade 4).
/// 
/// 16 doubles are allocated inside the struct.
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates
	double m_c[16]; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  {set();}

	/// Copy constructor.
	inline mv(const mv&A)  {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  {set(A);}
	/// Converts a e3_t to a mv.
	inline mv(const e3_t&A)  {set(A);}
	/// Converts a e0_t to a mv.
	inline mv(const e0_t&A)  {set(A);}
	/// Converts a I4_t to a mv.
	inline mv(const I4_t&A)  {set(A);}
	/// Converts a I4i_t to a mv.
	inline mv(const I4i_t&A)  {set(A);}
	/// Converts a vector to a mv.
	inline mv(const vector&A)  {set(A);}
	/// Converts a point to a mv.
	inline mv(const point&A)  {set(A);}
	/// Converts a normalizedPoint to a mv.
	inline mv(const normalizedPoint&A)  {set(A);}
	/// Converts a bivector to a mv.
	inline mv(const bivector&A)  {set(A);}
	/// Converts a line to a mv.
	inline mv(const line&A)  {set(A);}
	/// Converts a plane to a mv.
	inline mv(const plane&A)  {set(A);}
	/// Converts a pseudoscalar to a mv.
	inline mv(const pseudoscalar&A)  {set(A);}
	/// Converts a oddVersor to a mv.
	inline mv(const oddVersor&A)  {set(A);}
	/// Converts a evenVersor to a mv.
	inline mv(const evenVersor&A)  {set(A);}
	/// Converts a rotor to a mv.
	inline mv(const rotor&A)  {set(A);}


	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e0_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I4_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I4i_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const point &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const line &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const plane &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pseudoscalar &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const oddVersor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const evenVersor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const rotor &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of e3_t A
	void set(const e3_t &A);
	/// Sets this mv to the value of e0_t A
	void set(const e0_t &A);
	/// Sets this mv to the value of I4_t A
	void set(const I4_t &A);
	/// Sets this mv to the value of I4i_t A
	void set(const I4i_t &A);
	/// Sets this mv to the value of vector A
	void set(const vector &A);
	/// Sets this mv to the value of point A
	void set(const point &A);
	/// Sets this mv to the value of normalizedPoint A
	void set(const normalizedPoint &A);
	/// Sets this mv to the value of bivector A
	void set(const bivector &A);
	/// Sets this mv to the value of line A
	void set(const line &A);
	/// Sets this mv to the value of plane A
	void set(const plane &A);
	/// Sets this mv to the value of pseudoscalar A
	void set(const pseudoscalar &A);
	/// Sets this mv to the value of oddVersor A
	void set(const oddVersor &A);
	/// Sets this mv to the value of evenVersor A
	void set(const evenVersor &A);
	/// Sets this mv to the value of rotor A
	void set(const rotor &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[p3ga_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the e1 coordinate of this mv.
	inline double get_e1() const {
		return (m_gu & 2) ? m_c[p3ga_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the e2 coordinate of this mv.
	inline double get_e2() const {
		return (m_gu & 2) ? m_c[p3ga_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the e3 coordinate of this mv.
	inline double get_e3() const {
		return (m_gu & 2) ? m_c[p3ga_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the e0 coordinate of this mv.
	inline double get_e0() const {
		return (m_gu & 2) ? m_c[p3ga_mvSize[m_gu & 1] + 3] : 0.0;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline double get_e1_e2() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the e1_e3 coordinate of this mv.
	inline double get_e1_e3() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the e2_e3 coordinate of this mv.
	inline double get_e2_e3() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the e1_e0 coordinate of this mv.
	inline double get_e1_e0() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 3] : 0.0;
	}
	/// Returns the e2_e0 coordinate of this mv.
	inline double get_e2_e0() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 4] : 0.0;
	}
	/// Returns the e3_e0 coordinate of this mv.
	inline double get_e3_e0() const {
		return (m_gu & 4) ? m_c[p3ga_mvSize[m_gu & 3] + 5] : 0.0;
	}
	/// Returns the e1_e2_e3 coordinate of this mv.
	inline double get_e1_e2_e3() const {
		return (m_gu & 8) ? m_c[p3ga_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns the e1_e2_e0 coordinate of this mv.
	inline double get_e1_e2_e0() const {
		return (m_gu & 8) ? m_c[p3ga_mvSize[m_gu & 7] + 1] : 0.0;
	}
	/// Returns the e1_e3_e0 coordinate of this mv.
	inline double get_e1_e3_e0() const {
		return (m_gu & 8) ? m_c[p3ga_mvSize[m_gu & 7] + 2] : 0.0;
	}
	/// Returns the e2_e3_e0 coordinate of this mv.
	inline double get_e2_e3_e0() const {
		return (m_gu & 8) ? m_c[p3ga_mvSize[m_gu & 7] + 3] : 0.0;
	}
	/// Returns the e1_e2_e3_e0 coordinate of this mv.
	inline double get_e1_e2_e3_e0() const {
		return (m_gu & 16) ? m_c[p3ga_mvSize[m_gu & 15] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[p3ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(double val)  {
		reserveGroup_1();
		m_c[p3ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(double val)  {
		reserveGroup_1();
		m_c[p3ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e3 coordinate of this mv.
	inline void set_e3(double val)  {
		reserveGroup_1();
		m_c[p3ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the e0 coordinate of this mv.
	inline void set_e0(double val)  {
		reserveGroup_1();
		m_c[p3ga_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the e1_e3 coordinate of this mv.
	inline void set_e1_e3(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e2_e3 coordinate of this mv.
	inline void set_e2_e3(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the e1_e0 coordinate of this mv.
	inline void set_e1_e0(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the e2_e0 coordinate of this mv.
	inline void set_e2_e0(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the e3_e0 coordinate of this mv.
	inline void set_e3_e0(double val)  {
		reserveGroup_2();
		m_c[p3ga_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the e1_e2_e3 coordinate of this mv.
	inline void set_e1_e2_e3(double val)  {
		reserveGroup_3();
		m_c[p3ga_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the e1_e2_e0 coordinate of this mv.
	inline void set_e1_e2_e0(double val)  {
		reserveGroup_3();
		m_c[p3ga_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the e1_e3_e0 coordinate of this mv.
	inline void set_e1_e3_e0(double val)  {
		reserveGroup_3();
		m_c[p3ga_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the e2_e3_e0 coordinate of this mv.
	inline void set_e2_e3_e0(double val)  {
		reserveGroup_3();
		m_c[p3ga_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the e1_e2_e3_e0 coordinate of this mv.
	inline void set_e1_e2_e3_e0(double val)  {
		reserveGroup_4();
		m_c[p3ga_mvSize[m_gu & 15] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[5], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[16]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + p3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + p3ga_mvSize[groupUsageBelow];
			for (int i = p3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + p3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + p3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + p3ga_mvSize[groupUsageBelow];
			for (int i = p3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + p3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + p3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + p3ga_mvSize[groupUsageBelow];
			for (int i = p3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + p3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + p3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + p3ga_mvSize[groupUsageBelow];
			for (int i = p3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + p3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + p3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef double Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef double Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline double get_e2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type e3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e3 = 1
/// 
/// 
class e3_t
{
public:
public:

	/// Floating point type used by e3_t 
	typedef double Float;
	/// Array indices of e3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e3_t with variable coordinates set to 0.
	inline e3_t() {set();}

	/// Copy constructor.
	inline e3_t(const e3_t &A) {set(A);}



	/// Constructs a new e3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e3_t).
	inline e3_t &operator=(const e3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e3 coordinate.
	inline double get_e3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e3_t

/// This class can hold a specialized multivector of type e0_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e0 = 1
/// 
/// 
class e0_t
{
public:
public:

	/// Floating point type used by e0_t 
	typedef double Float;
	/// Array indices of e0_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e0_t with variable coordinates set to 0.
	inline e0_t() {set();}

	/// Copy constructor.
	inline e0_t(const e0_t &A) {set(A);}



	/// Constructs a new e0_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e0_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e0_t).
	inline e0_t &operator=(const e0_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e0_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e0_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e0 coordinate.
	inline double get_e0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e0_t

/// This class can hold a specialized multivector of type I4_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1^e2^e3^e0 = 1
/// 
/// 
class I4_t
{
public:
public:

	/// Floating point type used by I4_t 
	typedef double Float;
	/// Array indices of I4_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I4_t with variable coordinates set to 0.
	inline I4_t() {set();}

	/// Copy constructor.
	inline I4_t(const I4_t &A) {set(A);}



	/// Constructs a new I4_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I4_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I4_t).
	inline I4_t &operator=(const I4_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I4_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I4_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3^e0 coordinate.
	inline double get_e1_e2_e3_e0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I4_t

/// This class can hold a specialized multivector of type I4i_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1^e2^e3^e0 = 1
/// 
/// 
class I4i_t
{
public:
public:

	/// Floating point type used by I4i_t 
	typedef double Float;
	/// Array indices of I4i_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I4i_t with variable coordinates set to 0.
	inline I4i_t() {set();}

	/// Copy constructor.
	inline I4i_t(const I4i_t &A) {set(A);}



	/// Constructs a new I4i_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I4i_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I4i_t).
	inline I4i_t &operator=(const I4i_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I4i_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I4i_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3^e0 coordinate.
	inline double get_e1_e2_e3_e0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I4i_t

/// This class can hold a specialized multivector of type vector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vector
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
public:

	/// Floating point type used by vector 
	typedef double Float;
	/// Array indices of vector coordinates.
	typedef enum {
		/// index of coordinate for e1 in vector
		E1 = 0, 
		/// index of coordinate for e2 in vector
		E2 = 1, 
		/// index of coordinate for e3 in vector
		E3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3
	} CoordinateOrder;

	/// Constructs a new vector with variable coordinates set to 0.
	inline vector() {set();}

	/// Copy constructor.
	inline vector(const vector &A) {set(A);}



	/// Constructs a new vector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vector(mv &A, int filler) {set(A);}

	/// Constructs a new vector. Coordinate values come from 'A'.
	inline vector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new vector with each coordinate specified.
	inline vector(const CoordinateOrder co,  double e1, double e2, double e3) {
		set(co, e1, e2, e3);
	}

	/// Assignment operator (vector).
	inline vector &operator=(const vector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class vector

/// This class can hold a specialized multivector of type point.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate e0  (array index: E0 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class point
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The e0 coordinate.
	double m_e0;
public:

	/// Floating point type used by point 
	typedef double Float;
	/// Array indices of point coordinates.
	typedef enum {
		/// index of coordinate for e1 in point
		E1 = 0, 
		/// index of coordinate for e2 in point
		E2 = 1, 
		/// index of coordinate for e3 in point
		E3 = 2, 
		/// index of coordinate for e0 in point
		E0 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_e0
	} CoordinateOrder;

	/// Constructs a new point with variable coordinates set to 0.
	inline point() {set();}

	/// Copy constructor.
	inline point(const point &A) {set(A);}



	/// Constructs a new point from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline point(mv &A, int filler) {set(A);}

	/// Constructs a new point. Coordinate values come from 'A'.
	inline point(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new point with each coordinate specified.
	inline point(const CoordinateOrder co,  double e1, double e2, double e3, double e0) {
		set(co, e1, e2, e3, e0);
	}

	/// Assignment operator (point).
	inline point &operator=(const point &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline point &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const point &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3, double e0);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the e0 coordinate.
	inline double get_e0() const { return m_e0;}
	/// Sets the e0 coordinate.
	inline void set_e0(double e0) { m_e0 = e0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class point

/// This class can hold a specialized multivector of type normalizedPoint.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
/// 
/// The constant non-zero coordinates are:
///   - e0 = 1
/// 
/// 
class normalizedPoint
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
public:

	/// Floating point type used by normalizedPoint 
	typedef double Float;
	/// Array indices of normalizedPoint coordinates.
	typedef enum {
		/// index of coordinate for e1 in normalizedPoint
		E1 = 0, 
		/// index of coordinate for e2 in normalizedPoint
		E2 = 1, 
		/// index of coordinate for e3 in normalizedPoint
		E3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3
	} CoordinateOrder;

	/// Constructs a new normalizedPoint with variable coordinates set to 0.
	inline normalizedPoint() {set();}

	/// Copy constructor.
	inline normalizedPoint(const normalizedPoint &A) {set(A);}



	/// Constructs a new normalizedPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedPoint(mv &A, int filler) {set(A);}

	/// Constructs a new normalizedPoint. Coordinate values come from 'A'.
	inline normalizedPoint(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new normalizedPoint with each coordinate specified.
	inline normalizedPoint(const CoordinateOrder co,  double e1, double e2, double e3) {
		set(co, e1, e2, e3);
	}

	/// Assignment operator (normalizedPoint).
	inline normalizedPoint &operator=(const normalizedPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline normalizedPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the e0 coordinate.
	inline double get_e0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class normalizedPoint

/// This class can hold a specialized multivector of type bivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2  (array index: E1_E2 = 0)
///   - coordinate e2^e3  (array index: E2_E3 = 1)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivector
{
public:
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by bivector 
	typedef double Float;
	/// Array indices of bivector coordinates.
	typedef enum {
		/// index of coordinate for e1^e2 in bivector
		E1_E2 = 0, 
		/// index of coordinate for e2^e3 in bivector
		E2_E3 = 1, 
		/// index of coordinate for -1*e1^e3 in bivector
		E3_E1 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new bivector with variable coordinates set to 0.
	inline bivector() {set();}

	/// Copy constructor.
	inline bivector(const bivector &A) {set(A);}



	/// Constructs a new bivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivector(mv &A, int filler) {set(A);}

	/// Constructs a new bivector. Coordinate values come from 'A'.
	inline bivector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new bivector with each coordinate specified.
	inline bivector(const CoordinateOrder co,  double e1_e2, double e2_e3, double e3_e1) {
		set(co, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (bivector).
	inline bivector &operator=(const bivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class bivector

/// This class can hold a specialized multivector of type line.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate -1*e1^e0  (array index: E0_E1 = 0)
///   - coordinate -1*e2^e0  (array index: E0_E2 = 1)
///   - coordinate -1*e3^e0  (array index: E0_E3 = 2)
///   - coordinate e1^e2  (array index: E1_E2 = 3)
///   - coordinate e2^e3  (array index: E2_E3 = 4)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 5)
/// 
/// The type has no constant coordinates.
/// 
/// 
class line
{
public:
	/// The -1*e1^e0 coordinate.
	double m_e0_e1;
	/// The -1*e2^e0 coordinate.
	double m_e0_e2;
	/// The -1*e3^e0 coordinate.
	double m_e0_e3;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by line 
	typedef double Float;
	/// Array indices of line coordinates.
	typedef enum {
		/// index of coordinate for -1*e1^e0 in line
		E0_E1 = 0, 
		/// index of coordinate for -1*e2^e0 in line
		E0_E2 = 1, 
		/// index of coordinate for -1*e3^e0 in line
		E0_E3 = 2, 
		/// index of coordinate for e1^e2 in line
		E1_E2 = 3, 
		/// index of coordinate for e2^e3 in line
		E2_E3 = 4, 
		/// index of coordinate for -1*e1^e3 in line
		E3_E1 = 5, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new line with variable coordinates set to 0.
	inline line() {set();}

	/// Copy constructor.
	inline line(const line &A) {set(A);}



	/// Constructs a new line from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline line(mv &A, int filler) {set(A);}

	/// Constructs a new line. Coordinate values come from 'A'.
	inline line(const CoordinateOrder co, const double A[6]) {set(co, A);}
	
	/// Constructs a new line with each coordinate specified.
	inline line(const CoordinateOrder co,  double e0_e1, double e0_e2, double e0_e3, double e1_e2, double e2_e3, double e3_e1) {
		set(co, e0_e1, e0_e2, e0_e3, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (line).
	inline line &operator=(const line &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline line &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const line &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[6]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e0_e1, double e0_e2, double e0_e3, double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the -1*e1^e0 coordinate.
	inline double get_e0_e1() const { return m_e0_e1;}
	/// Sets the -1*e1^e0 coordinate.
	inline void set_e0_e1(double e0_e1) { m_e0_e1 = e0_e1;}
	/// Returns the -1*e2^e0 coordinate.
	inline double get_e0_e2() const { return m_e0_e2;}
	/// Sets the -1*e2^e0 coordinate.
	inline void set_e0_e2(double e0_e2) { m_e0_e2 = e0_e2;}
	/// Returns the -1*e3^e0 coordinate.
	inline double get_e0_e3() const { return m_e0_e3;}
	/// Sets the -1*e3^e0 coordinate.
	inline void set_e0_e3(double e0_e3) { m_e0_e3 = e0_e3;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class line

/// This class can hold a specialized multivector of type plane.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^e0  (array index: E1_E2_E0 = 0)
///   - coordinate e2^e3^e0  (array index: E2_E3_E0 = 1)
///   - coordinate -1*e1^e3^e0  (array index: E3_E1_E0 = 2)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class plane
{
public:
	/// The e1^e2^e0 coordinate.
	double m_e1_e2_e0;
	/// The e2^e3^e0 coordinate.
	double m_e2_e3_e0;
	/// The -1*e1^e3^e0 coordinate.
	double m_e3_e1_e0;
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
public:

	/// Floating point type used by plane 
	typedef double Float;
	/// Array indices of plane coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^e0 in plane
		E1_E2_E0 = 0, 
		/// index of coordinate for e2^e3^e0 in plane
		E2_E3_E0 = 1, 
		/// index of coordinate for -1*e1^e3^e0 in plane
		E3_E1_E0 = 2, 
		/// index of coordinate for e1^e2^e3 in plane
		E1_E2_E3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3
	} CoordinateOrder;

	/// Constructs a new plane with variable coordinates set to 0.
	inline plane() {set();}

	/// Copy constructor.
	inline plane(const plane &A) {set(A);}



	/// Constructs a new plane from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline plane(mv &A, int filler) {set(A);}

	/// Constructs a new plane. Coordinate values come from 'A'.
	inline plane(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new plane with each coordinate specified.
	inline plane(const CoordinateOrder co,  double e1_e2_e0, double e2_e3_e0, double e3_e1_e0, double e1_e2_e3) {
		set(co, e1_e2_e0, e2_e3_e0, e3_e1_e0, e1_e2_e3);
	}

	/// Assignment operator (plane).
	inline plane &operator=(const plane &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline plane &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const plane &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_e0, double e2_e3_e0, double e3_e1_e0, double e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e0 coordinate.
	inline double get_e1_e2_e0() const { return m_e1_e2_e0;}
	/// Sets the e1^e2^e0 coordinate.
	inline void set_e1_e2_e0(double e1_e2_e0) { m_e1_e2_e0 = e1_e2_e0;}
	/// Returns the e2^e3^e0 coordinate.
	inline double get_e2_e3_e0() const { return m_e2_e3_e0;}
	/// Sets the e2^e3^e0 coordinate.
	inline void set_e2_e3_e0(double e2_e3_e0) { m_e2_e3_e0 = e2_e3_e0;}
	/// Returns the -1*e1^e3^e0 coordinate.
	inline double get_e3_e1_e0() const { return m_e3_e1_e0;}
	/// Sets the -1*e1^e3^e0 coordinate.
	inline void set_e3_e1_e0(double e3_e1_e0) { m_e3_e1_e0 = e3_e1_e0;}
	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class plane

/// This class can hold a specialized multivector of type pseudoscalar.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate -1*e1^e2^e3^e0  (array index: E2_E1_E3_E0 = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pseudoscalar
{
public:
	/// The -1*e1^e2^e3^e0 coordinate.
	double m_e2_e1_e3_e0;
public:

	/// Floating point type used by pseudoscalar 
	typedef double Float;
	/// Array indices of pseudoscalar coordinates.
	typedef enum {
		/// index of coordinate for -1*e1^e2^e3^e0 in pseudoscalar
		E2_E1_E3_E0 = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e2e1e3e0
	} CoordinateOrder;

	/// Constructs a new pseudoscalar with variable coordinates set to 0.
	inline pseudoscalar() {set();}

	/// Copy constructor.
	inline pseudoscalar(const pseudoscalar &A) {set(A);}



	/// Constructs a new pseudoscalar from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pseudoscalar(mv &A, int filler) {set(A);}

	/// Constructs a new pseudoscalar. Coordinate values come from 'A'.
	inline pseudoscalar(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new pseudoscalar with each coordinate specified.
	inline pseudoscalar(const CoordinateOrder co,  double e2_e1_e3_e0) {
		set(co, e2_e1_e3_e0);
	}

	/// Assignment operator (pseudoscalar).
	inline pseudoscalar &operator=(const pseudoscalar &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pseudoscalar &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pseudoscalar &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e2_e1_e3_e0);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the -1*e1^e2^e3^e0 coordinate.
	inline double get_e2_e1_e3_e0() const { return m_e2_e1_e3_e0;}
	/// Sets the -1*e1^e2^e3^e0 coordinate.
	inline void set_e2_e1_e3_e0(double e2_e1_e3_e0) { m_e2_e1_e3_e0 = e2_e1_e3_e0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class pseudoscalar

/// This class can hold a specialized multivector of type oddVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate e0  (array index: E0 = 3)
///   - coordinate e1^e2^e0  (array index: E1_E2_E0 = 4)
///   - coordinate e2^e3^e0  (array index: E2_E3_E0 = 5)
///   - coordinate -1*e1^e3^e0  (array index: E3_E1_E0 = 6)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class oddVersor
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The e0 coordinate.
	double m_e0;
	/// The e1^e2^e0 coordinate.
	double m_e1_e2_e0;
	/// The e2^e3^e0 coordinate.
	double m_e2_e3_e0;
	/// The -1*e1^e3^e0 coordinate.
	double m_e3_e1_e0;
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
public:

	/// Floating point type used by oddVersor 
	typedef double Float;
	/// Array indices of oddVersor coordinates.
	typedef enum {
		/// index of coordinate for e1 in oddVersor
		E1 = 0, 
		/// index of coordinate for e2 in oddVersor
		E2 = 1, 
		/// index of coordinate for e3 in oddVersor
		E3 = 2, 
		/// index of coordinate for e0 in oddVersor
		E0 = 3, 
		/// index of coordinate for e1^e2^e0 in oddVersor
		E1_E2_E0 = 4, 
		/// index of coordinate for e2^e3^e0 in oddVersor
		E2_E3_E0 = 5, 
		/// index of coordinate for -1*e1^e3^e0 in oddVersor
		E3_E1_E0 = 6, 
		/// index of coordinate for e1^e2^e3 in oddVersor
		E1_E2_E3 = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3
	} CoordinateOrder;

	/// Constructs a new oddVersor with variable coordinates set to 0.
	inline oddVersor() {set();}

	/// Copy constructor.
	inline oddVersor(const oddVersor &A) {set(A);}



	/// Constructs a new oddVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline oddVersor(mv &A, int filler) {set(A);}

	/// Constructs a new oddVersor. Coordinate values come from 'A'.
	inline oddVersor(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new oddVersor with each coordinate specified.
	inline oddVersor(const CoordinateOrder co,  double e1, double e2, double e3, double e0, double e1_e2_e0, double e2_e3_e0, double e3_e1_e0, double e1_e2_e3) {
		set(co, e1, e2, e3, e0, e1_e2_e0, e2_e3_e0, e3_e1_e0, e1_e2_e3);
	}

	/// Assignment operator (oddVersor).
	inline oddVersor &operator=(const oddVersor &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline oddVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const oddVersor &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3, double e0, double e1_e2_e0, double e2_e3_e0, double e3_e1_e0, double e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the e0 coordinate.
	inline double get_e0() const { return m_e0;}
	/// Sets the e0 coordinate.
	inline void set_e0(double e0) { m_e0 = e0;}
	/// Returns the e1^e2^e0 coordinate.
	inline double get_e1_e2_e0() const { return m_e1_e2_e0;}
	/// Sets the e1^e2^e0 coordinate.
	inline void set_e1_e2_e0(double e1_e2_e0) { m_e1_e2_e0 = e1_e2_e0;}
	/// Returns the e2^e3^e0 coordinate.
	inline double get_e2_e3_e0() const { return m_e2_e3_e0;}
	/// Sets the e2^e3^e0 coordinate.
	inline void set_e2_e3_e0(double e2_e3_e0) { m_e2_e3_e0 = e2_e3_e0;}
	/// Returns the -1*e1^e3^e0 coordinate.
	inline double get_e3_e1_e0() const { return m_e3_e1_e0;}
	/// Sets the -1*e1^e3^e0 coordinate.
	inline void set_e3_e1_e0(double e3_e1_e0) { m_e3_e1_e0 = e3_e1_e0;}
	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class oddVersor

/// This class can hold a specialized multivector of type evenVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate -1*e1^e0  (array index: E0_E1 = 1)
///   - coordinate -1*e2^e0  (array index: E0_E2 = 2)
///   - coordinate -1*e3^e0  (array index: E0_E3 = 3)
///   - coordinate e1^e2  (array index: E1_E2 = 4)
///   - coordinate e2^e3  (array index: E2_E3 = 5)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 6)
///   - coordinate -1*e1^e2^e3^e0  (array index: E2_E1_E3_E0 = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class evenVersor
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The -1*e1^e0 coordinate.
	double m_e0_e1;
	/// The -1*e2^e0 coordinate.
	double m_e0_e2;
	/// The -1*e3^e0 coordinate.
	double m_e0_e3;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
	/// The -1*e1^e2^e3^e0 coordinate.
	double m_e2_e1_e3_e0;
public:

	/// Floating point type used by evenVersor 
	typedef double Float;
	/// Array indices of evenVersor coordinates.
	typedef enum {
		/// index of coordinate for 1 in evenVersor
		SCALAR = 0, 
		/// index of coordinate for -1*e1^e0 in evenVersor
		E0_E1 = 1, 
		/// index of coordinate for -1*e2^e0 in evenVersor
		E0_E2 = 2, 
		/// index of coordinate for -1*e3^e0 in evenVersor
		E0_E3 = 3, 
		/// index of coordinate for e1^e2 in evenVersor
		E1_E2 = 4, 
		/// index of coordinate for e2^e3 in evenVersor
		E2_E3 = 5, 
		/// index of coordinate for -1*e1^e3 in evenVersor
		E3_E1 = 6, 
		/// index of coordinate for -1*e1^e2^e3^e0 in evenVersor
		E2_E1_E3_E0 = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0
	} CoordinateOrder;

	/// Constructs a new evenVersor with variable coordinates set to 0.
	inline evenVersor() {set();}

	/// Copy constructor.
	inline evenVersor(const evenVersor &A) {set(A);}


	/// Constructs a new evenVersor with scalar value 'scalar'.
	inline evenVersor(double scalar) {set(scalar);}

	/// Constructs a new evenVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline evenVersor(mv &A, int filler) {set(A);}

	/// Constructs a new evenVersor. Coordinate values come from 'A'.
	inline evenVersor(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new evenVersor with each coordinate specified.
	inline evenVersor(const CoordinateOrder co,  double scalar, double e0_e1, double e0_e2, double e0_e3, double e1_e2, double e2_e3, double e3_e1, double e2_e1_e3_e0) {
		set(co, scalar, e0_e1, e0_e2, e0_e3, e1_e2, e2_e3, e3_e1, e2_e1_e3_e0);
	}

	/// Assignment operator (evenVersor).
	inline evenVersor &operator=(const evenVersor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline evenVersor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline evenVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const evenVersor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e0_e1, double e0_e2, double e0_e3, double e1_e2, double e2_e3, double e3_e1, double e2_e1_e3_e0);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the -1*e1^e0 coordinate.
	inline double get_e0_e1() const { return m_e0_e1;}
	/// Sets the -1*e1^e0 coordinate.
	inline void set_e0_e1(double e0_e1) { m_e0_e1 = e0_e1;}
	/// Returns the -1*e2^e0 coordinate.
	inline double get_e0_e2() const { return m_e0_e2;}
	/// Sets the -1*e2^e0 coordinate.
	inline void set_e0_e2(double e0_e2) { m_e0_e2 = e0_e2;}
	/// Returns the -1*e3^e0 coordinate.
	inline double get_e0_e3() const { return m_e0_e3;}
	/// Sets the -1*e3^e0 coordinate.
	inline void set_e0_e3(double e0_e3) { m_e0_e3 = e0_e3;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the -1*e1^e2^e3^e0 coordinate.
	inline double get_e2_e1_e3_e0() const { return m_e2_e1_e3_e0;}
	/// Sets the -1*e1^e2^e3^e0 coordinate.
	inline void set_e2_e1_e3_e0(double e2_e1_e3_e0) { m_e2_e1_e3_e0 = e2_e1_e3_e0;}
}; // end of class evenVersor

/// This class can hold a specialized multivector of type rotor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^e2  (array index: E1_E2 = 1)
///   - coordinate e2^e3  (array index: E2_E3 = 2)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class rotor
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by rotor 
	typedef double Float;
	/// Array indices of rotor coordinates.
	typedef enum {
		/// index of coordinate for 1 in rotor
		SCALAR = 0, 
		/// index of coordinate for e1^e2 in rotor
		E1_E2 = 1, 
		/// index of coordinate for e2^e3 in rotor
		E2_E3 = 2, 
		/// index of coordinate for -1*e1^e3 in rotor
		E3_E1 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new rotor with variable coordinates set to 0.
	inline rotor() {set();}

	/// Copy constructor.
	inline rotor(const rotor &A) {set(A);}


	/// Constructs a new rotor with scalar value 'scalar'.
	inline rotor(double scalar) {set(scalar);}

	/// Constructs a new rotor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline rotor(mv &A, int filler) {set(A);}

	/// Constructs a new rotor. Coordinate values come from 'A'.
	inline rotor(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new rotor with each coordinate specified.
	inline rotor(const CoordinateOrder co,  double scalar, double e1_e2, double e2_e3, double e3_e1) {
		set(co, scalar, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (rotor).
	inline rotor &operator=(const rotor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline rotor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline rotor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const rotor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::p3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::p3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
}; // end of class rotor

/// This class can hold a general outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2, e3, e0.
/// Domain grade 2: e1^e2, e1^e3, e2^e3, e1^e0, e2^e0, e3^e0.
/// Domain grade 3: e1^e2^e3, e1^e2^e0, e1^e3^e0, e2^e3^e0.
/// Domain grade 4: e1^e2^e3^e0.
/// 
/// The range and domain are equal.
/// 
class om
{
public:
	/// Matrix for grade 1; the size is 4 x 4
	double m_m1[16];
	/// Matrix for grade 2; the size is 6 x 6
	double m_m2[36];
	/// Matrix for grade 3; the size is 4 x 4
	double m_m3[16];
	/// Matrix for grade 4; the size is 1 x 1
	double m_m4[1];
public:

	/// Floating point type used by om 
	typedef double Float;

	/// Constructs a new om, set to identity
	inline om() { setIdentity(); }

	/// Copy constructor.
	inline om(const om&M) { set(M); }

	/// Constructor from matrix
	inline om(const double *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline om(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
		{ set(ie1, ie2, ie3, ie0); }

	/// Converts a grade1OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM &M) { set(M); }
	
	/// Converts a grade2OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade2OM &M) { set(M); }
	
	/// Converts a grade3OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade3OM &M) { set(M); }
	

	/// Sets this to 'M'
	inline om &operator=(const om &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM &M) { set(M); return *this; }
	
	/// Sets this om to grade2OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade2OM &M) { set(M); return *this; }
	
	/// Sets this om to grade3OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade3OM &M) { set(M); return *this; }
	

	/// Sets this om to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const om &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const point &ie1, const point &ie2, const point &ie3, const point &ie0);

	/// Sets this om to a grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM &M);
	
	/// Sets this om to a grade2OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade2OM &M);
	
	/// Sets this om to a grade3OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade3OM &M);
	
	private:
	void set_0();
	void set_1();
	void set_2();
	void set_3();
	void set_grade_2_0();
	void set_grade_2_1();
	void set_grade_2_2();
	void set_grade_2_3();
	void set_grade_2_4();
	void set_grade_2_5();
	void set_grade_3_0();
	void set_grade_3_1();
	void set_grade_3_2();
	void set_grade_3_3();
	void set_grade_4_0();
	public:
}; // end of om

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2, e3, e0.
/// Domain grade 2: .
/// Domain grade 3: .
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class grade1OM
{
public:
	/// Matrix for grade 1; the size is 4 x 4
	double m_m1[16];
public:

	/// Floating point type used by grade1OM 
	typedef double Float;

	/// Constructs a new grade1OM, set to identity
	inline grade1OM() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM(const grade1OM&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
		{ set(ie1, ie2, ie3, ie0); }

	/// Converts a om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM &operator=(const grade1OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const point &ie1, const point &ie2, const point &ie3, const point &ie0);

	/// Sets this grade1OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: -1*e1^e0, -1*e2^e0, -1*e3^e0, e1^e2, e2^e3, -1*e1^e3.
/// Domain grade 3: .
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class grade2OM
{
public:
	/// Matrix for grade 2; the size is 6 x 6
	double m_m2[36];
public:

	/// Floating point type used by grade2OM 
	typedef double Float;

	/// Constructs a new grade2OM, set to identity
	inline grade2OM() { setIdentity(); }

	/// Copy constructor.
	inline grade2OM(const grade2OM&M) { set(M); }

	/// Constructor from matrix
	inline grade2OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade2OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade2OM(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
		{ set(ie1, ie2, ie3, ie0); }

	/// Converts a om to a grade2OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade2OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade2OM &operator=(const grade2OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade2OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade2OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade2OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade2OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const point &ie1, const point &ie2, const point &ie3, const point &ie0);

	/// Sets this grade2OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade2OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: .
/// Domain grade 3: e1^e2^e0, e2^e3^e0, -1*e1^e3^e0, e1^e2^e3.
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class grade3OM
{
public:
	/// Matrix for grade 3; the size is 4 x 4
	double m_m3[16];
public:

	/// Floating point type used by grade3OM 
	typedef double Float;

	/// Constructs a new grade3OM, set to identity
	inline grade3OM() { setIdentity(); }

	/// Copy constructor.
	inline grade3OM(const grade3OM&M) { set(M); }

	/// Constructor from matrix
	inline grade3OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade3OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade3OM(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
		{ set(ie1, ie2, ie3, ie0); }

	/// Converts a om to a grade3OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade3OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade3OM &operator=(const grade3OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade3OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade3OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade3OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade3OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const point &ie1, const point &ie2, const point &ie3, const point &ie0);

	/// Sets this grade3OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade3OM
extern e1_t e1;
extern e2_t e2;
extern e3_t e3;
extern e0_t e0;
extern I4_t I4;
extern I4i_t I4i;
extern vector vectorE1;
extern vector vectorE2;
extern vector vectorE3;
extern point pointAtOrigin;
extern bivector someBivectorConstant;
/** rotor which rotates by 90 degrees in e1^e2 plane. */
extern rotor rotor90;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 31);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  e1_t
double _double(const e1_t &x);
/// Returns scalar part of  e1_t
inline double _Float(const e1_t &x) {return _double(x); };
/// Returns scalar part of  e2_t
double _double(const e2_t &x);
/// Returns scalar part of  e2_t
inline double _Float(const e2_t &x) {return _double(x); };
/// Returns scalar part of  e3_t
double _double(const e3_t &x);
/// Returns scalar part of  e3_t
inline double _Float(const e3_t &x) {return _double(x); };
/// Returns scalar part of  e0_t
double _double(const e0_t &x);
/// Returns scalar part of  e0_t
inline double _Float(const e0_t &x) {return _double(x); };
/// Returns scalar part of  I4_t
double _double(const I4_t &x);
/// Returns scalar part of  I4_t
inline double _Float(const I4_t &x) {return _double(x); };
/// Returns scalar part of  I4i_t
double _double(const I4i_t &x);
/// Returns scalar part of  I4i_t
inline double _Float(const I4i_t &x) {return _double(x); };
/// Returns scalar part of  vector
double _double(const vector &x);
/// Returns scalar part of  vector
inline double _Float(const vector &x) {return _double(x); };
/// Returns scalar part of  point
double _double(const point &x);
/// Returns scalar part of  point
inline double _Float(const point &x) {return _double(x); };
/// Returns scalar part of  normalizedPoint
double _double(const normalizedPoint &x);
/// Returns scalar part of  normalizedPoint
inline double _Float(const normalizedPoint &x) {return _double(x); };
/// Returns scalar part of  bivector
double _double(const bivector &x);
/// Returns scalar part of  bivector
inline double _Float(const bivector &x) {return _double(x); };
/// Returns scalar part of  line
double _double(const line &x);
/// Returns scalar part of  line
inline double _Float(const line &x) {return _double(x); };
/// Returns scalar part of  plane
double _double(const plane &x);
/// Returns scalar part of  plane
inline double _Float(const plane &x) {return _double(x); };
/// Returns scalar part of  pseudoscalar
double _double(const pseudoscalar &x);
/// Returns scalar part of  pseudoscalar
inline double _Float(const pseudoscalar &x) {return _double(x); };
/// Returns scalar part of  oddVersor
double _double(const oddVersor &x);
/// Returns scalar part of  oddVersor
inline double _Float(const oddVersor &x) {return _double(x); };
/// Returns scalar part of  evenVersor
double _double(const evenVersor &x);
/// Returns scalar part of  evenVersor
inline double _Float(const evenVersor &x) {return _double(x); };
/// Returns scalar part of  rotor
double _double(const rotor &x);
/// Returns scalar part of  rotor
inline double _Float(const rotor &x) {return _double(x); };
/** Converts normalizedPoint to vector: dst = P.
Extracts the vector part of a normalized point */
vector _vector(const normalizedPoint &P);
/** Converts point to vector: dst = P.
Extracts the vector part of a point */
vector _vector(const point &P);
/** Converts rotor to bivector: dst = R.
Extracts the bivector part of a rotor */
bivector _bivector(const rotor &R);
/** Converts oddVersor to line: dst = V.
Extracts the trivector (line) part of an oddVersor */
line _line(const oddVersor &V);
/** Converts oddVersor to vector: dst = V.
Extracts the vector part of an oddVersor */
vector _vector(const oddVersor &V);
/** Converts line to bivector: dst = V.
Extracts the Euclidean bivector part of a line */
bivector _bivector(const line &V);
/// Generates a random double in [0.0 1.0) interval using the c library rand() function
double genrand();
/// Seeds the random number generator for  double
void genrand_seed(unsigned int seed);
/// Seeds the random number generator for  double with the current time
void genrand_timeSeed();
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns vector + vector.
vector add(const vector &a, const vector &b);
/// Returns bivector + bivector.
bivector add(const bivector &a, const bivector &b);
/// Returns plane + plane.
plane add(const plane &a, const plane &b);
/// Returns line + line.
line add(const line &a, const line &b);
/// Returns normalizedPoint + normalizedPoint.
point add(const normalizedPoint &a, const normalizedPoint &b);
/// Returns e1_t + e2_t.
vector add(const e1_t &a, const e2_t &b);
/// Returns I4_t + bivector.
evenVersor add(const I4_t &a, const bivector &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns vector - vector.
vector subtract(const vector &a, const vector &b);
/// Returns bivector - bivector.
bivector subtract(const bivector &a, const bivector &b);
/// Returns plane - plane.
plane subtract(const plane &a, const plane &b);
/// Returns line - line.
line subtract(const line &a, const line &b);
/// Returns normalizedPoint - normalizedPoint.
vector subtract(const normalizedPoint &a, const normalizedPoint &b);
/// Returns I4_t - bivector.
evenVersor subtract(const I4_t &a, const bivector &b);
/// Returns a * b * inverse(a) using default metric.
mv applyVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyUnitVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyVersorWI(const mv &a, const mv &b, const mv &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyUnitVersor(const rotor &a, const vector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const rotor &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const rotor &a, const point &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivector applyUnitVersor(const rotor &a, const bivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const rotor &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyUnitVersor(const rotor &a, const plane &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyUnitVersor(const rotor &a, const e1_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyUnitVersor(const rotor &a, const I4_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const evenVersor &a, const vector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const evenVersor &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const evenVersor &a, const point &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const evenVersor &a, const bivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const evenVersor &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyUnitVersor(const evenVersor &a, const plane &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const evenVersor &a, const e3_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyUnitVersor(const evenVersor &a, const I4i_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const oddVersor &a, const vector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const oddVersor &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyUnitVersor(const oddVersor &a, const point &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const oddVersor &a, const bivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const oddVersor &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyUnitVersor(const oddVersor &a, const plane &b);
/// Returns a * b * inverse(a) using default metric.
vector applyVersor(const rotor &a, const vector &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const rotor &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const rotor &a, const point &b);
/// Returns a * b * inverse(a) using default metric.
bivector applyVersor(const rotor &a, const bivector &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const rotor &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
plane applyVersor(const rotor &a, const plane &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const evenVersor &a, const vector &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const evenVersor &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const evenVersor &a, const point &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const evenVersor &a, const bivector &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const evenVersor &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
plane applyVersor(const evenVersor &a, const plane &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const oddVersor &a, const vector &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const oddVersor &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
point applyVersor(const oddVersor &a, const point &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const oddVersor &a, const bivector &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const oddVersor &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
plane applyVersor(const oddVersor &a, const plane &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyVersorWI(const rotor &a, const vector &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const rotor &a, const normalizedPoint &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const rotor &a, const point &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivector applyVersorWI(const rotor &a, const bivector &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const rotor &a, const line &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyVersorWI(const rotor &a, const plane &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyVersorWI(const rotor &a, const e2_t &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyVersorWI(const rotor &a, const I4_t &b, const rotor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const evenVersor &a, const vector &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const evenVersor &a, const normalizedPoint &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const evenVersor &a, const point &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const evenVersor &a, const bivector &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const evenVersor &a, const line &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyVersorWI(const evenVersor &a, const plane &b, const evenVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const oddVersor &a, const vector &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const oddVersor &a, const normalizedPoint &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const oddVersor &a, const point &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const oddVersor &a, const bivector &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const oddVersor &a, const line &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyVersorWI(const oddVersor &a, const plane &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const oddVersor &a, const e1_t &b, const oddVersor &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
point applyVersorWI(const oddVersor &a, const e2_t &b, const oddVersor &c);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns a / b
vector div(const vector &a, const double b);
/// Returns a / b
point div(const normalizedPoint &a, const double b);
/// Returns a / b
bivector div(const bivector &a, const double b);
/// Returns a / b
line div(const line &a, const double b);
/// Returns a / b
plane div(const plane &a, const double b);
/// Returns a / b
pseudoscalar div(const pseudoscalar &a, const double b);
/// Returns a / b
rotor div(const rotor &a, const double b);
/// Returns a / b
evenVersor div(const evenVersor &a, const double b);
/// Returns a / b
oddVersor div(const oddVersor &a, const double b);
/// Returns a / b
vector div(const e1_t &a, const double b);
/// Returns a / b
pseudoscalar div(const I4_t &a, const double b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);
/// Returns dual of double using default metric.
pseudoscalar dual(const double a);
/// Returns undual of double using default metric.
pseudoscalar undual(const double a);
/// Returns dual of vector using default metric.
plane dual(const vector &a);
/// Returns undual of vector using default metric.
plane undual(const vector &a);
/// Returns dual of normalizedPoint using default metric.
plane dual(const normalizedPoint &a);
/// Returns undual of normalizedPoint using default metric.
plane undual(const normalizedPoint &a);
/// Returns dual of bivector using default metric.
line dual(const bivector &a);
/// Returns undual of bivector using default metric.
line undual(const bivector &a);
/// Returns dual of rotor using default metric.
evenVersor dual(const rotor &a);
/// Returns undual of rotor using default metric.
evenVersor undual(const rotor &a);
/// Returns dual of oddVersor using default metric.
oddVersor dual(const oddVersor &a);
/// Returns undual of oddVersor using default metric.
oddVersor undual(const oddVersor &a);
/// Returns dual of evenVersor using default metric.
evenVersor dual(const evenVersor &a);
/// Returns undual of evenVersor using default metric.
evenVersor undual(const evenVersor &a);
/// Returns dual of line using default metric.
line dual(const line &a);
/// Returns undual of line using default metric.
line undual(const line &a);
/// Returns dual of plane using default metric.
point dual(const plane &a);
/// Returns undual of plane using default metric.
point undual(const plane &a);
/// Returns dual of pseudoscalar using default metric.
double dual(const pseudoscalar &a);
/// Returns undual of pseudoscalar using default metric.
double undual(const pseudoscalar &a);
/// Returns dual of e1_t using default metric.
plane dual(const e1_t &a);
/// Returns undual of e3_t using default metric.
plane undual(const e3_t &a);
/// Returns dual of I4_t using default metric.
double dual(const I4_t &a);
/// Returns undual of I4i_t using default metric.
double undual(const I4i_t &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const vector &a, const vector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivector &a, const bivector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotor &a, const rotor &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivector &a, const rotor &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotor &a, const bivector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotor &a, const line &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const oddVersor &a, const plane &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const line &a, const line &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const plane &a, const plane &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const normalizedPoint &a, const normalizedPoint &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const e1_t &a, const e1_t &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const e1_t &a, const e2_t &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const I4_t &a, const I4i_t &b, const double c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 0 of  rotor.
double extractGrade0(const rotor &a);
/// Returns grade 2 of  rotor.
bivector extractGrade2(const rotor &a);
/// Returns grade 0 of  oddVersor.
double extractGrade0(const oddVersor &a);
/// Returns grade 1 of  oddVersor.
point extractGrade1(const oddVersor &a);
/// Returns grade 2 of  oddVersor.
double extractGrade2(const oddVersor &a);
/// Returns grade 3 of  oddVersor.
plane extractGrade3(const oddVersor &a);
/// Returns grade 0 of  evenVersor.
double extractGrade0(const evenVersor &a);
/// Returns grade 1 of  evenVersor.
double extractGrade1(const evenVersor &a);
/// Returns grade 2 of  evenVersor.
line extractGrade2(const evenVersor &a);
/// Returns grade 3 of  evenVersor.
double extractGrade3(const evenVersor &a);
/// Returns grade 4 of  evenVersor.
pseudoscalar extractGrade4(const evenVersor &a);
/// Returns grade 0 of  normalizedPoint.
double extractGrade0(const normalizedPoint &a);
/// Returns grade 1 of  normalizedPoint.
normalizedPoint extractGrade1(const normalizedPoint &a);
/// Returns grade 2 of  normalizedPoint.
double extractGrade2(const normalizedPoint &a);
/// Returns grade 3 of  normalizedPoint.
double extractGrade3(const normalizedPoint &a);
/// Returns grade 4 of  normalizedPoint.
double extractGrade4(const normalizedPoint &a);
/// Returns grade 0 of  e1_t.
double extractGrade0(const e1_t &a);
/// Returns grade 1 of  e2_t.
e2_t extractGrade1(const e2_t &a);
/// Returns grade 2 of  e3_t.
double extractGrade2(const e3_t &a);
/// Returns grade 3 of  e0_t.
double extractGrade3(const e0_t &a);
/// Returns grade 4 of  e1_t.
double extractGrade4(const e1_t &a);
/// Returns grade 0 of  I4_t.
double extractGrade0(const I4_t &a);
/// Returns grade 1 of  I4i_t.
double extractGrade1(const I4i_t &a);
/// Returns grade 2 of  I4_t.
double extractGrade2(const I4_t &a);
/// Returns grade 3 of  I4i_t.
double extractGrade3(const I4i_t &a);
/// Returns grade 4 of  I4_t.
I4_t extractGrade4(const I4_t &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of vector and vector.
rotor gp(const vector &a, const vector &b);
/// Returns geometric product of rotor and vector.
oddVersor gp(const rotor &a, const vector &b);
/// Returns geometric product of vector and line.
oddVersor gp(const vector &a, const line &b);
/// Returns geometric product of rotor and line.
evenVersor gp(const rotor &a, const line &b);
/// Returns geometric product of vector and rotor.
oddVersor gp(const vector &a, const rotor &b);
/// Returns geometric product of rotor and rotor.
rotor gp(const rotor &a, const rotor &b);
/// Returns geometric product of plane and rotor.
oddVersor gp(const plane &a, const rotor &b);
/// Returns geometric product of plane and line.
oddVersor gp(const plane &a, const line &b);
/// Returns geometric product of bivector and bivector.
rotor gp(const bivector &a, const bivector &b);
/// Returns geometric product of point and point.
evenVersor gp(const point &a, const point &b);
/// Returns geometric product of normalizedPoint and normalizedPoint.
evenVersor gp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns geometric product of pseudoscalar and oddVersor.
oddVersor gp(const pseudoscalar &a, const oddVersor &b);
/// Returns geometric product of e1_t and e2_t.
bivector gp(const e1_t &a, const e2_t &b);
/// Returns geometric product of e3_t and e0_t.
line gp(const e3_t &a, const e0_t &b);
/// Returns geometric product of e3_t and I4i_t.
plane gp(const e3_t &a, const I4i_t &b);
/// Returns geometric product of mv and mv.
mv gp_null(const mv &a, const mv &b);
/// Returns geometric product of vector and vector.
rotor gp_null(const vector &a, const vector &b);
/// Returns geometric product of rotor and vector.
oddVersor gp_null(const rotor &a, const vector &b);
/// Returns geometric product of vector and line.
oddVersor gp_null(const vector &a, const line &b);
/// Returns geometric product of rotor and line.
evenVersor gp_null(const rotor &a, const line &b);
/// Returns geometric product of vector and rotor.
oddVersor gp_null(const vector &a, const rotor &b);
/// Returns geometric product of rotor and rotor.
rotor gp_null(const rotor &a, const rotor &b);
/// Returns geometric product of plane and rotor.
oddVersor gp_null(const plane &a, const rotor &b);
/// Returns geometric product of plane and line.
oddVersor gp_null(const plane &a, const line &b);
/// Returns geometric product of bivector and bivector.
rotor gp_null(const bivector &a, const bivector &b);
/// Returns geometric product of pseudoscalar and oddVersor.
oddVersor gp_null(const pseudoscalar &a, const oddVersor &b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const mv &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const rotor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const oddVersor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const evenVersor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const vector &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const bivector &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const pseudoscalar &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const line &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const plane &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e1_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e2_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const I4_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const I4i_t &a, const double b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv hp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and vector.
vector hp(const vector &a, const vector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and bivector.
bivector hp(const bivector &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and rotor.
rotor hp(const rotor &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of oddVersor and oddVersor.
oddVersor hp(const oddVersor &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and oddVersor.
vector hp(const vector &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and evenVersor.
evenVersor hp(const evenVersor &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and rotor.
bivector hp(const bivector &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and evenVersor.
pseudoscalar hp(const pseudoscalar &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and oddVersor.
double hp(const pseudoscalar &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and bivector.
bivector hp(const rotor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and bivector.
bivector hp(const evenVersor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of point and point.
point hp(const point &a, const point &b);
/// Returns Hadamard product (coordinate-wise multiplication) of normalizedPoint and normalizedPoint.
normalizedPoint hp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and e1_t.
vector hp(const vector &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of I4_t and pseudoscalar.
pseudoscalar hp(const I4_t &a, const pseudoscalar &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and I4i_t.
pseudoscalar hp(const pseudoscalar &a, const I4i_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv ihp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and vector.
vector ihp(const vector &a, const vector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and bivector.
bivector ihp(const bivector &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and rotor.
rotor ihp(const rotor &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of oddVersor and oddVersor.
oddVersor ihp(const oddVersor &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and oddVersor.
vector ihp(const vector &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and evenVersor.
evenVersor ihp(const evenVersor &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and rotor.
bivector ihp(const bivector &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and evenVersor.
pseudoscalar ihp(const pseudoscalar &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and oddVersor.
double ihp(const pseudoscalar &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and bivector.
bivector ihp(const rotor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and bivector.
bivector ihp(const evenVersor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of point and point.
point ihp(const point &a, const point &b);
/// Returns Hadamard product (coordinate-wise multiplication) of normalizedPoint and normalizedPoint.
normalizedPoint ihp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and e1_t.
vector ihp(const vector &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of I4_t and pseudoscalar.
pseudoscalar ihp(const I4_t &a, const pseudoscalar &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and I4i_t.
pseudoscalar ihp(const pseudoscalar &a, const I4i_t &b);
/// Returns (a + 1).
mv increment(const mv &a);
/// Returns (a + 1).
rotor increment(const bivector &a);
/// Returns (a + 1).
rotor increment(const rotor &a);
/// Returns (a + 1).
evenVersor increment(const evenVersor &a);
/// Returns (a + 1).
evenVersor increment(const pseudoscalar &a);
/// Returns (a + 1).
evenVersor increment(const I4_t &a);
/// Returns (a - 1).
mv decrement(const mv &a);
/// Returns (a - 1).
rotor decrement(const bivector &a);
/// Returns (a - 1).
rotor decrement(const rotor &a);
/// Returns (a - 1).
evenVersor decrement(const evenVersor &a);
/// Returns (a - 1).
evenVersor decrement(const pseudoscalar &a);
/// Returns (a - 1).
evenVersor decrement(const I4i_t &a);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns Hestenes inner product of mv and mv.
mv hip(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns scalar product of vector and vector.
double sp(const vector &a, const vector &b);
/// Returns left contraction of vector and plane.
line lc(const vector &a, const plane &b);
/// Returns right contraction of vector and line.
double rc(const vector &a, const line &b);
/// Returns Hestenes inner product of vector and vector.
double hip(const vector &a, const vector &b);
/// Returns Modified Hestenes inner product of pseudoscalar and vector.
plane mhip(const pseudoscalar &a, const vector &b);
/// Returns scalar product of bivector and oddVersor.
double sp(const bivector &a, const oddVersor &b);
/// Returns left contraction of bivector and vector.
double lc(const bivector &a, const vector &b);
/// Returns right contraction of evenVersor and vector.
oddVersor rc(const evenVersor &a, const vector &b);
/// Returns Hestenes inner product of oddVersor and vector.
evenVersor hip(const oddVersor &a, const vector &b);
/// Returns Modified Hestenes inner product of bivector and vector.
vector mhip(const bivector &a, const vector &b);
/// Returns scalar product of vector and pseudoscalar.
double sp(const vector &a, const pseudoscalar &b);
/// Returns left contraction of vector and evenVersor.
oddVersor lc(const vector &a, const evenVersor &b);
/// Returns right contraction of vector and bivector.
double rc(const vector &a, const bivector &b);
/// Returns Hestenes inner product of vector and plane.
line hip(const vector &a, const plane &b);
/// Returns Modified Hestenes inner product of vector and line.
point mhip(const vector &a, const line &b);
/// Returns scalar product of evenVersor and rotor.
double sp(const evenVersor &a, const rotor &b);
/// Returns left contraction of evenVersor and rotor.
rotor lc(const evenVersor &a, const rotor &b);
/// Returns right contraction of oddVersor and rotor.
oddVersor rc(const oddVersor &a, const rotor &b);
/// Returns Hestenes inner product of oddVersor and rotor.
point hip(const oddVersor &a, const rotor &b);
/// Returns Modified Hestenes inner product of oddVersor and rotor.
oddVersor mhip(const oddVersor &a, const rotor &b);
/// Returns scalar product of e1_t and rotor.
double sp(const e1_t &a, const rotor &b);
/// Returns left contraction of e2_t and rotor.
vector lc(const e2_t &a, const rotor &b);
/// Returns right contraction of I4_t and rotor.
evenVersor rc(const I4_t &a, const rotor &b);
/// Returns Hestenes inner product of I4i_t and rotor.
line hip(const I4i_t &a, const rotor &b);
/// Returns Modified Hestenes inner product of e0_t and rotor.
point mhip(const e0_t &a, const rotor &b);
/// Returns scalar product of e1_t and e1_t.
double sp(const e1_t &a, const e1_t &b);
/// Returns left contraction of e2_t and e3_t.
double lc(const e2_t &a, const e3_t &b);
/// Returns right contraction of I4_t and I4i_t.
double rc(const I4_t &a, const I4i_t &b);
/// Returns Hestenes inner product of I4i_t and e0_t.
plane hip(const I4i_t &a, const e0_t &b);
/// Returns Modified Hestenes inner product of e0_t and e1_t.
double mhip(const e0_t &a, const e1_t &b);
/// Returns scalar product of rotor and plane.
double sp(const rotor &a, const plane &b);
/// Returns left contraction of rotor and line.
evenVersor lc(const rotor &a, const line &b);
/// Returns right contraction of rotor and evenVersor.
rotor rc(const rotor &a, const evenVersor &b);
/// Returns Hestenes inner product of rotor and bivector.
double hip(const rotor &a, const bivector &b);
/// Returns Modified Hestenes inner product of rotor and pseudoscalar.
evenVersor mhip(const rotor &a, const pseudoscalar &b);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm of vector using default metric.
double norm(const vector &a);
/// internal conversion function
double norm_returns_scalar(const vector &a);
/// Returns norm of bivector using default metric.
double norm(const bivector &a);
/// internal conversion function
double norm_returns_scalar(const bivector &a);
/// Returns norm of line using default metric.
double norm(const line &a);
/// internal conversion function
double norm_returns_scalar(const line &a);
/// Returns norm of plane using default metric.
double norm(const plane &a);
/// internal conversion function
double norm_returns_scalar(const plane &a);
/// Returns norm of rotor using default metric.
double norm(const rotor &a);
/// internal conversion function
double norm_returns_scalar(const rotor &a);
/// Returns norm of oddVersor using default metric.
double norm(const oddVersor &a);
/// internal conversion function
double norm_returns_scalar(const oddVersor &a);
/// Returns norm of evenVersor using default metric.
double norm(const evenVersor &a);
/// internal conversion function
double norm_returns_scalar(const evenVersor &a);
/// Returns norm of normalizedPoint using default metric.
double norm(const normalizedPoint &a);
/// internal conversion function
double norm_returns_scalar(const normalizedPoint &a);
/// Returns norm of point using default metric.
double norm(const point &a);
/// internal conversion function
double norm_returns_scalar(const point &a);
/// Returns norm of pseudoscalar using default metric.
double norm(const pseudoscalar &a);
/// internal conversion function
double norm_returns_scalar(const pseudoscalar &a);
/// Returns norm of e1_t using default metric.
double norm(const e1_t &a);
/// internal conversion function
double norm_returns_scalar(const e1_t &a);
/// Returns norm of e2_t using default metric.
double norm(const e2_t &a);
/// internal conversion function
double norm_returns_scalar(const e2_t &a);
/// Returns norm of I4i_t using default metric.
double norm(const I4i_t &a);
/// internal conversion function
double norm_returns_scalar(const I4i_t &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns norm2 of vector using default metric.
double norm2(const vector &a);
/// internal conversion function
double norm2_returns_scalar(const vector &a);
/// Returns norm2 of bivector using default metric.
double norm2(const bivector &a);
/// internal conversion function
double norm2_returns_scalar(const bivector &a);
/// Returns norm2 of normalizedPoint using default metric.
double norm2(const normalizedPoint &a);
/// internal conversion function
double norm2_returns_scalar(const normalizedPoint &a);
/// Returns norm2 of point using default metric.
double norm2(const point &a);
/// internal conversion function
double norm2_returns_scalar(const point &a);
/// Returns norm2 of line using default metric.
double norm2(const line &a);
/// internal conversion function
double norm2_returns_scalar(const line &a);
/// Returns norm2 of plane using default metric.
double norm2(const plane &a);
/// internal conversion function
double norm2_returns_scalar(const plane &a);
/// Returns norm2 of rotor using default metric.
double norm2(const rotor &a);
/// internal conversion function
double norm2_returns_scalar(const rotor &a);
/// Returns norm2 of oddVersor using default metric.
double norm2(const oddVersor &a);
/// internal conversion function
double norm2_returns_scalar(const oddVersor &a);
/// Returns norm2 of evenVersor using default metric.
double norm2(const evenVersor &a);
/// internal conversion function
double norm2_returns_scalar(const evenVersor &a);
/// Returns norm2 of pseudoscalar using default metric.
double norm2(const pseudoscalar &a);
/// internal conversion function
double norm2_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of e3_t using default metric.
double norm2(const e3_t &a);
/// internal conversion function
double norm2_returns_scalar(const e3_t &a);
/// Returns norm2 of e0_t using default metric.
double norm2(const e0_t &a);
/// internal conversion function
double norm2_returns_scalar(const e0_t &a);
/// Returns norm2 of I4_t using default metric.
double norm2(const I4_t &a);
/// internal conversion function
double norm2_returns_scalar(const I4_t &a);
/// Returns norm of mv using null metric.
double norm_null(const mv &a);
/// internal conversion function
double norm_null_returns_scalar(const mv &a);
/// Returns norm of vector using null metric.
double norm_null(const vector &a);
/// internal conversion function
double norm_null_returns_scalar(const vector &a);
/// Returns norm of bivector using null metric.
double norm_null(const bivector &a);
/// internal conversion function
double norm_null_returns_scalar(const bivector &a);
/// Returns norm of line using null metric.
double norm_null(const line &a);
/// internal conversion function
double norm_null_returns_scalar(const line &a);
/// Returns norm of plane using null metric.
double norm_null(const plane &a);
/// internal conversion function
double norm_null_returns_scalar(const plane &a);
/// Returns norm of rotor using null metric.
double norm_null(const rotor &a);
/// internal conversion function
double norm_null_returns_scalar(const rotor &a);
/// Returns norm of oddVersor using null metric.
double norm_null(const oddVersor &a);
/// internal conversion function
double norm_null_returns_scalar(const oddVersor &a);
/// Returns norm of evenVersor using null metric.
double norm_null(const evenVersor &a);
/// internal conversion function
double norm_null_returns_scalar(const evenVersor &a);
/// Returns norm of pseudoscalar using null metric.
double norm_null(const pseudoscalar &a);
/// internal conversion function
double norm_null_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of mv using null metric.
double norm2_null(const mv &a);
/// internal conversion function
double norm2_null_returns_scalar(const mv &a);
/// Returns norm2 of vector using null metric.
double norm2_null(const vector &a);
/// internal conversion function
double norm2_null_returns_scalar(const vector &a);
/// Returns norm2 of bivector using null metric.
double norm2_null(const bivector &a);
/// internal conversion function
double norm2_null_returns_scalar(const bivector &a);
/// Returns norm2 of line using null metric.
double norm2_null(const line &a);
/// internal conversion function
double norm2_null_returns_scalar(const line &a);
/// Returns norm2 of plane using null metric.
double norm2_null(const plane &a);
/// internal conversion function
double norm2_null_returns_scalar(const plane &a);
/// Returns norm2 of rotor using null metric.
double norm2_null(const rotor &a);
/// internal conversion function
double norm2_null_returns_scalar(const rotor &a);
/// Returns norm2 of oddVersor using null metric.
double norm2_null(const oddVersor &a);
/// internal conversion function
double norm2_null_returns_scalar(const oddVersor &a);
/// Returns norm2 of evenVersor using null metric.
double norm2_null(const evenVersor &a);
/// internal conversion function
double norm2_null_returns_scalar(const evenVersor &a);
/// Returns norm2 of pseudoscalar using null metric.
double norm2_null(const pseudoscalar &a);
/// internal conversion function
double norm2_null_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of e0_t using null metric.
double norm2_null(const e0_t &a);
/// internal conversion function
double norm2_null_returns_scalar(const e0_t &a);
/// Returns norm2 of I4_t using null metric.
double norm2_null(const I4_t &a);
/// internal conversion function
double norm2_null_returns_scalar(const I4_t &a);
/// Returns norm2 of e1_t using null metric.
double norm2_null(const e1_t &a);
/// internal conversion function
double norm2_null_returns_scalar(const e1_t &a);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vector and vector.
bivector op(const vector &a, const vector &b);
/// Returns outer product of rotor and vector.
oddVersor op(const rotor &a, const vector &b);
/// Returns outer product of vector and line.
plane op(const vector &a, const line &b);
/// Returns outer product of rotor and line.
evenVersor op(const rotor &a, const line &b);
/// Returns outer product of vector and rotor.
oddVersor op(const vector &a, const rotor &b);
/// Returns outer product of rotor and rotor.
rotor op(const rotor &a, const rotor &b);
/// Returns outer product of plane and rotor.
plane op(const plane &a, const rotor &b);
/// Returns outer product of plane and line.
double op(const plane &a, const line &b);
/// Returns outer product of bivector and bivector.
double op(const bivector &a, const bivector &b);
/// Returns outer product of pseudoscalar and oddVersor.
double op(const pseudoscalar &a, const oddVersor &b);
/// Returns outer product of e1_t and e2_t.
bivector op(const e1_t &a, const e2_t &b);
/// Returns outer product of e0_t and I4i_t.
double op(const e0_t &a, const I4i_t &b);
/// Returns geometric product of mv and double.
mv gp(const mv &a, const double b);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);
/// exp of bivector (uses fast special case)
rotor exp(const bivector &a);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);
/// cosh of bivector (uses fast special case)
double cosh(const bivector &a);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);
/// sinh of bivector (uses fast special case)
bivector sinh(const bivector &a);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);
/// cos of bivector (uses fast special case)
double cos(const bivector &a);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);
/// sin of bivector (uses fast special case)
bivector sin(const bivector &a);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns negation of vector.
vector negate(const vector &a);
/// Returns negation of bivector.
bivector negate(const bivector &a);
/// Returns negation of normalizedPoint.
point negate(const normalizedPoint &a);
/// Returns negation of point.
point negate(const point &a);
/// Returns negation of line.
line negate(const line &a);
/// Returns negation of plane.
plane negate(const plane &a);
/// Returns negation of rotor.
rotor negate(const rotor &a);
/// Returns negation of oddVersor.
oddVersor negate(const oddVersor &a);
/// Returns negation of evenVersor.
evenVersor negate(const evenVersor &a);
/// Returns negation of pseudoscalar.
pseudoscalar negate(const pseudoscalar &a);
/// Returns negation of e1_t.
vector negate(const e1_t &a);
/// Returns negation of e2_t.
vector negate(const e2_t &a);
/// Returns negation of I4_t.
pseudoscalar negate(const I4_t &a);
/// Returns negation of double.
double negate(const double a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns reverse of vector.
vector reverse(const vector &a);
/// Returns reverse of bivector.
bivector reverse(const bivector &a);
/// Returns reverse of normalizedPoint.
normalizedPoint reverse(const normalizedPoint &a);
/// Returns reverse of point.
point reverse(const point &a);
/// Returns reverse of line.
line reverse(const line &a);
/// Returns reverse of plane.
plane reverse(const plane &a);
/// Returns reverse of rotor.
rotor reverse(const rotor &a);
/// Returns reverse of oddVersor.
oddVersor reverse(const oddVersor &a);
/// Returns reverse of evenVersor.
evenVersor reverse(const evenVersor &a);
/// Returns reverse of pseudoscalar.
pseudoscalar reverse(const pseudoscalar &a);
/// Returns reverse of double.
double reverse(const double a);
/// Returns reverse of e0_t.
e0_t reverse(const e0_t &a);
/// Returns reverse of e3_t.
e3_t reverse(const e3_t &a);
/// Returns reverse of I4i_t.
I4_t reverse(const I4i_t &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns Clifford conjugate of vector.
vector cliffordConjugate(const vector &a);
/// Returns Clifford conjugate of bivector.
bivector cliffordConjugate(const bivector &a);
/// Returns Clifford conjugate of normalizedPoint.
point cliffordConjugate(const normalizedPoint &a);
/// Returns Clifford conjugate of point.
point cliffordConjugate(const point &a);
/// Returns Clifford conjugate of line.
line cliffordConjugate(const line &a);
/// Returns Clifford conjugate of plane.
plane cliffordConjugate(const plane &a);
/// Returns Clifford conjugate of rotor.
rotor cliffordConjugate(const rotor &a);
/// Returns Clifford conjugate of oddVersor.
oddVersor cliffordConjugate(const oddVersor &a);
/// Returns Clifford conjugate of evenVersor.
evenVersor cliffordConjugate(const evenVersor &a);
/// Returns Clifford conjugate of pseudoscalar.
pseudoscalar cliffordConjugate(const pseudoscalar &a);
/// Returns Clifford conjugate of double.
double cliffordConjugate(const double a);
/// Returns Clifford conjugate of e0_t.
point cliffordConjugate(const e0_t &a);
/// Returns Clifford conjugate of e3_t.
vector cliffordConjugate(const e3_t &a);
/// Returns Clifford conjugate of I4i_t.
I4_t cliffordConjugate(const I4i_t &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns grade involution of vector.
vector gradeInvolution(const vector &a);
/// Returns grade involution of bivector.
bivector gradeInvolution(const bivector &a);
/// Returns grade involution of normalizedPoint.
point gradeInvolution(const normalizedPoint &a);
/// Returns grade involution of point.
point gradeInvolution(const point &a);
/// Returns grade involution of line.
line gradeInvolution(const line &a);
/// Returns grade involution of plane.
plane gradeInvolution(const plane &a);
/// Returns grade involution of rotor.
rotor gradeInvolution(const rotor &a);
/// Returns grade involution of oddVersor.
oddVersor gradeInvolution(const oddVersor &a);
/// Returns grade involution of evenVersor.
evenVersor gradeInvolution(const evenVersor &a);
/// Returns grade involution of pseudoscalar.
pseudoscalar gradeInvolution(const pseudoscalar &a);
/// Returns grade involution of double.
double gradeInvolution(const double a);
/// Returns grade involution of e2_t.
vector gradeInvolution(const e2_t &a);
/// Returns grade involution of e1_t.
vector gradeInvolution(const e1_t &a);
/// Returns grade involution of I4_t.
I4_t gradeInvolution(const I4_t &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns unit of vector using default metric.
vector unit(const vector &a);
/// Returns unit of bivector using default metric.
bivector unit(const bivector &a);
/// Returns unit of line using default metric.
line unit(const line &a);
/// Returns unit of plane using default metric.
plane unit(const plane &a);
/// Returns unit of rotor using default metric.
rotor unit(const rotor &a);
/// Returns unit of oddVersor using default metric.
oddVersor unit(const oddVersor &a);
/// Returns unit of evenVersor using default metric.
evenVersor unit(const evenVersor &a);
/// Returns unit of normalizedPoint using default metric.
point unit(const normalizedPoint &a);
/// Returns unit of point using default metric.
point unit(const point &a);
/// Returns unit of pseudoscalar using default metric.
pseudoscalar unit(const pseudoscalar &a);
/// Returns unit of e1_t using default metric.
e1_t unit(const e1_t &a);
/// Returns unit of e2_t using default metric.
e2_t unit(const e2_t &a);
/// Returns unit of I4_t using default metric.
I4_t unit(const I4_t &a);
/// Returns unit of mv using null metric.
mv unit_null(const mv &a);
/// Returns unit of vector using null metric.
vector unit_null(const vector &a);
/// Returns unit of bivector using null metric.
bivector unit_null(const bivector &a);
/// Returns unit of line using null metric.
line unit_null(const line &a);
/// Returns unit of plane using null metric.
plane unit_null(const plane &a);
/// Returns unit of rotor using null metric.
rotor unit_null(const rotor &a);
/// Returns unit of oddVersor using null metric.
oddVersor unit_null(const oddVersor &a);
/// Returns unit of evenVersor using null metric.
evenVersor unit_null(const evenVersor &a);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns versor inverse of a using default metric.
vector versorInverse(const vector &a);
/// Returns versor inverse of a using default metric.
bivector versorInverse(const bivector &a);
/// Returns versor inverse of a using default metric.
line versorInverse(const line &a);
/// Returns versor inverse of a using default metric.
plane versorInverse(const plane &a);
/// Returns versor inverse of a using default metric.
rotor versorInverse(const rotor &a);
/// Returns versor inverse of a using default metric.
oddVersor versorInverse(const oddVersor &a);
/// Returns versor inverse of a using default metric.
evenVersor versorInverse(const evenVersor &a);
/// Returns versor inverse of a using default metric.
point versorInverse(const normalizedPoint &a);
/// Returns versor inverse of a using default metric.
point versorInverse(const point &a);
/// Returns versor inverse of a using default metric.
pseudoscalar versorInverse(const pseudoscalar &a);
/// Returns versor inverse of a using default metric.
e1_t versorInverse(const e1_t &a);
/// Returns versor inverse of a using default metric.
e2_t versorInverse(const e2_t &a);
/// Returns versor inverse of a using default metric.
I4_t versorInverse(const I4_t &a);
/// Returns versor inverse of a using null metric.
mv versorInverse_null(const mv &a);
/// Returns versor inverse of a using null metric.
vector versorInverse_null(const vector &a);
/// Returns versor inverse of a using null metric.
bivector versorInverse_null(const bivector &a);
/// Returns versor inverse of a using null metric.
line versorInverse_null(const line &a);
/// Returns versor inverse of a using null metric.
plane versorInverse_null(const plane &a);
/// Returns versor inverse of a using null metric.
rotor versorInverse_null(const rotor &a);
/// Returns versor inverse of a using null metric.
oddVersor versorInverse_null(const oddVersor &a);
/// Returns versor inverse of a using null metric.
evenVersor versorInverse_null(const evenVersor &a);
/// Returns true if all coordinates of a are abs <= b
bool zero(const mv &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const vector &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const bivector &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const pseudoscalar &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const rotor &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const line &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const plane &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const evenVersor &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const oddVersor &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const e1_t &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const e2_t &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const I4i_t &a, const double b);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vector operator+(const vector &a, const vector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline vector &operator+=(vector &a, const vector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline bivector operator+(const bivector &a, const bivector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline bivector &operator+=(bivector &a, const bivector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline plane operator+(const plane &a, const plane &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline plane &operator+=(plane &a, const plane &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline line operator+(const line &a, const line &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline line &operator+=(line &a, const line &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline point operator+(const normalizedPoint &a, const normalizedPoint &b) {
	return add(a, b);
}
/// returns add(a, b)
inline vector operator+(const e1_t &a, const e2_t &b) {
	return add(a, b);
}
/// returns add(a, b)
inline evenVersor operator+(const I4_t &a, const bivector &b) {
	return add(a, b);
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector operator-(const vector &a, const vector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector &operator-=(vector &a, const vector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector operator-(const bivector &a, const bivector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector &operator-=(bivector &a, const bivector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline plane operator-(const plane &a, const plane &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline plane &operator-=(plane &a, const plane &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline line operator-(const line &a, const line &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline line &operator-=(line &a, const line &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector operator-(const normalizedPoint &a, const normalizedPoint &b) {
	return subtract(a, b);
}
/// returns subtract(a, b)
inline evenVersor operator-(const I4_t &a, const bivector &b) {
	return subtract(a, b);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns dual(a)
inline plane operator*(const vector &a) {
	return dual(a);
}
/// returns dual(a)
inline plane operator*(const normalizedPoint &a) {
	return dual(a);
}
/// returns dual(a)
inline line operator*(const bivector &a) {
	return dual(a);
}
/// returns dual(a)
inline evenVersor operator*(const rotor &a) {
	return dual(a);
}
/// returns dual(a)
inline oddVersor operator*(const oddVersor &a) {
	return dual(a);
}
/// returns dual(a)
inline evenVersor operator*(const evenVersor &a) {
	return dual(a);
}
/// returns dual(a)
inline line operator*(const line &a) {
	return dual(a);
}
/// returns dual(a)
inline point operator*(const plane &a) {
	return dual(a);
}
/// returns dual(a)
inline double operator*(const pseudoscalar &a) {
	return dual(a);
}
/// returns dual(a)
inline plane operator*(const e1_t &a) {
	return dual(a);
}
/// returns dual(a)
inline double operator*(const I4_t &a) {
	return dual(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotor operator*(const vector &a, const vector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const rotor &a, const vector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const vector &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const rotor &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const vector &a, const rotor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline rotor operator*(const rotor &a, const rotor &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline rotor &operator*=(rotor &a, const rotor &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline oddVersor operator*(const plane &a, const rotor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const plane &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline rotor operator*(const bivector &a, const bivector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const point &a, const point &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const normalizedPoint &a, const normalizedPoint &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const pseudoscalar &a, const oddVersor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline bivector operator*(const e1_t &a, const e2_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline line operator*(const e3_t &a, const e0_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline plane operator*(const e3_t &a, const I4i_t &b) {
	return gp(a, b);
}
/// returns (a = increment(a))
inline mv &operator++(mv &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline rotor operator++(const bivector &a) {
	return increment(a);
}
/// returns (a = increment(a))
inline rotor &operator++(rotor &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline evenVersor &operator++(evenVersor &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline evenVersor operator++(const pseudoscalar &a) {
	return increment(a);
}
/// returns (a = increment(a))
inline evenVersor operator++(const I4_t &a) {
	return increment(a);
}
/// returns (a = decrement(a))
inline mv &operator--(mv &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline rotor operator--(const bivector &a) {
	return decrement(a);
}
/// returns (a = decrement(a))
inline rotor &operator--(rotor &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline evenVersor &operator--(evenVersor &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline evenVersor operator--(const pseudoscalar &a) {
	return decrement(a);
}
/// returns (a = decrement(a))
inline evenVersor operator--(const I4i_t &a) {
	return decrement(a);
}
/// returns sp(a, b)
inline mv operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns (a = sp(a, b))
inline mv &operator%=(mv &a, const mv &b) {
	return (a = sp(a, b));
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline mv operator>>(const mv &a, const mv &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline mv &operator>>=(mv &a, const mv &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const vector &a, const vector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline line operator<<(const vector &a, const plane &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const vector &a, const line &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector &a, const oddVersor &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const bivector &a, const vector &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline oddVersor operator>>(const evenVersor &a, const vector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector &a, const pseudoscalar &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline oddVersor operator<<(const vector &a, const evenVersor &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const vector &a, const bivector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const evenVersor &a, const rotor &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline rotor operator<<(const evenVersor &a, const rotor &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline oddVersor operator>>(const oddVersor &a, const rotor &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline oddVersor &operator>>=(oddVersor &a, const rotor &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const e1_t &a, const rotor &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline vector operator<<(const e2_t &a, const rotor &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline evenVersor operator>>(const I4_t &a, const rotor &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const e1_t &a, const e1_t &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const e2_t &a, const e3_t &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const I4_t &a, const I4i_t &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const rotor &a, const plane &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline evenVersor operator<<(const rotor &a, const line &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline rotor operator>>(const rotor &a, const evenVersor &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline rotor &operator>>=(rotor &a, const evenVersor &b) {
	return (a = rc(a, b));
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline bivector operator^(const vector &a, const vector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const rotor &a, const vector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline plane operator^(const vector &a, const line &b) {
	return op(a, b);
}
/// returns op(a, b)
inline evenVersor operator^(const rotor &a, const line &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const vector &a, const rotor &b) {
	return op(a, b);
}
/// returns op(a, b)
inline rotor operator^(const rotor &a, const rotor &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline rotor &operator^=(rotor &a, const rotor &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline plane operator^(const plane &a, const rotor &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline plane &operator^=(plane &a, const rotor &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline double operator^(const plane &a, const line &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivector &a, const bivector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const pseudoscalar &a, const oddVersor &b) {
	return op(a, b);
}
/// returns op(a, b)
inline bivector operator^(const e1_t &a, const e2_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const e0_t &a, const I4i_t &b) {
	return op(a, b);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const double &b) {
	return (a = gp(a, b));
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns negate(a)
inline vector operator-(const vector &a) {
	return negate(a);
}
/// returns negate(a)
inline bivector operator-(const bivector &a) {
	return negate(a);
}
/// returns negate(a)
inline point operator-(const normalizedPoint &a) {
	return negate(a);
}
/// returns negate(a)
inline point operator-(const point &a) {
	return negate(a);
}
/// returns negate(a)
inline line operator-(const line &a) {
	return negate(a);
}
/// returns negate(a)
inline plane operator-(const plane &a) {
	return negate(a);
}
/// returns negate(a)
inline rotor operator-(const rotor &a) {
	return negate(a);
}
/// returns negate(a)
inline oddVersor operator-(const oddVersor &a) {
	return negate(a);
}
/// returns negate(a)
inline evenVersor operator-(const evenVersor &a) {
	return negate(a);
}
/// returns negate(a)
inline pseudoscalar operator-(const pseudoscalar &a) {
	return negate(a);
}
/// returns negate(a)
inline vector operator-(const e1_t &a) {
	return negate(a);
}
/// returns negate(a)
inline vector operator-(const e2_t &a) {
	return negate(a);
}
/// returns negate(a)
inline pseudoscalar operator-(const I4_t &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns reverse(a)
inline vector operator~(const vector &a) {
	return reverse(a);
}
/// returns reverse(a)
inline bivector operator~(const bivector &a) {
	return reverse(a);
}
/// returns reverse(a)
inline normalizedPoint operator~(const normalizedPoint &a) {
	return reverse(a);
}
/// returns reverse(a)
inline point operator~(const point &a) {
	return reverse(a);
}
/// returns reverse(a)
inline line operator~(const line &a) {
	return reverse(a);
}
/// returns reverse(a)
inline plane operator~(const plane &a) {
	return reverse(a);
}
/// returns reverse(a)
inline rotor operator~(const rotor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline oddVersor operator~(const oddVersor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline evenVersor operator~(const evenVersor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline pseudoscalar operator~(const pseudoscalar &a) {
	return reverse(a);
}
/// returns reverse(a)
inline e0_t operator~(const e0_t &a) {
	return reverse(a);
}
/// returns reverse(a)
inline e3_t operator~(const e3_t &a) {
	return reverse(a);
}
/// returns reverse(a)
inline I4_t operator~(const I4i_t &a) {
	return reverse(a);
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline vector operator!(const vector &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline bivector operator!(const bivector &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline line operator!(const line &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline plane operator!(const plane &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline rotor operator!(const rotor &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline oddVersor operator!(const oddVersor &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline evenVersor operator!(const evenVersor &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline point operator!(const normalizedPoint &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline point operator!(const point &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline pseudoscalar operator!(const pseudoscalar &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline e1_t operator!(const e1_t &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline e2_t operator!(const e2_t &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline I4_t operator!(const I4_t &a) {
	return versorInverse(a);
}

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
}
inline void mv::set(double val) {
	setGroupUsage(1);
	m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
	setGroupUsage(gu);
	p3ga::copy_N(m_c, arr, p3ga_mvSize[gu]);

}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const double*srcC = src.getC();
	p3ga::copy_N(m_c, srcC, p3ga_mvSize[src.gu()]);

}
inline void e1_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e0_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void I4_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
	}
	else {
	}
}
inline void I4i_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
	}
	else {
	}
}
inline void vector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
	}
}
inline void point::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
		m_e0 = ptr[3];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_e0 = 0.0;
	}
}
inline void normalizedPoint::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
	}
}
inline void bivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void line::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e0_e1 = -ptr[3];
		m_e0_e2 = -ptr[4];
		m_e0_e3 = -ptr[5];
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
	}
	else {
		m_e0_e1 = 0.0;
		m_e0_e2 = 0.0;
		m_e0_e3 = 0.0;
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void plane::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_e1_e2_e0 = ptr[1];
		m_e2_e3_e0 = ptr[3];
		m_e3_e1_e0 = -ptr[2];
		m_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e0 = 0.0;
		m_e2_e3_e0 = 0.0;
		m_e3_e1_e0 = 0.0;
		m_e1_e2_e3 = 0.0;
	}
}
inline void pseudoscalar::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
		m_e2_e1_e3_e0 = -ptr[0];
	}
	else {
		m_e2_e1_e3_e0 = 0.0;
	}
}
inline void oddVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
		m_e0 = ptr[3];
		ptr += 4;
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_e0 = 0.0;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_e1_e2_e0 = ptr[1];
		m_e2_e3_e0 = ptr[3];
		m_e3_e1_e0 = -ptr[2];
		m_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e0 = 0.0;
		m_e2_e3_e0 = 0.0;
		m_e3_e1_e0 = 0.0;
		m_e1_e2_e3 = 0.0;
	}
}
inline void evenVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e0_e1 = -ptr[3];
		m_e0_e2 = -ptr[4];
		m_e0_e3 = -ptr[5];
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
		ptr += 6;
	}
	else {
		m_e0_e1 = 0.0;
		m_e0_e2 = 0.0;
		m_e0_e3 = 0.0;
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
		m_e2_e1_e3_e0 = -ptr[0];
	}
	else {
		m_e2_e1_e3_e0 = 0.0;
	}
}
inline void rotor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = ptr[2] = ptr[3] = 0.0;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = 0.0;
	ptr[1] = 1.0;
}
inline void mv::set(const e3_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const e0_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const I4_t &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const I4i_t &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const vector &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
	ptr[3] = 0.0;
}
inline void mv::set(const point &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
	ptr[3] = src.m_e0;
}
inline void mv::set(const normalizedPoint &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
	ptr[3] = 1.0;
}
inline void mv::set(const bivector &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
	ptr[3] = ptr[4] = ptr[5] = 0.0;
}
inline void mv::set(const line &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
	ptr[3] = -src.m_e0_e1;
	ptr[4] = -src.m_e0_e2;
	ptr[5] = -src.m_e0_e3;
}
inline void mv::set(const plane &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = src.m_e1_e2_e3;
	ptr[1] = src.m_e1_e2_e0;
	ptr[2] = -src.m_e3_e1_e0;
	ptr[3] = src.m_e2_e3_e0;
}
inline void mv::set(const pseudoscalar &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = -src.m_e2_e1_e3_e0;
}
inline void mv::set(const oddVersor &src) {
	setGroupUsage(10);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
	ptr[3] = src.m_e0;
	ptr += 4;
	ptr[0] = src.m_e1_e2_e3;
	ptr[1] = src.m_e1_e2_e0;
	ptr[2] = -src.m_e3_e1_e0;
	ptr[3] = src.m_e2_e3_e0;
}
inline void mv::set(const evenVersor &src) {
	setGroupUsage(21);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
	ptr[3] = -src.m_e0_e1;
	ptr[4] = -src.m_e0_e2;
	ptr[5] = -src.m_e0_e3;
	ptr += 6;
	ptr[0] = -src.m_e2_e1_e3_e0;
}
inline void mv::set(const rotor &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
	ptr[3] = ptr[4] = ptr[5] = 0.0;
}

inline double _double(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void vector::set()
{
	m_e1 = m_e2 = m_e3 = 0.0;

}
inline void point::set()
{
	m_e1 = m_e2 = m_e3 = m_e0 = 0.0;

}
inline void normalizedPoint::set()
{
	m_e1 = m_e2 = m_e3 = 0.0;

}
inline void bivector::set()
{
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void line::set()
{
	m_e0_e1 = m_e0_e2 = m_e0_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void plane::set()
{
	m_e1_e2_e0 = m_e2_e3_e0 = m_e3_e1_e0 = m_e1_e2_e3 = 0.0;

}
inline void pseudoscalar::set()
{
	m_e2_e1_e3_e0 = 0.0;

}
inline void oddVersor::set()
{
	m_e1 = m_e2 = m_e3 = m_e0 = m_e1_e2_e0 = m_e2_e3_e0 = m_e3_e1_e0 = m_e1_e2_e3 = 0.0;

}
inline void evenVersor::set()
{
	m_scalar = m_e0_e1 = m_e0_e2 = m_e0_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e2_e1_e3_e0 = 0.0;

}
inline void rotor::set()
{
	m_scalar = m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}

inline void evenVersor::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e0_e1 = m_e0_e2 = m_e0_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e2_e1_e3_e0 = 0.0;

}
inline void rotor::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}

inline void vector::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;

}
inline void point::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3, const double _e0)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_e0 = _e0;

}
inline void normalizedPoint::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;

}
inline void bivector::set(const CoordinateOrder co, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void line::set(const CoordinateOrder co, const double _e0_e1, const double _e0_e2, const double _e0_e3, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_e0_e1 = _e0_e1;
	m_e0_e2 = _e0_e2;
	m_e0_e3 = _e0_e3;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void plane::set(const CoordinateOrder co, const double _e1_e2_e0, const double _e2_e3_e0, const double _e3_e1_e0, const double _e1_e2_e3)
{
	m_e1_e2_e0 = _e1_e2_e0;
	m_e2_e3_e0 = _e2_e3_e0;
	m_e3_e1_e0 = _e3_e1_e0;
	m_e1_e2_e3 = _e1_e2_e3;

}
inline void pseudoscalar::set(const CoordinateOrder co, const double _e2_e1_e3_e0)
{
	m_e2_e1_e3_e0 = _e2_e1_e3_e0;

}
inline void oddVersor::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3, const double _e0, const double _e1_e2_e0, const double _e2_e3_e0, const double _e3_e1_e0, const double _e1_e2_e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_e0 = _e0;
	m_e1_e2_e0 = _e1_e2_e0;
	m_e2_e3_e0 = _e2_e3_e0;
	m_e3_e1_e0 = _e3_e1_e0;
	m_e1_e2_e3 = _e1_e2_e3;

}
inline void evenVersor::set(const CoordinateOrder co, const double _scalar, const double _e0_e1, const double _e0_e2, const double _e0_e3, const double _e1_e2, const double _e2_e3, const double _e3_e1, const double _e2_e1_e3_e0)
{
	m_scalar = _scalar;
	m_e0_e1 = _e0_e1;
	m_e0_e2 = _e0_e2;
	m_e0_e3 = _e0_e3;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;
	m_e2_e1_e3_e0 = _e2_e1_e3_e0;

}
inline void rotor::set(const CoordinateOrder co, const double _scalar, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_scalar = _scalar;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}

inline void vector::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];

}
inline void point::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];
	m_e0 = A[3];

}
inline void normalizedPoint::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];

}
inline void bivector::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2 = A[0];
	m_e2_e3 = A[1];
	m_e3_e1 = A[2];

}
inline void line::set(const CoordinateOrder co, const double *A)
{
	m_e0_e1 = A[0];
	m_e0_e2 = A[1];
	m_e0_e3 = A[2];
	m_e1_e2 = A[3];
	m_e2_e3 = A[4];
	m_e3_e1 = A[5];

}
inline void plane::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_e0 = A[0];
	m_e2_e3_e0 = A[1];
	m_e3_e1_e0 = A[2];
	m_e1_e2_e3 = A[3];

}
inline void pseudoscalar::set(const CoordinateOrder co, const double *A)
{
	m_e2_e1_e3_e0 = A[0];

}
inline void oddVersor::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];
	m_e0 = A[3];
	m_e1_e2_e0 = A[4];
	m_e2_e3_e0 = A[5];
	m_e3_e1_e0 = A[6];
	m_e1_e2_e3 = A[7];

}
inline void evenVersor::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e0_e1 = A[1];
	m_e0_e2 = A[2];
	m_e0_e3 = A[3];
	m_e1_e2 = A[4];
	m_e2_e3 = A[5];
	m_e3_e1 = A[6];
	m_e2_e1_e3_e0 = A[7];

}
inline void rotor::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_e2 = A[1];
	m_e2_e3 = A[2];
	m_e3_e1 = A[3];

}

inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void e3_t::set(const e3_t &a)
{

}
inline void e0_t::set(const e0_t &a)
{

}
inline void I4_t::set(const I4_t &a)
{

}
inline void I4i_t::set(const I4i_t &a)
{

}
inline void vector::set(const vector &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;

}
inline void point::set(const point &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_e0 = a.m_e0;

}
inline void normalizedPoint::set(const normalizedPoint &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;

}
inline void bivector::set(const bivector &a)
{
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void line::set(const line &a)
{
	m_e0_e1 = a.m_e0_e1;
	m_e0_e2 = a.m_e0_e2;
	m_e0_e3 = a.m_e0_e3;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void plane::set(const plane &a)
{
	m_e1_e2_e0 = a.m_e1_e2_e0;
	m_e2_e3_e0 = a.m_e2_e3_e0;
	m_e3_e1_e0 = a.m_e3_e1_e0;
	m_e1_e2_e3 = a.m_e1_e2_e3;

}
inline void pseudoscalar::set(const pseudoscalar &a)
{
	m_e2_e1_e3_e0 = a.m_e2_e1_e3_e0;

}
inline void oddVersor::set(const oddVersor &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_e0 = a.m_e0;
	m_e1_e2_e0 = a.m_e1_e2_e0;
	m_e2_e3_e0 = a.m_e2_e3_e0;
	m_e3_e1_e0 = a.m_e3_e1_e0;
	m_e1_e2_e3 = a.m_e1_e2_e3;

}
inline void evenVersor::set(const evenVersor &a)
{
	m_scalar = a.m_scalar;
	m_e0_e1 = a.m_e0_e1;
	m_e0_e2 = a.m_e0_e2;
	m_e0_e3 = a.m_e0_e3;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;
	m_e2_e1_e3_e0 = a.m_e2_e1_e3_e0;

}
inline void rotor::set(const rotor &a)
{
	m_scalar = a.m_scalar;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}


inline double e1_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e1_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	return maxValue;
}
inline double e2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 2;
	return maxValue;
}
inline double e3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 4;
	return maxValue;
}
inline double e0_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e0_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 8;
	return maxValue;
}
inline double I4_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I4_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 15;
	return maxValue;
}
inline double I4i_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I4i_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 15;
	return maxValue;
}
inline double vector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	return maxValue;
}
inline double vector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	return maxValue;
}
inline double point::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_e0) > maxValue) { maxValue = ::fabs(m_e0); }
	return maxValue;
}
inline double point::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	if (::fabs(m_e0) > maxValue) { maxValue = ::fabs(m_e0); bm = 8; }
	return maxValue;
}
inline double normalizedPoint::largestCoordinate() const {
	double maxValue = 1.0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	return maxValue;
}
inline double normalizedPoint::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 8;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 1; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	return maxValue;
}
inline double bivector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2);
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double bivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2);
	bm = 0;
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	return maxValue;
}
inline double line::largestCoordinate() const {
	double maxValue = ::fabs(m_e0_e1);
	if (::fabs(m_e0_e2) > maxValue) { maxValue = ::fabs(m_e0_e2); }
	if (::fabs(m_e0_e3) > maxValue) { maxValue = ::fabs(m_e0_e3); }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double line::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e0_e1);
	bm = 0;
	if (::fabs(m_e0_e2) > maxValue) { maxValue = ::fabs(m_e0_e2); bm = 10; }
	if (::fabs(m_e0_e3) > maxValue) { maxValue = ::fabs(m_e0_e3); bm = 12; }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 3; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	return maxValue;
}
inline double plane::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_e0);
	if (::fabs(m_e2_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e3_e0); }
	if (::fabs(m_e3_e1_e0) > maxValue) { maxValue = ::fabs(m_e3_e1_e0); }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); }
	return maxValue;
}
inline double plane::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_e0);
	bm = 0;
	if (::fabs(m_e2_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e3_e0); bm = 14; }
	if (::fabs(m_e3_e1_e0) > maxValue) { maxValue = ::fabs(m_e3_e1_e0); bm = 13; }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); bm = 7; }
	return maxValue;
}
inline double pseudoscalar::largestCoordinate() const {
	double maxValue = ::fabs(m_e2_e1_e3_e0);
	return maxValue;
}
inline double pseudoscalar::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e2_e1_e3_e0);
	bm = 0;
	return maxValue;
}
inline double oddVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_e0) > maxValue) { maxValue = ::fabs(m_e0); }
	if (::fabs(m_e1_e2_e0) > maxValue) { maxValue = ::fabs(m_e1_e2_e0); }
	if (::fabs(m_e2_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e3_e0); }
	if (::fabs(m_e3_e1_e0) > maxValue) { maxValue = ::fabs(m_e3_e1_e0); }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); }
	return maxValue;
}
inline double oddVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	if (::fabs(m_e0) > maxValue) { maxValue = ::fabs(m_e0); bm = 8; }
	if (::fabs(m_e1_e2_e0) > maxValue) { maxValue = ::fabs(m_e1_e2_e0); bm = 11; }
	if (::fabs(m_e2_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e3_e0); bm = 14; }
	if (::fabs(m_e3_e1_e0) > maxValue) { maxValue = ::fabs(m_e3_e1_e0); bm = 13; }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); bm = 7; }
	return maxValue;
}
inline double evenVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e0_e1) > maxValue) { maxValue = ::fabs(m_e0_e1); }
	if (::fabs(m_e0_e2) > maxValue) { maxValue = ::fabs(m_e0_e2); }
	if (::fabs(m_e0_e3) > maxValue) { maxValue = ::fabs(m_e0_e3); }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	if (::fabs(m_e2_e1_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e1_e3_e0); }
	return maxValue;
}
inline double evenVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e0_e1) > maxValue) { maxValue = ::fabs(m_e0_e1); bm = 9; }
	if (::fabs(m_e0_e2) > maxValue) { maxValue = ::fabs(m_e0_e2); bm = 10; }
	if (::fabs(m_e0_e3) > maxValue) { maxValue = ::fabs(m_e0_e3); bm = 12; }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 3; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	if (::fabs(m_e2_e1_e3_e0) > maxValue) { maxValue = ::fabs(m_e2_e1_e3_e0); bm = 15; }
	return maxValue;
}
inline double rotor::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double rotor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 3; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	return maxValue;
}

inline double _double(const e1_t &x) {
	return 0.0;
}
inline double _double(const e2_t &x) {
	return 0.0;
}
inline double _double(const e3_t &x) {
	return 0.0;
}
inline double _double(const e0_t &x) {
	return 0.0;
}
inline double _double(const I4_t &x) {
	return 0.0;
}
inline double _double(const I4i_t &x) {
	return 0.0;
}
inline double _double(const vector &x) {
	return 0.0;
}
inline double _double(const point &x) {
	return 0.0;
}
inline double _double(const normalizedPoint &x) {
	return 0.0;
}
inline double _double(const bivector &x) {
	return 0.0;
}
inline double _double(const line &x) {
	return 0.0;
}
inline double _double(const plane &x) {
	return 0.0;
}
inline double _double(const pseudoscalar &x) {
	return 0.0;
}
inline double _double(const oddVersor &x) {
	return 0.0;
}
inline double _double(const evenVersor &x) {
	return x.m_scalar;
}
inline double _double(const rotor &x) {
	return x.m_scalar;
}

inline void om::setIdentity() {
	p3ga::zero_16(m_m1);

	p3ga::zero_N(m_m2, 36);

	p3ga::zero_16(m_m3);

	p3ga::zero_1(m_m4);

	m_m1[0] = m_m1[5] = m_m1[10] = m_m1[15] = m_m2[0] = m_m2[7] = m_m2[14] = m_m2[21] = 
		m_m2[28] = m_m2[35] = m_m3[0] = m_m3[5] = m_m3[10] = m_m3[15] = m_m4[0] = 1.0;
}

inline void om::set(const om &src) {
	p3ga::copy_16(m_m1, src.m_m1);

	p3ga::copy_N(m_m2, src.m_m2, 36);

	p3ga::copy_16(m_m3, src.m_m3);

	p3ga::copy_1(m_m4, src.m_m4);

}
inline void grade1OM::set(const om &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
}
inline void grade2OM::set(const om &src) {
	m_m2[0] =  src.m_m2[21];
	m_m2[1] =  src.m_m2[22];
	m_m2[2] =  src.m_m2[23];
	m_m2[3] = -1.0 *  src.m_m2[18];
	m_m2[4] = -1.0 *  src.m_m2[20];
	m_m2[5] =  src.m_m2[19];
	m_m2[6] =  src.m_m2[27];
	m_m2[7] =  src.m_m2[28];
	m_m2[8] =  src.m_m2[29];
	m_m2[9] = -1.0 *  src.m_m2[24];
	m_m2[10] = -1.0 *  src.m_m2[26];
	m_m2[11] =  src.m_m2[25];
	m_m2[12] =  src.m_m2[33];
	m_m2[13] =  src.m_m2[34];
	m_m2[14] =  src.m_m2[35];
	m_m2[15] = -1.0 *  src.m_m2[30];
	m_m2[16] = -1.0 *  src.m_m2[32];
	m_m2[17] =  src.m_m2[31];
	m_m2[18] = -1.0 *  src.m_m2[3];
	m_m2[19] = -1.0 *  src.m_m2[4];
	m_m2[20] = -1.0 *  src.m_m2[5];
	m_m2[21] =  src.m_m2[0];
	m_m2[22] =  src.m_m2[2];
	m_m2[23] = -1.0 *  src.m_m2[1];
	m_m2[24] = -1.0 *  src.m_m2[15];
	m_m2[25] = -1.0 *  src.m_m2[16];
	m_m2[26] = -1.0 *  src.m_m2[17];
	m_m2[27] =  src.m_m2[12];
	m_m2[28] =  src.m_m2[14];
	m_m2[29] = -1.0 *  src.m_m2[13];
	m_m2[30] =  src.m_m2[9];
	m_m2[31] =  src.m_m2[10];
	m_m2[32] =  src.m_m2[11];
	m_m2[33] = -1.0 *  src.m_m2[6];
	m_m2[34] = -1.0 *  src.m_m2[8];
	m_m2[35] =  src.m_m2[7];
}
inline void grade3OM::set(const om &src) {
	m_m3[0] =  src.m_m3[5];
	m_m3[1] =  src.m_m3[7];
	m_m3[2] = -1.0 *  src.m_m3[6];
	m_m3[3] =  src.m_m3[4];
	m_m3[4] =  src.m_m3[13];
	m_m3[5] =  src.m_m3[15];
	m_m3[6] = -1.0 *  src.m_m3[14];
	m_m3[7] =  src.m_m3[12];
	m_m3[8] = -1.0 *  src.m_m3[9];
	m_m3[9] = -1.0 *  src.m_m3[11];
	m_m3[10] =  src.m_m3[10];
	m_m3[11] = -1.0 *  src.m_m3[8];
	m_m3[12] =  src.m_m3[1];
	m_m3[13] =  src.m_m3[3];
	m_m3[14] = -1.0 *  src.m_m3[2];
	m_m3[15] =  src.m_m3[0];
}
inline void om::set(const grade1OM &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
	m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = 
		m_m2[9] = m_m2[10] = m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = 
		m_m2[18] = m_m2[19] = m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = 
		m_m2[27] = m_m2[28] = m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = 
		m_m3[0] = m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = m_m3[8] = 
		m_m3[9] = m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m4[0] = 0.0;
}
inline void om::set(const grade2OM &src) {
	m_m2[0] =  src.m_m2[21];
	m_m2[1] = -1.0 *  src.m_m2[23];
	m_m2[2] =  src.m_m2[22];
	m_m2[3] = -1.0 *  src.m_m2[18];
	m_m2[4] = -1.0 *  src.m_m2[19];
	m_m2[5] = -1.0 *  src.m_m2[20];
	m_m2[6] = -1.0 *  src.m_m2[33];
	m_m2[7] =  src.m_m2[35];
	m_m2[8] = -1.0 *  src.m_m2[34];
	m_m2[9] =  src.m_m2[30];
	m_m2[10] =  src.m_m2[31];
	m_m2[11] =  src.m_m2[32];
	m_m2[12] =  src.m_m2[27];
	m_m2[13] = -1.0 *  src.m_m2[29];
	m_m2[14] =  src.m_m2[28];
	m_m2[15] = -1.0 *  src.m_m2[24];
	m_m2[16] = -1.0 *  src.m_m2[25];
	m_m2[17] = -1.0 *  src.m_m2[26];
	m_m2[18] = -1.0 *  src.m_m2[3];
	m_m2[19] =  src.m_m2[5];
	m_m2[20] = -1.0 *  src.m_m2[4];
	m_m2[21] =  src.m_m2[0];
	m_m2[22] =  src.m_m2[1];
	m_m2[23] =  src.m_m2[2];
	m_m2[24] = -1.0 *  src.m_m2[9];
	m_m2[25] =  src.m_m2[11];
	m_m2[26] = -1.0 *  src.m_m2[10];
	m_m2[27] =  src.m_m2[6];
	m_m2[28] =  src.m_m2[7];
	m_m2[29] =  src.m_m2[8];
	m_m2[30] = -1.0 *  src.m_m2[15];
	m_m2[31] =  src.m_m2[17];
	m_m2[32] = -1.0 *  src.m_m2[16];
	m_m2[33] =  src.m_m2[12];
	m_m2[34] =  src.m_m2[13];
	m_m2[35] =  src.m_m2[14];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m1[9] = m_m1[10] = m_m1[11] = m_m1[12] = m_m1[13] = m_m1[14] = m_m1[15] = m_m3[0] = m_m3[1] = 
		m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = m_m3[8] = m_m3[9] = m_m3[10] = 
		m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m4[0] = 0.0;
}
inline void om::set(const grade3OM &src) {
	m_m3[0] =  src.m_m3[15];
	m_m3[1] =  src.m_m3[12];
	m_m3[2] = -1.0 *  src.m_m3[14];
	m_m3[3] =  src.m_m3[13];
	m_m3[4] =  src.m_m3[3];
	m_m3[5] =  src.m_m3[0];
	m_m3[6] = -1.0 *  src.m_m3[2];
	m_m3[7] =  src.m_m3[1];
	m_m3[8] = -1.0 *  src.m_m3[11];
	m_m3[9] = -1.0 *  src.m_m3[8];
	m_m3[10] =  src.m_m3[10];
	m_m3[11] = -1.0 *  src.m_m3[9];
	m_m3[12] =  src.m_m3[7];
	m_m3[13] =  src.m_m3[4];
	m_m3[14] = -1.0 *  src.m_m3[6];
	m_m3[15] =  src.m_m3[5];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m1[9] = m_m1[10] = m_m1[11] = m_m1[12] = m_m1[13] = m_m1[14] = m_m1[15] = m_m2[0] = m_m2[1] = 
		m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = m_m2[9] = m_m2[10] = 
		m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = m_m2[18] = m_m2[19] = 
		m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = m_m2[27] = m_m2[28] = 
		m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = m_m4[0] = 0.0;
}

inline void grade1OM::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[4] = m_m1[8] = m_m1[12] = 0.0;

	m_m1[1] = m_m1[9] = m_m1[13] = 0.0;
	m_m1[5] = 1.0;

	m_m1[2] = m_m1[6] = m_m1[14] = 0.0;
	m_m1[10] = 1.0;

	m_m1[3] = m_m1[7] = m_m1[11] = 0.0;
	m_m1[15] = 1.0;

}

inline void grade2OM::setIdentity()
{
	m_m2[0] = 1.0;
	m_m2[6] = m_m2[12] = m_m2[18] = m_m2[24] = m_m2[30] = 0.0;

	m_m2[1] = m_m2[13] = m_m2[19] = m_m2[25] = m_m2[31] = 0.0;
	m_m2[7] = 1.0;

	m_m2[2] = m_m2[8] = m_m2[20] = m_m2[26] = m_m2[32] = 0.0;
	m_m2[14] = 1.0;

	m_m2[3] = m_m2[9] = m_m2[15] = m_m2[27] = m_m2[33] = 0.0;
	m_m2[21] = 1.0;

	m_m2[4] = m_m2[10] = m_m2[16] = m_m2[22] = m_m2[34] = 0.0;
	m_m2[28] = 1.0;

	m_m2[5] = m_m2[11] = m_m2[17] = m_m2[23] = m_m2[29] = 0.0;
	m_m2[35] = 1.0;

}

inline void grade3OM::setIdentity()
{
	m_m3[0] = 1.0;
	m_m3[4] = m_m3[8] = m_m3[12] = 0.0;

	m_m3[1] = m_m3[9] = m_m3[13] = 0.0;
	m_m3[5] = 1.0;

	m_m3[2] = m_m3[6] = m_m3[14] = 0.0;
	m_m3[10] = 1.0;

	m_m3[3] = m_m3[7] = m_m3[11] = 0.0;
	m_m3[15] = 1.0;

}

inline void grade1OM::set(const grade1OM &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[4] = src.m_m1[4];
	m_m1[8] = src.m_m1[8];
	m_m1[12] = src.m_m1[12];

	m_m1[1] = src.m_m1[1];
	m_m1[5] = src.m_m1[5];
	m_m1[9] = src.m_m1[9];
	m_m1[13] = src.m_m1[13];

	m_m1[2] = src.m_m1[2];
	m_m1[6] = src.m_m1[6];
	m_m1[10] = src.m_m1[10];
	m_m1[14] = src.m_m1[14];

	m_m1[3] = src.m_m1[3];
	m_m1[7] = src.m_m1[7];
	m_m1[11] = src.m_m1[11];
	m_m1[15] = src.m_m1[15];

}

inline void grade2OM::set(const grade2OM &src)
{
	m_m2[0] = src.m_m2[0];
	m_m2[6] = src.m_m2[6];
	m_m2[12] = src.m_m2[12];
	m_m2[18] = src.m_m2[18];
	m_m2[24] = src.m_m2[24];
	m_m2[30] = src.m_m2[30];

	m_m2[1] = src.m_m2[1];
	m_m2[7] = src.m_m2[7];
	m_m2[13] = src.m_m2[13];
	m_m2[19] = src.m_m2[19];
	m_m2[25] = src.m_m2[25];
	m_m2[31] = src.m_m2[31];

	m_m2[2] = src.m_m2[2];
	m_m2[8] = src.m_m2[8];
	m_m2[14] = src.m_m2[14];
	m_m2[20] = src.m_m2[20];
	m_m2[26] = src.m_m2[26];
	m_m2[32] = src.m_m2[32];

	m_m2[3] = src.m_m2[3];
	m_m2[9] = src.m_m2[9];
	m_m2[15] = src.m_m2[15];
	m_m2[21] = src.m_m2[21];
	m_m2[27] = src.m_m2[27];
	m_m2[33] = src.m_m2[33];

	m_m2[4] = src.m_m2[4];
	m_m2[10] = src.m_m2[10];
	m_m2[16] = src.m_m2[16];
	m_m2[22] = src.m_m2[22];
	m_m2[28] = src.m_m2[28];
	m_m2[34] = src.m_m2[34];

	m_m2[5] = src.m_m2[5];
	m_m2[11] = src.m_m2[11];
	m_m2[17] = src.m_m2[17];
	m_m2[23] = src.m_m2[23];
	m_m2[29] = src.m_m2[29];
	m_m2[35] = src.m_m2[35];

}

inline void grade3OM::set(const grade3OM &src)
{
	m_m3[0] = src.m_m3[0];
	m_m3[4] = src.m_m3[4];
	m_m3[8] = src.m_m3[8];
	m_m3[12] = src.m_m3[12];

	m_m3[1] = src.m_m3[1];
	m_m3[5] = src.m_m3[5];
	m_m3[9] = src.m_m3[9];
	m_m3[13] = src.m_m3[13];

	m_m3[2] = src.m_m3[2];
	m_m3[6] = src.m_m3[6];
	m_m3[10] = src.m_m3[10];
	m_m3[14] = src.m_m3[14];

	m_m3[3] = src.m_m3[3];
	m_m3[7] = src.m_m3[7];
	m_m3[11] = src.m_m3[11];
	m_m3[15] = src.m_m3[15];

}
inline void grade1OM::set(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
{
	// Set image of e1
	m_m1[0] = ie1.m_e1;
	m_m1[4] = ie1.m_e2;
	m_m1[8] = ie1.m_e3;
	m_m1[12] = ie1.m_e0;

	// Set image of e2
	m_m1[1] = ie2.m_e1;
	m_m1[5] = ie2.m_e2;
	m_m1[9] = ie2.m_e3;
	m_m1[13] = ie2.m_e0;

	// Set image of e3
	m_m1[2] = ie3.m_e1;
	m_m1[6] = ie3.m_e2;
	m_m1[10] = ie3.m_e3;
	m_m1[14] = ie3.m_e0;

	// Set image of e0
	m_m1[3] = ie0.m_e1;
	m_m1[7] = ie0.m_e2;
	m_m1[11] = ie0.m_e3;
	m_m1[15] = ie0.m_e0;

}
inline void grade2OM::set(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
{
	// Set image of -1*e1^e0
	m_m2[0] = -(-ie0.m_e0*ie1.m_e1+ie0.m_e1*ie1.m_e0);
	m_m2[6] = -(-ie0.m_e0*ie1.m_e2+ie0.m_e2*ie1.m_e0);
	m_m2[12] = -(-ie0.m_e0*ie1.m_e3+ie0.m_e3*ie1.m_e0);
	m_m2[18] = (ie0.m_e1*ie1.m_e2-ie0.m_e2*ie1.m_e1);
	m_m2[24] = (ie0.m_e2*ie1.m_e3-ie0.m_e3*ie1.m_e2);
	m_m2[30] = -(ie0.m_e1*ie1.m_e3-ie0.m_e3*ie1.m_e1);

	// Set image of -1*e2^e0
	m_m2[1] = -(-ie0.m_e0*ie2.m_e1+ie0.m_e1*ie2.m_e0);
	m_m2[7] = -(-ie0.m_e0*ie2.m_e2+ie0.m_e2*ie2.m_e0);
	m_m2[13] = -(-ie0.m_e0*ie2.m_e3+ie0.m_e3*ie2.m_e0);
	m_m2[19] = (ie0.m_e1*ie2.m_e2-ie0.m_e2*ie2.m_e1);
	m_m2[25] = (ie0.m_e2*ie2.m_e3-ie0.m_e3*ie2.m_e2);
	m_m2[31] = -(ie0.m_e1*ie2.m_e3-ie0.m_e3*ie2.m_e1);

	// Set image of -1*e3^e0
	m_m2[2] = -(-ie0.m_e0*ie3.m_e1+ie0.m_e1*ie3.m_e0);
	m_m2[8] = -(-ie0.m_e0*ie3.m_e2+ie0.m_e2*ie3.m_e0);
	m_m2[14] = -(-ie0.m_e0*ie3.m_e3+ie0.m_e3*ie3.m_e0);
	m_m2[20] = (ie0.m_e1*ie3.m_e2-ie0.m_e2*ie3.m_e1);
	m_m2[26] = (ie0.m_e2*ie3.m_e3-ie0.m_e3*ie3.m_e2);
	m_m2[32] = -(ie0.m_e1*ie3.m_e3-ie0.m_e3*ie3.m_e1);

	// Set image of e1^e2
	m_m2[3] = -(-ie1.m_e0*ie2.m_e1+ie1.m_e1*ie2.m_e0);
	m_m2[9] = -(-ie1.m_e0*ie2.m_e2+ie1.m_e2*ie2.m_e0);
	m_m2[15] = -(-ie1.m_e0*ie2.m_e3+ie1.m_e3*ie2.m_e0);
	m_m2[21] = (ie1.m_e1*ie2.m_e2-ie1.m_e2*ie2.m_e1);
	m_m2[27] = (ie1.m_e2*ie2.m_e3-ie1.m_e3*ie2.m_e2);
	m_m2[33] = -(ie1.m_e1*ie2.m_e3-ie1.m_e3*ie2.m_e1);

	// Set image of e2^e3
	m_m2[4] = -(-ie2.m_e0*ie3.m_e1+ie2.m_e1*ie3.m_e0);
	m_m2[10] = -(-ie2.m_e0*ie3.m_e2+ie2.m_e2*ie3.m_e0);
	m_m2[16] = -(-ie2.m_e0*ie3.m_e3+ie2.m_e3*ie3.m_e0);
	m_m2[22] = (ie2.m_e1*ie3.m_e2-ie2.m_e2*ie3.m_e1);
	m_m2[28] = (ie2.m_e2*ie3.m_e3-ie2.m_e3*ie3.m_e2);
	m_m2[34] = -(ie2.m_e1*ie3.m_e3-ie2.m_e3*ie3.m_e1);

	// Set image of -1*e1^e3
	m_m2[5] = -(ie1.m_e0*ie3.m_e1-ie1.m_e1*ie3.m_e0);
	m_m2[11] = -(ie1.m_e0*ie3.m_e2-ie1.m_e2*ie3.m_e0);
	m_m2[17] = -(ie1.m_e0*ie3.m_e3-ie1.m_e3*ie3.m_e0);
	m_m2[23] = (-ie1.m_e1*ie3.m_e2+ie1.m_e2*ie3.m_e1);
	m_m2[29] = (-ie1.m_e2*ie3.m_e3+ie1.m_e3*ie3.m_e2);
	m_m2[35] = -(-ie1.m_e1*ie3.m_e3+ie1.m_e3*ie3.m_e1);

}
inline void grade3OM::set(const point &ie1, const point &ie2, const point &ie3, const point &ie0)
{
	// Set image of e1^e2^e0
	m_m3[0] = (ie0.m_e0*ie1.m_e1*ie2.m_e2-ie0.m_e0*ie1.m_e2*ie2.m_e1-ie0.m_e1*ie1.m_e0*ie2.m_e2+ie0.m_e1*ie1.m_e2*ie2.m_e0+ie0.m_e2*ie1.m_e0*ie2.m_e1-ie0.m_e2*ie1.m_e1*ie2.m_e0);
	m_m3[4] = (ie0.m_e0*ie1.m_e2*ie2.m_e3-ie0.m_e0*ie1.m_e3*ie2.m_e2-ie0.m_e2*ie1.m_e0*ie2.m_e3+ie0.m_e2*ie1.m_e3*ie2.m_e0+ie0.m_e3*ie1.m_e0*ie2.m_e2-ie0.m_e3*ie1.m_e2*ie2.m_e0);
	m_m3[8] = -(ie0.m_e0*ie1.m_e1*ie2.m_e3-ie0.m_e0*ie1.m_e3*ie2.m_e1-ie0.m_e1*ie1.m_e0*ie2.m_e3+ie0.m_e1*ie1.m_e3*ie2.m_e0+ie0.m_e3*ie1.m_e0*ie2.m_e1-ie0.m_e3*ie1.m_e1*ie2.m_e0);
	m_m3[12] = (ie0.m_e1*ie1.m_e2*ie2.m_e3-ie0.m_e1*ie1.m_e3*ie2.m_e2-ie0.m_e2*ie1.m_e1*ie2.m_e3+ie0.m_e2*ie1.m_e3*ie2.m_e1+ie0.m_e3*ie1.m_e1*ie2.m_e2-ie0.m_e3*ie1.m_e2*ie2.m_e1);

	// Set image of e2^e3^e0
	m_m3[1] = (ie0.m_e0*ie2.m_e1*ie3.m_e2-ie0.m_e0*ie2.m_e2*ie3.m_e1-ie0.m_e1*ie2.m_e0*ie3.m_e2+ie0.m_e1*ie2.m_e2*ie3.m_e0+ie0.m_e2*ie2.m_e0*ie3.m_e1-ie0.m_e2*ie2.m_e1*ie3.m_e0);
	m_m3[5] = (ie0.m_e0*ie2.m_e2*ie3.m_e3-ie0.m_e0*ie2.m_e3*ie3.m_e2-ie0.m_e2*ie2.m_e0*ie3.m_e3+ie0.m_e2*ie2.m_e3*ie3.m_e0+ie0.m_e3*ie2.m_e0*ie3.m_e2-ie0.m_e3*ie2.m_e2*ie3.m_e0);
	m_m3[9] = -(ie0.m_e0*ie2.m_e1*ie3.m_e3-ie0.m_e0*ie2.m_e3*ie3.m_e1-ie0.m_e1*ie2.m_e0*ie3.m_e3+ie0.m_e1*ie2.m_e3*ie3.m_e0+ie0.m_e3*ie2.m_e0*ie3.m_e1-ie0.m_e3*ie2.m_e1*ie3.m_e0);
	m_m3[13] = (ie0.m_e1*ie2.m_e2*ie3.m_e3-ie0.m_e1*ie2.m_e3*ie3.m_e2-ie0.m_e2*ie2.m_e1*ie3.m_e3+ie0.m_e2*ie2.m_e3*ie3.m_e1+ie0.m_e3*ie2.m_e1*ie3.m_e2-ie0.m_e3*ie2.m_e2*ie3.m_e1);

	// Set image of -1*e1^e3^e0
	m_m3[2] = (-ie0.m_e0*ie1.m_e1*ie3.m_e2+ie0.m_e0*ie1.m_e2*ie3.m_e1+ie0.m_e1*ie1.m_e0*ie3.m_e2-ie0.m_e1*ie1.m_e2*ie3.m_e0-ie0.m_e2*ie1.m_e0*ie3.m_e1+ie0.m_e2*ie1.m_e1*ie3.m_e0);
	m_m3[6] = (-ie0.m_e0*ie1.m_e2*ie3.m_e3+ie0.m_e0*ie1.m_e3*ie3.m_e2+ie0.m_e2*ie1.m_e0*ie3.m_e3-ie0.m_e2*ie1.m_e3*ie3.m_e0-ie0.m_e3*ie1.m_e0*ie3.m_e2+ie0.m_e3*ie1.m_e2*ie3.m_e0);
	m_m3[10] = -(-ie0.m_e0*ie1.m_e1*ie3.m_e3+ie0.m_e0*ie1.m_e3*ie3.m_e1+ie0.m_e1*ie1.m_e0*ie3.m_e3-ie0.m_e1*ie1.m_e3*ie3.m_e0-ie0.m_e3*ie1.m_e0*ie3.m_e1+ie0.m_e3*ie1.m_e1*ie3.m_e0);
	m_m3[14] = (-ie0.m_e1*ie1.m_e2*ie3.m_e3+ie0.m_e1*ie1.m_e3*ie3.m_e2+ie0.m_e2*ie1.m_e1*ie3.m_e3-ie0.m_e2*ie1.m_e3*ie3.m_e1-ie0.m_e3*ie1.m_e1*ie3.m_e2+ie0.m_e3*ie1.m_e2*ie3.m_e1);

	// Set image of e1^e2^e3
	m_m3[3] = (ie1.m_e0*ie2.m_e1*ie3.m_e2-ie1.m_e0*ie2.m_e2*ie3.m_e1-ie1.m_e1*ie2.m_e0*ie3.m_e2+ie1.m_e1*ie2.m_e2*ie3.m_e0+ie1.m_e2*ie2.m_e0*ie3.m_e1-ie1.m_e2*ie2.m_e1*ie3.m_e0);
	m_m3[7] = (ie1.m_e0*ie2.m_e2*ie3.m_e3-ie1.m_e0*ie2.m_e3*ie3.m_e2-ie1.m_e2*ie2.m_e0*ie3.m_e3+ie1.m_e2*ie2.m_e3*ie3.m_e0+ie1.m_e3*ie2.m_e0*ie3.m_e2-ie1.m_e3*ie2.m_e2*ie3.m_e0);
	m_m3[11] = -(ie1.m_e0*ie2.m_e1*ie3.m_e3-ie1.m_e0*ie2.m_e3*ie3.m_e1-ie1.m_e1*ie2.m_e0*ie3.m_e3+ie1.m_e1*ie2.m_e3*ie3.m_e0+ie1.m_e3*ie2.m_e0*ie3.m_e1-ie1.m_e3*ie2.m_e1*ie3.m_e0);
	m_m3[15] = (ie1.m_e1*ie2.m_e2*ie3.m_e3-ie1.m_e1*ie2.m_e3*ie3.m_e2-ie1.m_e2*ie2.m_e1*ie3.m_e3+ie1.m_e2*ie2.m_e3*ie3.m_e1+ie1.m_e3*ie2.m_e1*ie3.m_e2-ie1.m_e3*ie2.m_e2*ie3.m_e1);

}
inline void grade1OM::set(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[4] = M[4];
	m_m1[8] = M[8];
	m_m1[12] = M[12];

	// Set image of e2
	m_m1[1] = M[1];
	m_m1[5] = M[5];
	m_m1[9] = M[9];
	m_m1[13] = M[13];

	// Set image of e3
	m_m1[2] = M[2];
	m_m1[6] = M[6];
	m_m1[10] = M[10];
	m_m1[14] = M[14];

	// Set image of e0
	m_m1[3] = M[3];
	m_m1[7] = M[7];
	m_m1[11] = M[11];
	m_m1[15] = M[15];

}
inline void grade2OM::set(const double *M)
{
	// Set image of -1*e1^e0
	m_m2[0] = -(-M[0]*M[15]+M[12]*M[3]);
	m_m2[6] = -(M[12]*M[7]-M[15]*M[4]);
	m_m2[12] = -(M[11]*M[12]-M[15]*M[8]);
	m_m2[18] = (-M[0]*M[7]+M[3]*M[4]);
	m_m2[24] = (-M[11]*M[4]+M[7]*M[8]);
	m_m2[30] = -(-M[0]*M[11]+M[3]*M[8]);

	// Set image of -1*e2^e0
	m_m2[1] = -(-M[1]*M[15]+M[13]*M[3]);
	m_m2[7] = -(M[13]*M[7]-M[15]*M[5]);
	m_m2[13] = -(M[11]*M[13]-M[15]*M[9]);
	m_m2[19] = (-M[1]*M[7]+M[3]*M[5]);
	m_m2[25] = (-M[11]*M[5]+M[7]*M[9]);
	m_m2[31] = -(-M[1]*M[11]+M[3]*M[9]);

	// Set image of -1*e3^e0
	m_m2[2] = -(M[14]*M[3]-M[15]*M[2]);
	m_m2[8] = -(M[14]*M[7]-M[15]*M[6]);
	m_m2[14] = -(-M[10]*M[15]+M[11]*M[14]);
	m_m2[20] = (-M[2]*M[7]+M[3]*M[6]);
	m_m2[26] = (M[10]*M[7]-M[11]*M[6]);
	m_m2[32] = -(M[10]*M[3]-M[11]*M[2]);

	// Set image of e1^e2
	m_m2[3] = -(M[0]*M[13]-M[1]*M[12]);
	m_m2[9] = -(-M[12]*M[5]+M[13]*M[4]);
	m_m2[15] = -(-M[12]*M[9]+M[13]*M[8]);
	m_m2[21] = (M[0]*M[5]-M[1]*M[4]);
	m_m2[27] = (M[4]*M[9]-M[5]*M[8]);
	m_m2[33] = -(M[0]*M[9]-M[1]*M[8]);

	// Set image of e2^e3
	m_m2[4] = -(M[1]*M[14]-M[13]*M[2]);
	m_m2[10] = -(-M[13]*M[6]+M[14]*M[5]);
	m_m2[16] = -(-M[10]*M[13]+M[14]*M[9]);
	m_m2[22] = (M[1]*M[6]-M[2]*M[5]);
	m_m2[28] = (M[10]*M[5]-M[6]*M[9]);
	m_m2[34] = -(M[1]*M[10]-M[2]*M[9]);

	// Set image of -1*e1^e3
	m_m2[5] = -(-M[0]*M[14]+M[12]*M[2]);
	m_m2[11] = -(M[12]*M[6]-M[14]*M[4]);
	m_m2[17] = -(M[10]*M[12]-M[14]*M[8]);
	m_m2[23] = (-M[0]*M[6]+M[2]*M[4]);
	m_m2[29] = (-M[10]*M[4]+M[6]*M[8]);
	m_m2[35] = -(-M[0]*M[10]+M[2]*M[8]);

}
inline void grade3OM::set(const double *M)
{
	// Set image of e1^e2^e0
	m_m3[0] = (-M[0]*M[13]*M[7]+M[0]*M[15]*M[5]+M[1]*M[12]*M[7]-M[1]*M[15]*M[4]-M[12]*M[3]*M[5]+M[13]*M[3]*M[4]);
	m_m3[4] = (M[11]*M[12]*M[5]-M[11]*M[13]*M[4]-M[12]*M[7]*M[9]+M[13]*M[7]*M[8]+M[15]*M[4]*M[9]-M[15]*M[5]*M[8]);
	m_m3[8] = -(-M[0]*M[11]*M[13]+M[0]*M[15]*M[9]+M[1]*M[11]*M[12]-M[1]*M[15]*M[8]-M[12]*M[3]*M[9]+M[13]*M[3]*M[8]);
	m_m3[12] = (M[0]*M[11]*M[5]-M[0]*M[7]*M[9]-M[1]*M[11]*M[4]+M[1]*M[7]*M[8]+M[3]*M[4]*M[9]-M[3]*M[5]*M[8]);

	// Set image of e2^e3^e0
	m_m3[1] = (-M[1]*M[14]*M[7]+M[1]*M[15]*M[6]+M[13]*M[2]*M[7]-M[13]*M[3]*M[6]+M[14]*M[3]*M[5]-M[15]*M[2]*M[5]);
	m_m3[5] = (-M[10]*M[13]*M[7]+M[10]*M[15]*M[5]+M[11]*M[13]*M[6]-M[11]*M[14]*M[5]+M[14]*M[7]*M[9]-M[15]*M[6]*M[9]);
	m_m3[9] = -(M[1]*M[10]*M[15]-M[1]*M[11]*M[14]-M[10]*M[13]*M[3]+M[11]*M[13]*M[2]+M[14]*M[3]*M[9]-M[15]*M[2]*M[9]);
	m_m3[13] = (-M[1]*M[10]*M[7]+M[1]*M[11]*M[6]+M[10]*M[3]*M[5]-M[11]*M[2]*M[5]+M[2]*M[7]*M[9]-M[3]*M[6]*M[9]);

	// Set image of -1*e1^e3^e0
	m_m3[2] = (M[0]*M[14]*M[7]-M[0]*M[15]*M[6]-M[12]*M[2]*M[7]+M[12]*M[3]*M[6]-M[14]*M[3]*M[4]+M[15]*M[2]*M[4]);
	m_m3[6] = (M[10]*M[12]*M[7]-M[10]*M[15]*M[4]-M[11]*M[12]*M[6]+M[11]*M[14]*M[4]-M[14]*M[7]*M[8]+M[15]*M[6]*M[8]);
	m_m3[10] = -(-M[0]*M[10]*M[15]+M[0]*M[11]*M[14]+M[10]*M[12]*M[3]-M[11]*M[12]*M[2]-M[14]*M[3]*M[8]+M[15]*M[2]*M[8]);
	m_m3[14] = (M[0]*M[10]*M[7]-M[0]*M[11]*M[6]-M[10]*M[3]*M[4]+M[11]*M[2]*M[4]-M[2]*M[7]*M[8]+M[3]*M[6]*M[8]);

	// Set image of e1^e2^e3
	m_m3[3] = (-M[0]*M[13]*M[6]+M[0]*M[14]*M[5]+M[1]*M[12]*M[6]-M[1]*M[14]*M[4]-M[12]*M[2]*M[5]+M[13]*M[2]*M[4]);
	m_m3[7] = (M[10]*M[12]*M[5]-M[10]*M[13]*M[4]-M[12]*M[6]*M[9]+M[13]*M[6]*M[8]+M[14]*M[4]*M[9]-M[14]*M[5]*M[8]);
	m_m3[11] = -(-M[0]*M[10]*M[13]+M[0]*M[14]*M[9]+M[1]*M[10]*M[12]-M[1]*M[14]*M[8]-M[12]*M[2]*M[9]+M[13]*M[2]*M[8]);
	m_m3[15] = (M[0]*M[10]*M[5]-M[0]*M[6]*M[9]-M[1]*M[10]*M[4]+M[1]*M[6]*M[8]+M[2]*M[4]*M[9]-M[2]*M[5]*M[8]);

}
inline void grade1OM::setTranspose(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[4] = M[1];
	m_m1[8] = M[2];
	m_m1[12] = M[3];

	// Set image of e2
	m_m1[1] = M[4];
	m_m1[5] = M[5];
	m_m1[9] = M[6];
	m_m1[13] = M[7];

	// Set image of e3
	m_m1[2] = M[8];
	m_m1[6] = M[9];
	m_m1[10] = M[10];
	m_m1[14] = M[11];

	// Set image of e0
	m_m1[3] = M[12];
	m_m1[7] = M[13];
	m_m1[11] = M[14];
	m_m1[15] = M[15];

}
inline void grade2OM::setTranspose(const double *M)
{
	// Set image of -1*e1^e0
	m_m2[0] = -(-M[0]*M[15]+M[12]*M[3]);
	m_m2[6] = -(-M[1]*M[15]+M[13]*M[3]);
	m_m2[12] = -(M[14]*M[3]-M[15]*M[2]);
	m_m2[18] = (-M[0]*M[13]+M[1]*M[12]);
	m_m2[24] = (-M[1]*M[14]+M[13]*M[2]);
	m_m2[30] = -(-M[0]*M[14]+M[12]*M[2]);

	// Set image of -1*e2^e0
	m_m2[1] = -(M[12]*M[7]-M[15]*M[4]);
	m_m2[7] = -(M[13]*M[7]-M[15]*M[5]);
	m_m2[13] = -(M[14]*M[7]-M[15]*M[6]);
	m_m2[19] = (M[12]*M[5]-M[13]*M[4]);
	m_m2[25] = (M[13]*M[6]-M[14]*M[5]);
	m_m2[31] = -(M[12]*M[6]-M[14]*M[4]);

	// Set image of -1*e3^e0
	m_m2[2] = -(M[11]*M[12]-M[15]*M[8]);
	m_m2[8] = -(M[11]*M[13]-M[15]*M[9]);
	m_m2[14] = -(-M[10]*M[15]+M[11]*M[14]);
	m_m2[20] = (M[12]*M[9]-M[13]*M[8]);
	m_m2[26] = (M[10]*M[13]-M[14]*M[9]);
	m_m2[32] = -(M[10]*M[12]-M[14]*M[8]);

	// Set image of e1^e2
	m_m2[3] = -(M[0]*M[7]-M[3]*M[4]);
	m_m2[9] = -(M[1]*M[7]-M[3]*M[5]);
	m_m2[15] = -(M[2]*M[7]-M[3]*M[6]);
	m_m2[21] = (M[0]*M[5]-M[1]*M[4]);
	m_m2[27] = (M[1]*M[6]-M[2]*M[5]);
	m_m2[33] = -(M[0]*M[6]-M[2]*M[4]);

	// Set image of e2^e3
	m_m2[4] = -(M[11]*M[4]-M[7]*M[8]);
	m_m2[10] = -(M[11]*M[5]-M[7]*M[9]);
	m_m2[16] = -(-M[10]*M[7]+M[11]*M[6]);
	m_m2[22] = (M[4]*M[9]-M[5]*M[8]);
	m_m2[28] = (M[10]*M[5]-M[6]*M[9]);
	m_m2[34] = -(M[10]*M[4]-M[6]*M[8]);

	// Set image of -1*e1^e3
	m_m2[5] = -(-M[0]*M[11]+M[3]*M[8]);
	m_m2[11] = -(-M[1]*M[11]+M[3]*M[9]);
	m_m2[17] = -(M[10]*M[3]-M[11]*M[2]);
	m_m2[23] = (-M[0]*M[9]+M[1]*M[8]);
	m_m2[29] = (-M[1]*M[10]+M[2]*M[9]);
	m_m2[35] = -(-M[0]*M[10]+M[2]*M[8]);

}
inline void grade3OM::setTranspose(const double *M)
{
	// Set image of e1^e2^e0
	m_m3[0] = (-M[0]*M[13]*M[7]+M[0]*M[15]*M[5]+M[1]*M[12]*M[7]-M[1]*M[15]*M[4]-M[12]*M[3]*M[5]+M[13]*M[3]*M[4]);
	m_m3[4] = (-M[1]*M[14]*M[7]+M[1]*M[15]*M[6]+M[13]*M[2]*M[7]-M[13]*M[3]*M[6]+M[14]*M[3]*M[5]-M[15]*M[2]*M[5]);
	m_m3[8] = -(-M[0]*M[14]*M[7]+M[0]*M[15]*M[6]+M[12]*M[2]*M[7]-M[12]*M[3]*M[6]+M[14]*M[3]*M[4]-M[15]*M[2]*M[4]);
	m_m3[12] = (-M[0]*M[13]*M[6]+M[0]*M[14]*M[5]+M[1]*M[12]*M[6]-M[1]*M[14]*M[4]-M[12]*M[2]*M[5]+M[13]*M[2]*M[4]);

	// Set image of e2^e3^e0
	m_m3[1] = (M[11]*M[12]*M[5]-M[11]*M[13]*M[4]-M[12]*M[7]*M[9]+M[13]*M[7]*M[8]+M[15]*M[4]*M[9]-M[15]*M[5]*M[8]);
	m_m3[5] = (-M[10]*M[13]*M[7]+M[10]*M[15]*M[5]+M[11]*M[13]*M[6]-M[11]*M[14]*M[5]+M[14]*M[7]*M[9]-M[15]*M[6]*M[9]);
	m_m3[9] = -(-M[10]*M[12]*M[7]+M[10]*M[15]*M[4]+M[11]*M[12]*M[6]-M[11]*M[14]*M[4]+M[14]*M[7]*M[8]-M[15]*M[6]*M[8]);
	m_m3[13] = (M[10]*M[12]*M[5]-M[10]*M[13]*M[4]-M[12]*M[6]*M[9]+M[13]*M[6]*M[8]+M[14]*M[4]*M[9]-M[14]*M[5]*M[8]);

	// Set image of -1*e1^e3^e0
	m_m3[2] = (M[0]*M[11]*M[13]-M[0]*M[15]*M[9]-M[1]*M[11]*M[12]+M[1]*M[15]*M[8]+M[12]*M[3]*M[9]-M[13]*M[3]*M[8]);
	m_m3[6] = (-M[1]*M[10]*M[15]+M[1]*M[11]*M[14]+M[10]*M[13]*M[3]-M[11]*M[13]*M[2]-M[14]*M[3]*M[9]+M[15]*M[2]*M[9]);
	m_m3[10] = -(-M[0]*M[10]*M[15]+M[0]*M[11]*M[14]+M[10]*M[12]*M[3]-M[11]*M[12]*M[2]-M[14]*M[3]*M[8]+M[15]*M[2]*M[8]);
	m_m3[14] = (M[0]*M[10]*M[13]-M[0]*M[14]*M[9]-M[1]*M[10]*M[12]+M[1]*M[14]*M[8]+M[12]*M[2]*M[9]-M[13]*M[2]*M[8]);

	// Set image of e1^e2^e3
	m_m3[3] = (M[0]*M[11]*M[5]-M[0]*M[7]*M[9]-M[1]*M[11]*M[4]+M[1]*M[7]*M[8]+M[3]*M[4]*M[9]-M[3]*M[5]*M[8]);
	m_m3[7] = (-M[1]*M[10]*M[7]+M[1]*M[11]*M[6]+M[10]*M[3]*M[5]-M[11]*M[2]*M[5]+M[2]*M[7]*M[9]-M[3]*M[6]*M[9]);
	m_m3[11] = -(-M[0]*M[10]*M[7]+M[0]*M[11]*M[6]+M[10]*M[3]*M[4]-M[11]*M[2]*M[4]+M[2]*M[7]*M[8]-M[3]*M[6]*M[8]);
	m_m3[15] = (M[0]*M[10]*M[5]-M[0]*M[6]*M[9]-M[1]*M[10]*M[4]+M[1]*M[6]*M[8]+M[2]*M[4]*M[9]-M[2]*M[5]*M[8]);

}
inline vector _vector(const normalizedPoint &P)
{
	return vector(vector::coord_e1_e2_e3,
			P.m_e1, // e1
			P.m_e2, // e2
			P.m_e3 // e3
		);

}
inline vector _vector(const point &P)
{
	return vector(vector::coord_e1_e2_e3,
			P.m_e1, // e1
			P.m_e2, // e2
			P.m_e3 // e3
		);

}
inline bivector _bivector(const rotor &R)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			R.m_e1_e2, // e1_e2
			R.m_e2_e3, // e2_e3
			R.m_e3_e1 // e3_e1
		);

}
inline line _line(const oddVersor &V)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline vector _vector(const oddVersor &V)
{
	return vector(vector::coord_e1_e2_e3,
			V.m_e1, // e1
			V.m_e2, // e2
			V.m_e3 // e3
		);

}
inline bivector _bivector(const line &V)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			V.m_e1_e2, // e1_e2
			V.m_e2_e3, // e2_e3
			V.m_e3_e1 // e3_e1
		);

}
inline double genrand() {
return (double)((double)(rand() & 0x7FFF) / 32768.0) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0 * 32768.0)); 
}
inline void genrand_seed(unsigned int seed) {
	srand(seed);
}

inline void genrand_timeSeed() {
	genrand_seed((unsigned int)time(NULL));
}

inline vector add(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3) // e3
		);

}
inline bivector add(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1) // e3_e1
		);

}
inline plane add(const plane &a, const plane &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2_e0+b.m_e1_e2_e0), // e1_e2_e0
			(a.m_e2_e3_e0+b.m_e2_e3_e0), // e2_e3_e0
			-(-a.m_e3_e1_e0-b.m_e3_e1_e0), // e3_e1_e0
			(a.m_e1_e2_e3+b.m_e1_e2_e3) // e1_e2_e3
		);

}
inline line add(const line &a, const line &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e0_e1-b.m_e0_e1), // e0_e1
			-(-a.m_e0_e2-b.m_e0_e2), // e0_e2
			-(-a.m_e0_e3-b.m_e0_e3), // e0_e3
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1) // e3_e1
		);

}
inline point add(const normalizedPoint &a, const normalizedPoint &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3), // e3
			2.0 // e0
		);

}
inline vector add(const e1_t &a, const e2_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			1.0, // e1
			1.0, // e2
			0.0 // e3
		);

}
inline evenVersor add(const I4_t &a, const bivector &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			b.m_e1_e2, // e1_e2
			b.m_e2_e3, // e2_e3
			b.m_e3_e1, // e3_e1
			-1.0 // e2_e1_e3_e0
		);

}
inline vector subtract(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1-b.m_e1), // e1
			(a.m_e2-b.m_e2), // e2
			(a.m_e3-b.m_e3) // e3
		);

}
inline bivector subtract(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline plane subtract(const plane &a, const plane &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2_e0-b.m_e1_e2_e0), // e1_e2_e0
			(a.m_e2_e3_e0-b.m_e2_e3_e0), // e2_e3_e0
			-(-a.m_e3_e1_e0+b.m_e3_e1_e0), // e3_e1_e0
			(a.m_e1_e2_e3-b.m_e1_e2_e3) // e1_e2_e3
		);

}
inline line subtract(const line &a, const line &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e0_e1+b.m_e0_e1), // e0_e1
			-(-a.m_e0_e2+b.m_e0_e2), // e0_e2
			-(-a.m_e0_e3+b.m_e0_e3), // e0_e3
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline vector subtract(const normalizedPoint &a, const normalizedPoint &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1-b.m_e1), // e1
			(a.m_e2-b.m_e2), // e2
			(a.m_e3-b.m_e3) // e3
		);

}
inline evenVersor subtract(const I4_t &a, const bivector &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			-b.m_e1_e2, // e1_e2
			-b.m_e2_e3, // e2_e3
			-b.m_e3_e1, // e3_e1
			-1.0 // e2_e1_e3_e0
		);

}
inline vector applyUnitVersor(const rotor &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3) // e3
		);
}
inline point applyUnitVersor(const rotor &a, const normalizedPoint &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // e0
		);
}
inline point applyUnitVersor(const rotor &a, const point &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2*b.m_e0+a.m_e2_e3*a.m_e2_e3*b.m_e0+a.m_e3_e1*a.m_e3_e1*b.m_e0+a.m_scalar*a.m_scalar*b.m_e0) // e0
		);
}
inline bivector applyUnitVersor(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline line applyUnitVersor(const rotor &a, const line &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(a.m_e1_e2*a.m_e1_e2*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e2-a.m_e2_e3*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e1+2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e3-a.m_scalar*a.m_scalar*b.m_e0_e1), // e0_e1
			-(a.m_e1_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e1+a.m_e2_e3*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e3-a.m_e3_e1*a.m_e3_e1*b.m_e0_e2-a.m_scalar*a.m_scalar*b.m_e0_e2), // e0_e2
			-(-a.m_e1_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e1-a.m_scalar*a.m_scalar*b.m_e0_e3), // e0_e3
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline plane applyUnitVersor(const rotor &a, const plane &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1_e0-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_e0+a.m_scalar*a.m_scalar*b.m_e1_e2_e0), // e1_e2_e0
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1_e0+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_e0+a.m_scalar*a.m_scalar*b.m_e2_e3_e0), // e2_e3_e0
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1_e0+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_e0+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_e0-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1_e0-a.m_scalar*a.m_scalar*b.m_e3_e1_e0), // e3_e1_e0
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3) // e1_e2_e3
		);
}
inline vector applyUnitVersor(const rotor &a, const e1_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar), // e1
			(-2.0*a.m_e1_e2*a.m_scalar+2.0*a.m_e2_e3*a.m_e3_e1), // e2
			(2.0*a.m_e1_e2*a.m_e2_e3+2.0*a.m_e3_e1*a.m_scalar) // e3
		);
}
inline pseudoscalar applyUnitVersor(const rotor &a, const I4_t &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // e2_e1_e3_e0
		);
}
inline point applyUnitVersor(const evenVersor &a, const vector &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1-a.m_e0_e3*a.m_e0_e3*b.m_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2) // e0
		);
}
inline point applyUnitVersor(const evenVersor &a, const normalizedPoint &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e1*a.m_scalar+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e1_e2+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e2*a.m_scalar+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e0_e3*a.m_e2_e3-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e3*a.m_scalar+a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(-a.m_e0_e1*a.m_e0_e1+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1-a.m_e0_e2*a.m_e0_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2-a.m_e0_e3*a.m_e0_e3+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // e0
		);
}
inline point applyUnitVersor(const evenVersor &a, const point &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e2*a.m_scalar*b.m_e0+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0-a.m_e0_e3*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e3*a.m_scalar*b.m_e0+a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(-a.m_e0_e1*a.m_e0_e1*b.m_e0+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1-a.m_e0_e2*a.m_e0_e2*b.m_e0+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2-a.m_e0_e3*a.m_e0_e3*b.m_e0+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+a.m_e1_e2*a.m_e1_e2*b.m_e0+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0+a.m_e3_e1*a.m_e3_e1*b.m_e0+a.m_scalar*a.m_scalar*b.m_e0) // e0
		);
}
inline line applyUnitVersor(const evenVersor &a, const bivector &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e2_e3), // e0_e1
			-(2.0*a.m_e0_e1*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e0_e3*a.m_scalar*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e3_e1), // e0_e2
			-(-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e1_e2), // e0_e3
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1_e2+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e0_e1*a.m_e0_e1*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e0_e3*a.m_e0_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e0_e1*a.m_e0_e1*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2+a.m_e0_e3*a.m_e0_e3*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline line applyUnitVersor(const evenVersor &a, const line &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e0_e1*a.m_e0_e1*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2+a.m_e0_e3*a.m_e0_e3*b.m_e0_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e0_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_scalar*b.m_e3_e1+a.m_e1_e2*a.m_e1_e2*b.m_e0_e1+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e1+2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e3-a.m_scalar*a.m_scalar*b.m_e0_e1), // e0_e1
			-(a.m_e0_e1*a.m_e0_e1*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e0_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e3_e1+a.m_e0_e3*a.m_e0_e3*b.m_e0_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e0_e3*a.m_scalar*b.m_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e3-a.m_e3_e1*a.m_e3_e1*b.m_e0_e2-a.m_scalar*a.m_scalar*b.m_e0_e2), // e0_e2
			-(a.m_e0_e1*a.m_e0_e1*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_scalar*b.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e0_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_scalar*b.m_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e3+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e1-a.m_scalar*a.m_scalar*b.m_e0_e3), // e0_e3
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0_e2-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e0_e1+a.m_e0_e3*a.m_e0_e3*b.m_e1_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e3+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0_e1+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0_e2+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e0_e1*a.m_e0_e1*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0_e2-a.m_e0_e2*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_scalar*b.m_e0_e3-a.m_e0_e3*a.m_e0_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e0_e3*a.m_scalar*b.m_e0_e2-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e0_e1*a.m_e0_e1*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0_e3-a.m_e0_e2*a.m_e0_e2*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e2+a.m_e0_e3*a.m_e0_e3*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e0_e3*a.m_scalar*b.m_e0_e1+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e2+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline plane applyUnitVersor(const evenVersor &a, const plane &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e0_e1*a.m_e0_e1*b.m_e1_e2_e0+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3_e0+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_e0_e2*a.m_e0_e2*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1_e0+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e1_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e1_e2_e0+2.0*a.m_e0_e3*a.m_scalar*b.m_e1_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2_e0-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_e0+a.m_scalar*a.m_scalar*b.m_e1_e2_e0), // e1_e2_e0
			(-a.m_e0_e1*a.m_e0_e1*b.m_e2_e3_e0+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1_e0+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2_e0+2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2_e3+a.m_e0_e2*a.m_e0_e2*b.m_e2_e3_e0+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e0+a.m_e0_e3*a.m_e0_e3*b.m_e2_e3_e0+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2_e3-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_e0+a.m_scalar*a.m_scalar*b.m_e2_e3_e0), // e2_e3_e0
			-(-a.m_e0_e1*a.m_e0_e1*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3_e0+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2_e0+a.m_e0_e2*a.m_e0_e2*b.m_e3_e1_e0+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e3_e1_e0+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1_e0+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_e0+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_e0-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1_e0-a.m_scalar*a.m_scalar*b.m_e3_e1_e0), // e3_e1_e0
			(-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2_e3+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e1_e2_e0+-2.0*a.m_e0_e1*a.m_scalar*b.m_e2_e3_e0-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2_e3+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e2_e3_e0+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_scalar*b.m_e3_e1_e0-a.m_e0_e3*a.m_e0_e3*b.m_e1_e2_e3+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e0_e3*a.m_scalar*b.m_e1_e2_e0+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e2_e3_e0+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e3_e1_e0+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3) // e1_e2_e3
		);
}
inline point applyUnitVersor(const evenVersor &a, const e3_t &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-2.0*a.m_e0_e1*a.m_e0_e3+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar), // e1
			(2.0*a.m_e0_e1*a.m_e2_e1_e3_e0+-2.0*a.m_e0_e2*a.m_e0_e3+2.0*a.m_e1_e2*a.m_e3_e1+2.0*a.m_e2_e3*a.m_scalar), // e2
			(a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2-a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar), // e3
			(-2.0*a.m_e0_e1*a.m_e3_e1+2.0*a.m_e0_e2*a.m_e2_e3+2.0*a.m_e0_e3*a.m_scalar+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0) // e0
		);
}
inline pseudoscalar applyUnitVersor(const evenVersor &a, const I4i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-(a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // e2_e1_e3_e0
		);
}
inline point applyUnitVersor(const oddVersor &a, const vector &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*a.m_e0*b.m_e1+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1), // e1
			(-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2), // e2
			(-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3), // e3
			(2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1) // e0
		);
}
inline point applyUnitVersor(const oddVersor &a, const normalizedPoint &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*a.m_e0*b.m_e1+2.0*a.m_e0*a.m_e1+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e1_e2_e0*a.m_e2+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_e3_e1_e0+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1), // e1
			(-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e0*a.m_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e2_e3_e0*a.m_e3+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2), // e2
			(-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e0*a.m_e3+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_e3_e1_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+-2.0*a.m_e2*a.m_e2_e3_e0+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3), // e3
			(a.m_e0*a.m_e0+2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3-a.m_e1*a.m_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1-a.m_e1_e2_e3*a.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2-a.m_e2*a.m_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2-a.m_e3*a.m_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0) // e0
		);
}
inline point applyUnitVersor(const oddVersor &a, const point &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*a.m_e0*b.m_e1+2.0*a.m_e0*a.m_e1*b.m_e0+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1), // e1
			(-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e0+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2), // e2
			(-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e0+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3), // e3
			(a.m_e0*a.m_e0*b.m_e0+2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3-a.m_e1*a.m_e1*b.m_e0+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2-a.m_e2*a.m_e2*b.m_e0+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2-a.m_e3*a.m_e3*b.m_e0+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0) // e0
		);
}
inline line applyUnitVersor(const oddVersor &a, const bivector &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e0*a.m_e2*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2), // e0_e1
			-(2.0*a.m_e0*a.m_e1*b.m_e1_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e0*a.m_e3*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2*a.m_e3_e1_e0*b.m_e3_e1+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2), // e0_e2
			-(-2.0*a.m_e0*a.m_e1*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e1_e2+2.0*a.m_e0*a.m_e2*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2_e3+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e3_e1), // e0_e3
			(a.m_e0*a.m_e0*b.m_e1_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e3*a.m_e3*b.m_e1_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2), // e1_e2
			(a.m_e0*a.m_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1-a.m_e2*a.m_e2*b.m_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3*a.m_e3*b.m_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3), // e2_e3
			-(-a.m_e0*a.m_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e3_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1) // e3_e1
		);
}
inline line applyUnitVersor(const oddVersor &a, const line &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(a.m_e0*a.m_e0*b.m_e0_e1+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e0_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e0*a.m_e2*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e3_e1+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e0_e3+a.m_e1*a.m_e1*b.m_e0_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e2*b.m_e0_e2+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e3*b.m_e0_e3+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3_e1-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e2_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e0_e2+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2-a.m_e2*a.m_e2*b.m_e0_e1+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e0_e2-a.m_e3*a.m_e3*b.m_e0_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e1), // e0_e1
			-(a.m_e0*a.m_e0*b.m_e0_e2+2.0*a.m_e0*a.m_e1*b.m_e1_e2+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e0_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e0*a.m_e3*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e0_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e0_e3+2.0*a.m_e1*a.m_e2*b.m_e0_e1+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e0_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e0_e1+a.m_e2*a.m_e2*b.m_e0_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2*a.m_e3*b.m_e0_e3+2.0*a.m_e2*a.m_e3_e1_e0*b.m_e3_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e2+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e0_e1-a.m_e3*a.m_e3*b.m_e0_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e2), // e0_e2
			-(a.m_e0*a.m_e0*b.m_e0_e3+-2.0*a.m_e0*a.m_e1*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e1_e2+2.0*a.m_e0*a.m_e2*b.m_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e0_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e0_e1-a.m_e1*a.m_e1*b.m_e0_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e3*b.m_e0_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e0_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e0_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e0_e3+2.0*a.m_e2*a.m_e3*b.m_e0_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e1_e2-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e0_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e3), // e0_e3
			(a.m_e0*a.m_e0*b.m_e1_e2+-2.0*a.m_e0*a.m_e1*b.m_e0_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e3+2.0*a.m_e0*a.m_e2*b.m_e0_e1+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e3+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0_e1-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e3-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0_e1+a.m_e3*a.m_e3*b.m_e1_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2), // e1_e2
			(a.m_e0*a.m_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e1+-2.0*a.m_e0*a.m_e2*b.m_e0_e3+2.0*a.m_e0*a.m_e3*b.m_e0_e2+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0_e2-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0_e3-a.m_e2*a.m_e2*b.m_e2_e3+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e1+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0_e3+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3*a.m_e3*b.m_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3), // e2_e3
			-(-a.m_e0*a.m_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e1*b.m_e0_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e0_e1+a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1) // e3_e1
		);
}
inline plane applyUnitVersor(const oddVersor &a, const plane &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e0*a.m_e0*b.m_e1_e2_e0+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e3*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3_e0+a.m_e1*a.m_e1*b.m_e1_e2_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3*b.m_e2_e3_e0+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e1_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1_e0-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3_e0+a.m_e2*a.m_e2*b.m_e1_e2_e0+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2*a.m_e3*b.m_e3_e1_e0-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e3*a.m_e3*b.m_e1_e2_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2_e0), // e1_e2_e0
			(a.m_e0*a.m_e0*b.m_e2_e3_e0+2.0*a.m_e0*a.m_e1*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2_e0-a.m_e1*a.m_e1*b.m_e2_e3_e0+-2.0*a.m_e1*a.m_e2*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3*b.m_e1_e2_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e2_e3_e0+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1_e0+a.m_e3*a.m_e3*b.m_e2_e3_e0+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3_e0), // e2_e3_e0
			-(-a.m_e0*a.m_e0*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3_e0+-2.0*a.m_e0*a.m_e2*b.m_e1_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e1*a.m_e1*b.m_e3_e1_e0+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2_e3+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1*a.m_e2*b.m_e2_e3_e0+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1_e0+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2_e3+a.m_e2*a.m_e2*b.m_e3_e1_e0+2.0*a.m_e2*a.m_e3*b.m_e1_e2_e0+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2_e3+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3_e0-a.m_e3*a.m_e3*b.m_e3_e1_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1_e0), // e3_e1_e0
			(-a.m_e0*a.m_e0*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e1*b.m_e2_e3_e0+2.0*a.m_e0*a.m_e2*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e3*b.m_e1_e2_e0+a.m_e1*a.m_e1*b.m_e1_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e1_e2_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e2_e3_e0+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e1_e2_e3+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e3_e1_e0+a.m_e3*a.m_e3*b.m_e1_e2_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e2_e3_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2_e3) // e1_e2_e3
		);
}
inline vector applyVersor(const rotor &a, const vector &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return vector(vector::coord_e1_e2_e3,
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_) // e3
		);
}
inline point applyVersor(const rotor &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // e0
		);
}
inline point applyVersor(const rotor &a, const point &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2*b.m_e0+a.m_e2_e3*a.m_e2_e3*b.m_e0+a.m_e3_e1*a.m_e3_e1*b.m_e0+a.m_scalar*a.m_scalar*b.m_e0))/(_n2_) // e0
		);
}
inline bivector applyVersor(const rotor &a, const bivector &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline line applyVersor(const rotor &a, const line &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e2-a.m_e2_e3*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e1+2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e3-a.m_scalar*a.m_scalar*b.m_e0_e1))/(_n2_), // e0_e1
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e1+a.m_e2_e3*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e3-a.m_e3_e1*a.m_e3_e1*b.m_e0_e2-a.m_scalar*a.m_scalar*b.m_e0_e2))/(_n2_), // e0_e2
			(-(-a.m_e1_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e1-a.m_scalar*a.m_scalar*b.m_e0_e3))/(_n2_), // e0_e3
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline plane applyVersor(const rotor &a, const plane &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1_e0-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_e0+a.m_scalar*a.m_scalar*b.m_e1_e2_e0))/(_n2_), // e1_e2_e0
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1_e0+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_e0+a.m_scalar*a.m_scalar*b.m_e2_e3_e0))/(_n2_), // e2_e3_e0
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1_e0+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_e0+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_e0-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1_e0-a.m_scalar*a.m_scalar*b.m_e3_e1_e0))/(_n2_), // e3_e1_e0
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3))/(_n2_) // e1_e2_e3
		);
}
inline point applyVersor(const evenVersor &a, const vector &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1-a.m_e0_e3*a.m_e0_e3*b.m_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2))/(_n2_) // e0
		);
}
inline point applyVersor(const evenVersor &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e1*a.m_scalar+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e1_e2+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e2*a.m_scalar+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e0_e3*a.m_e2_e3-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e3*a.m_scalar+a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((-a.m_e0_e1*a.m_e0_e1+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1-a.m_e0_e2*a.m_e0_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2-a.m_e0_e3*a.m_e0_e3+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // e0
		);
}
inline point applyVersor(const evenVersor &a, const point &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0+a.m_e0_e2*a.m_e0_e2*b.m_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((a.m_e0_e1*a.m_e0_e1*b.m_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e1+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3-a.m_e0_e2*a.m_e0_e2*b.m_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e2*a.m_scalar*b.m_e0+a.m_e0_e3*a.m_e0_e3*b.m_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e1+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e0_e1*a.m_e0_e1*b.m_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0+a.m_e0_e2*a.m_e0_e2*b.m_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e2+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0-a.m_e0_e3*a.m_e0_e3*b.m_e3+-2.0*a.m_e0_e3*a.m_scalar*b.m_e0+a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((-a.m_e0_e1*a.m_e0_e1*b.m_e0+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e0_e1*a.m_scalar*b.m_e1-a.m_e0_e2*a.m_e0_e2*b.m_e0+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e2-a.m_e0_e3*a.m_e0_e3*b.m_e0+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e0_e3*a.m_scalar*b.m_e3+a.m_e1_e2*a.m_e1_e2*b.m_e0+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0+a.m_e3_e1*a.m_e3_e1*b.m_e0+a.m_scalar*a.m_scalar*b.m_e0))/(_n2_) // e0
		);
}
inline line applyVersor(const evenVersor &a, const bivector &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			(-(-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e2_e3))/(_n2_), // e0_e1
			(-(2.0*a.m_e0_e1*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e0_e3*a.m_scalar*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e3_e1))/(_n2_), // e0_e2
			(-(-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e1_e2))/(_n2_), // e0_e3
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e0_e3*a.m_e0_e3*b.m_e1_e2+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((a.m_e0_e1*a.m_e0_e1*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e0_e3*a.m_e0_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e0_e1*a.m_e0_e1*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2+a.m_e0_e3*a.m_e0_e3*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline line applyVersor(const evenVersor &a, const line &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			(-(-a.m_e0_e1*a.m_e0_e1*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2+a.m_e0_e3*a.m_e0_e3*b.m_e0_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e0_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_scalar*b.m_e3_e1+a.m_e1_e2*a.m_e1_e2*b.m_e0_e1+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e1+2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e3-a.m_scalar*a.m_scalar*b.m_e0_e1))/(_n2_), // e0_e1
			(-(a.m_e0_e1*a.m_e0_e1*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e0_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2-a.m_e0_e2*a.m_e0_e2*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e3_e1+a.m_e0_e3*a.m_e0_e3*b.m_e0_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e0_e3*a.m_scalar*b.m_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e0_e1-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e3-a.m_e3_e1*a.m_e3_e1*b.m_e0_e2-a.m_scalar*a.m_scalar*b.m_e0_e2))/(_n2_), // e0_e2
			(-(a.m_e0_e1*a.m_e0_e1*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_scalar*b.m_e3_e1+a.m_e0_e2*a.m_e0_e2*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e0_e1+2.0*a.m_e0_e2*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_scalar*b.m_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e0_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e1_e2+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e3_e1-a.m_e1_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e0_e2-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e0_e3+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e3*a.m_scalar*b.m_e0_e2+a.m_e3_e1*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e0_e1-a.m_scalar*a.m_scalar*b.m_e0_e3))/(_n2_), // e0_e3
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e3+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0_e2-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e0_e2*a.m_scalar*b.m_e0_e1+a.m_e0_e3*a.m_e0_e3*b.m_e1_e2+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e3+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0_e1+2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0_e2+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((a.m_e0_e1*a.m_e0_e1*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1+2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e0_e3+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e1+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0_e2-a.m_e0_e2*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_scalar*b.m_e0_e3-a.m_e0_e3*a.m_e0_e3*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e1+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e0_e3*a.m_scalar*b.m_e0_e2-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3+2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e0_e3+-2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e0_e1*a.m_e0_e1*b.m_e3_e1+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3+2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2+2.0*a.m_e0_e1*a.m_e2_e3*b.m_e0_e2+-2.0*a.m_e0_e1*a.m_e3_e1*b.m_e0_e1+-2.0*a.m_e0_e1*a.m_scalar*b.m_e0_e3-a.m_e0_e2*a.m_e0_e2*b.m_e3_e1+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2+-2.0*a.m_e0_e2*a.m_e1_e2*b.m_e0_e3+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e0_e1+-2.0*a.m_e0_e2*a.m_e3_e1*b.m_e0_e2+a.m_e0_e3*a.m_e0_e3*b.m_e3_e1+2.0*a.m_e0_e3*a.m_e1_e2*b.m_e0_e2+-2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e0_e3+2.0*a.m_e0_e3*a.m_scalar*b.m_e0_e1+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e0_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e0_e3+2.0*a.m_e2_e1_e3_e0*a.m_scalar*b.m_e0_e2+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline plane applyVersor(const evenVersor &a, const plane &b)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			((a.m_e0_e1*a.m_e0_e1*b.m_e1_e2_e0+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e2_e3_e0+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_e0_e2*a.m_e0_e2*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_e0_e3*b.m_e3_e1_e0+2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e1_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e1_e2_e0+2.0*a.m_e0_e3*a.m_scalar*b.m_e1_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2_e0-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_e0+a.m_scalar*a.m_scalar*b.m_e1_e2_e0))/(_n2_), // e1_e2_e0
			((-a.m_e0_e1*a.m_e0_e1*b.m_e2_e3_e0+-2.0*a.m_e0_e1*a.m_e0_e2*b.m_e3_e1_e0+-2.0*a.m_e0_e1*a.m_e0_e3*b.m_e1_e2_e0+2.0*a.m_e0_e1*a.m_scalar*b.m_e1_e2_e3+a.m_e0_e2*a.m_e0_e2*b.m_e2_e3_e0+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e0_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e0+a.m_e0_e3*a.m_e0_e3*b.m_e2_e3_e0+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e1_e2_e3-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_e0+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_e0+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1_e0-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_e0+a.m_scalar*a.m_scalar*b.m_e2_e3_e0))/(_n2_), // e2_e3_e0
			(-(-a.m_e0_e1*a.m_e0_e1*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e0_e2*b.m_e2_e3_e0+2.0*a.m_e0_e1*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e0_e1*a.m_e2_e1_e3_e0*b.m_e1_e2_e0+a.m_e0_e2*a.m_e0_e2*b.m_e3_e1_e0+2.0*a.m_e0_e2*a.m_e0_e3*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_scalar*b.m_e1_e2_e3-a.m_e0_e3*a.m_e0_e3*b.m_e3_e1_e0+2.0*a.m_e0_e3*a.m_e2_e1_e3_e0*b.m_e2_e3_e0+-2.0*a.m_e0_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e1_e2*a.m_e1_e2*b.m_e3_e1_e0+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_e0+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_e0+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_e0-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1_e0-a.m_scalar*a.m_scalar*b.m_e3_e1_e0))/(_n2_), // e3_e1_e0
			((-a.m_e0_e1*a.m_e0_e1*b.m_e1_e2_e3+-2.0*a.m_e0_e1*a.m_e1_e2*b.m_e3_e1_e0+2.0*a.m_e0_e1*a.m_e3_e1*b.m_e1_e2_e0+-2.0*a.m_e0_e1*a.m_scalar*b.m_e2_e3_e0-a.m_e0_e2*a.m_e0_e2*b.m_e1_e2_e3+2.0*a.m_e0_e2*a.m_e1_e2*b.m_e2_e3_e0+-2.0*a.m_e0_e2*a.m_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e0_e2*a.m_scalar*b.m_e3_e1_e0-a.m_e0_e3*a.m_e0_e3*b.m_e1_e2_e3+2.0*a.m_e0_e3*a.m_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e0_e3*a.m_e3_e1*b.m_e2_e3_e0+-2.0*a.m_e0_e3*a.m_scalar*b.m_e1_e2_e0+a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+-2.0*a.m_e1_e2*a.m_e2_e1_e3_e0*b.m_e1_e2_e0-a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2_e1_e3_e0*a.m_e2_e3*b.m_e2_e3_e0+-2.0*a.m_e2_e1_e3_e0*a.m_e3_e1*b.m_e3_e1_e0+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3))/(_n2_) // e1_e2_e3
		);
}
inline point applyVersor(const oddVersor &a, const vector &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0*a.m_e0*b.m_e1+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1))/(_n2_), // e1
			((-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2))/(_n2_), // e2
			((-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3))/(_n2_), // e3
			((2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1))/(_n2_) // e0
		);
}
inline point applyVersor(const oddVersor &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0*a.m_e0*b.m_e1+2.0*a.m_e0*a.m_e1+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e1_e2_e0*a.m_e2+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_e3_e1_e0+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1))/(_n2_), // e1
			((-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e0*a.m_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e2_e3_e0*a.m_e3+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2))/(_n2_), // e2
			((-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e0*a.m_e3+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_e3_e1_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+-2.0*a.m_e2*a.m_e2_e3_e0+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3))/(_n2_), // e3
			((a.m_e0*a.m_e0+2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3-a.m_e1*a.m_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1-a.m_e1_e2_e3*a.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2-a.m_e2*a.m_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2-a.m_e3*a.m_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0))/(_n2_) // e0
		);
}
inline point applyVersor(const oddVersor &a, const point &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return point(point::coord_e1_e2_e3_e0,
			((-a.m_e0*a.m_e0*b.m_e1+2.0*a.m_e0*a.m_e1*b.m_e0+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1))/(_n2_), // e1
			((-a.m_e0*a.m_e0*b.m_e2+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e0+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e1-a.m_e3*a.m_e3*b.m_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2))/(_n2_), // e2
			((-a.m_e0*a.m_e0*b.m_e3+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e0+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0+-2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e2*a.m_e2*b.m_e3+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3+a.m_e3*a.m_e3*b.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3))/(_n2_), // e3
			((a.m_e0*a.m_e0*b.m_e0+2.0*a.m_e0*a.m_e1*b.m_e1+2.0*a.m_e0*a.m_e2*b.m_e2+2.0*a.m_e0*a.m_e3*b.m_e3-a.m_e1*a.m_e1*b.m_e0+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2-a.m_e2*a.m_e2*b.m_e0+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2-a.m_e3*a.m_e3*b.m_e0+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0))/(_n2_) // e0
		);
}
inline line applyVersor(const oddVersor &a, const bivector &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			(-(-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e0*a.m_e2*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2))/(_n2_), // e0_e1
			(-(2.0*a.m_e0*a.m_e1*b.m_e1_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e0*a.m_e3*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2*a.m_e3_e1_e0*b.m_e3_e1+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2))/(_n2_), // e0_e2
			(-(-2.0*a.m_e0*a.m_e1*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e1_e2+2.0*a.m_e0*a.m_e2*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2_e3+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e3_e1))/(_n2_), // e0_e3
			((a.m_e0*a.m_e0*b.m_e1_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e3*a.m_e3*b.m_e1_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2))/(_n2_), // e1_e2
			((a.m_e0*a.m_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1-a.m_e2*a.m_e2*b.m_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3*a.m_e3*b.m_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3))/(_n2_), // e2_e3
			(-(-a.m_e0*a.m_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e3_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline line applyVersor(const oddVersor &a, const line &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			(-(a.m_e0*a.m_e0*b.m_e0_e1+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e0_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e0*a.m_e2*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e3_e1+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e0_e3+a.m_e1*a.m_e1*b.m_e0_e1+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e2*b.m_e0_e2+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e3*b.m_e0_e3+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e3_e1-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e2_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e0_e2+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2-a.m_e2*a.m_e2*b.m_e0_e1+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e0_e2-a.m_e3*a.m_e3*b.m_e0_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e1))/(_n2_), // e0_e1
			(-(a.m_e0*a.m_e0*b.m_e0_e2+2.0*a.m_e0*a.m_e1*b.m_e1_e2+-2.0*a.m_e0*a.m_e1_e2_e0*b.m_e0_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e0*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e0*a.m_e3*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e0_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e0_e3+2.0*a.m_e1*a.m_e2*b.m_e0_e1+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e0_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e0_e1+a.m_e2*a.m_e2*b.m_e0_e2+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2*a.m_e3*b.m_e0_e3+2.0*a.m_e2*a.m_e3_e1_e0*b.m_e3_e1-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e2+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e0_e1-a.m_e3*a.m_e3*b.m_e0_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2+a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e2))/(_n2_), // e0_e2
			(-(a.m_e0*a.m_e0*b.m_e0_e3+-2.0*a.m_e0*a.m_e1*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e1_e2+2.0*a.m_e0*a.m_e2*b.m_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e0_e2+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e0_e1-a.m_e1*a.m_e1*b.m_e0_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e1*a.m_e3*b.m_e0_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e0_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e0_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e0_e3+2.0*a.m_e2*a.m_e3*b.m_e0_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e1_e2-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e0_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e0_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e0_e3))/(_n2_), // e0_e3
			((a.m_e0*a.m_e0*b.m_e1_e2+-2.0*a.m_e0*a.m_e1*b.m_e0_e2+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e3+2.0*a.m_e0*a.m_e2*b.m_e0_e1+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e3+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0_e1-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e3-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0_e1+a.m_e3*a.m_e3*b.m_e1_e2+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0_e2-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2))/(_n2_), // e1_e2
			((a.m_e0*a.m_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e1+-2.0*a.m_e0*a.m_e2*b.m_e0_e3+2.0*a.m_e0*a.m_e3*b.m_e0_e2+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2+a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e0_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0_e2-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0_e2+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2+-2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e0_e3-a.m_e2*a.m_e2*b.m_e2_e3+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e1+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3+2.0*a.m_e2_e3_e0*a.m_e3*b.m_e0_e3+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1-a.m_e3*a.m_e3*b.m_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3))/(_n2_), // e2_e3
			(-(-a.m_e0*a.m_e0*b.m_e3_e1+-2.0*a.m_e0*a.m_e1*b.m_e0_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3+2.0*a.m_e0*a.m_e1_e2_e3*b.m_e0_e2+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2+2.0*a.m_e0*a.m_e3*b.m_e0_e1+a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3+2.0*a.m_e1*a.m_e2_e3_e0*b.m_e0_e2+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e0_e1+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1+-2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e0_e1+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e0_e3+2.0*a.m_e1_e2_e0*a.m_e3*b.m_e0_e2+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e0_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e0_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+-2.0*a.m_e2*a.m_e3_e1_e0*b.m_e0_e2+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3+a.m_e3*a.m_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e0_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline plane applyVersor(const oddVersor &a, const plane &b)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			((a.m_e0*a.m_e0*b.m_e1_e2_e0+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e3*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e3_e1_e0*b.m_e2_e3_e0+a.m_e1*a.m_e1*b.m_e1_e2_e0+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3*b.m_e2_e3_e0+2.0*a.m_e1*a.m_e3_e1_e0*b.m_e1_e2_e3+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2_e0+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e3_e1_e0-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3_e0+a.m_e2*a.m_e2*b.m_e1_e2_e0+-2.0*a.m_e2*a.m_e2_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2*a.m_e3*b.m_e3_e1_e0-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e3*a.m_e3*b.m_e1_e2_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2_e0))/(_n2_), // e1_e2_e0
			((a.m_e0*a.m_e0*b.m_e2_e3_e0+2.0*a.m_e0*a.m_e1*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e0*a.m_e3_e1_e0*b.m_e1_e2_e0-a.m_e1*a.m_e1*b.m_e2_e3_e0+-2.0*a.m_e1*a.m_e2*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3*b.m_e1_e2_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e0*a.m_e2*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2_e0+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e2_e3_e0+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e3_e1_e0+a.m_e3*a.m_e3*b.m_e2_e3_e0+-2.0*a.m_e3*a.m_e3_e1_e0*b.m_e1_e2_e3-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e2_e3_e0))/(_n2_), // e2_e3_e0
			(-(-a.m_e0*a.m_e0*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e1_e2_e0*b.m_e2_e3_e0+-2.0*a.m_e0*a.m_e2*b.m_e1_e2_e3+-2.0*a.m_e0*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e1*a.m_e1*b.m_e3_e1_e0+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e1_e2_e3+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2_e0+2.0*a.m_e1*a.m_e2*b.m_e2_e3_e0+a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e1_e2_e0*a.m_e3_e1_e0*b.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1_e0+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3_e0+-2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e1_e2_e3+a.m_e2*a.m_e2*b.m_e3_e1_e0+2.0*a.m_e2*a.m_e3*b.m_e1_e2_e0+a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e3_e1_e0+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e1_e2_e3+-2.0*a.m_e2_e3_e0*a.m_e3_e1_e0*b.m_e2_e3_e0-a.m_e3*a.m_e3*b.m_e3_e1_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e3_e1_e0))/(_n2_), // e3_e1_e0
			((-a.m_e0*a.m_e0*b.m_e1_e2_e3+2.0*a.m_e0*a.m_e1*b.m_e2_e3_e0+2.0*a.m_e0*a.m_e2*b.m_e3_e1_e0+2.0*a.m_e0*a.m_e3*b.m_e1_e2_e0+a.m_e1*a.m_e1*b.m_e1_e2_e3+2.0*a.m_e1*a.m_e1_e2_e0*b.m_e3_e1_e0+-2.0*a.m_e1*a.m_e3_e1_e0*b.m_e1_e2_e0-a.m_e1_e2_e0*a.m_e1_e2_e0*b.m_e1_e2_e3+2.0*a.m_e1_e2_e0*a.m_e1_e2_e3*b.m_e1_e2_e0+-2.0*a.m_e1_e2_e0*a.m_e2*b.m_e2_e3_e0+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_e0*b.m_e2_e3_e0+2.0*a.m_e1_e2_e3*a.m_e3_e1_e0*b.m_e3_e1_e0+a.m_e2*a.m_e2*b.m_e1_e2_e3+2.0*a.m_e2*a.m_e2_e3_e0*b.m_e1_e2_e0-a.m_e2_e3_e0*a.m_e2_e3_e0*b.m_e1_e2_e3+-2.0*a.m_e2_e3_e0*a.m_e3*b.m_e3_e1_e0+a.m_e3*a.m_e3*b.m_e1_e2_e3+2.0*a.m_e3*a.m_e3_e1_e0*b.m_e2_e3_e0-a.m_e3_e1_e0*a.m_e3_e1_e0*b.m_e1_e2_e3))/(_n2_) // e1_e2_e3
		);
}
inline vector applyVersorWI(const rotor &a, const vector &b, const rotor &c)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar) // e3
		);
}
inline point applyVersorWI(const rotor &a, const normalizedPoint &b, const rotor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(-a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar) // e0
		);
}
inline point applyVersorWI(const rotor &a, const point &b, const rotor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(-a.m_e1_e2*b.m_e0*c.m_e1_e2-a.m_e2_e3*b.m_e0*c.m_e2_e3-a.m_e3_e1*b.m_e0*c.m_e3_e1+a.m_scalar*b.m_e0*c.m_scalar) // e0
		);
}
inline bivector applyVersorWI(const rotor &a, const bivector &b, const rotor &c)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline line applyVersorWI(const rotor &a, const line &b, const rotor &c)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e1_e2*b.m_e0_e1*c.m_e1_e2-a.m_e1_e2*b.m_e0_e2*c.m_scalar+a.m_e1_e2*b.m_e0_e3*c.m_e2_e3+a.m_e2_e3*b.m_e0_e1*c.m_e2_e3+a.m_e2_e3*b.m_e0_e2*c.m_e3_e1+a.m_e2_e3*b.m_e0_e3*c.m_e1_e2-a.m_e3_e1*b.m_e0_e1*c.m_e3_e1+a.m_e3_e1*b.m_e0_e2*c.m_e2_e3+a.m_e3_e1*b.m_e0_e3*c.m_scalar-a.m_scalar*b.m_e0_e1*c.m_scalar+a.m_scalar*b.m_e0_e2*c.m_e1_e2-a.m_scalar*b.m_e0_e3*c.m_e3_e1), // e0_e1
			-(a.m_e1_e2*b.m_e0_e1*c.m_scalar-a.m_e1_e2*b.m_e0_e2*c.m_e1_e2+a.m_e1_e2*b.m_e0_e3*c.m_e3_e1+a.m_e2_e3*b.m_e0_e1*c.m_e3_e1-a.m_e2_e3*b.m_e0_e2*c.m_e2_e3-a.m_e2_e3*b.m_e0_e3*c.m_scalar+a.m_e3_e1*b.m_e0_e1*c.m_e2_e3+a.m_e3_e1*b.m_e0_e2*c.m_e3_e1+a.m_e3_e1*b.m_e0_e3*c.m_e1_e2-a.m_scalar*b.m_e0_e1*c.m_e1_e2-a.m_scalar*b.m_e0_e2*c.m_scalar+a.m_scalar*b.m_e0_e3*c.m_e2_e3), // e0_e2
			-(a.m_e1_e2*b.m_e0_e1*c.m_e2_e3+a.m_e1_e2*b.m_e0_e2*c.m_e3_e1+a.m_e1_e2*b.m_e0_e3*c.m_e1_e2+a.m_e2_e3*b.m_e0_e1*c.m_e1_e2+a.m_e2_e3*b.m_e0_e2*c.m_scalar-a.m_e2_e3*b.m_e0_e3*c.m_e2_e3-a.m_e3_e1*b.m_e0_e1*c.m_scalar+a.m_e3_e1*b.m_e0_e2*c.m_e1_e2-a.m_e3_e1*b.m_e0_e3*c.m_e3_e1+a.m_scalar*b.m_e0_e1*c.m_e3_e1-a.m_scalar*b.m_e0_e2*c.m_e2_e3-a.m_scalar*b.m_e0_e3*c.m_scalar), // e0_e3
			(-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline plane applyVersorWI(const rotor &a, const plane &b, const rotor &c)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e1_e2*b.m_e1_e2_e0*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3_e0*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1_e0*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2_e0*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3_e0*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1_e0*c.m_scalar+a.m_e3_e1*b.m_e1_e2_e0*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3_e0*c.m_scalar-a.m_e3_e1*b.m_e3_e1_e0*c.m_e1_e2+a.m_scalar*b.m_e1_e2_e0*c.m_scalar-a.m_scalar*b.m_e2_e3_e0*c.m_e3_e1+a.m_scalar*b.m_e3_e1_e0*c.m_e2_e3), // e1_e2_e0
			(-a.m_e1_e2*b.m_e1_e2_e0*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3_e0*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1_e0*c.m_scalar-a.m_e2_e3*b.m_e1_e2_e0*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3_e0*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1_e0*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2_e0*c.m_scalar+a.m_e3_e1*b.m_e2_e3_e0*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1_e0*c.m_e2_e3+a.m_scalar*b.m_e1_e2_e0*c.m_e3_e1+a.m_scalar*b.m_e2_e3_e0*c.m_scalar-a.m_scalar*b.m_e3_e1_e0*c.m_e1_e2), // e2_e3_e0
			-(a.m_e1_e2*b.m_e1_e2_e0*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3_e0*c.m_scalar-a.m_e1_e2*b.m_e3_e1_e0*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2_e0*c.m_scalar+a.m_e2_e3*b.m_e2_e3_e0*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1_e0*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2_e0*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3_e0*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1_e0*c.m_e3_e1+a.m_scalar*b.m_e1_e2_e0*c.m_e2_e3-a.m_scalar*b.m_e2_e3_e0*c.m_e1_e2-a.m_scalar*b.m_e3_e1_e0*c.m_scalar), // e3_e1_e0
			(-a.m_e1_e2*b.m_e1_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2_e3*c.m_e2_e3-a.m_e3_e1*b.m_e1_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e1_e2_e3*c.m_scalar) // e1_e2_e3
		);
}
inline vector applyVersorWI(const rotor &a, const e2_t &b, const rotor &c)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*c.m_scalar-a.m_e2_e3*c.m_e3_e1-a.m_e3_e1*c.m_e2_e3-a.m_scalar*c.m_e1_e2), // e1
			(a.m_e1_e2*c.m_e1_e2+a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar), // e2
			(-a.m_e1_e2*c.m_e3_e1-a.m_e2_e3*c.m_scalar-a.m_e3_e1*c.m_e1_e2+a.m_scalar*c.m_e2_e3) // e3
		);
}
inline pseudoscalar applyVersorWI(const rotor &a, const I4_t &b, const rotor &c)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-(-a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar) // e2_e1_e3_e0
		);
}
inline point applyVersorWI(const evenVersor &a, const vector &b, const evenVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e0_e1*b.m_e1*c.m_e0_e1+a.m_e0_e1*b.m_e2*c.m_e0_e2+a.m_e0_e1*b.m_e3*c.m_e0_e3-a.m_e0_e2*b.m_e1*c.m_e0_e2+a.m_e0_e2*b.m_e2*c.m_e0_e1-a.m_e0_e2*b.m_e3*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e1*c.m_e0_e3+a.m_e0_e3*b.m_e2*c.m_e2_e1_e3_e0+a.m_e0_e3*b.m_e3*c.m_e0_e1+a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e2-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(a.m_e0_e1*b.m_e1*c.m_e0_e2-a.m_e0_e1*b.m_e2*c.m_e0_e1+a.m_e0_e1*b.m_e3*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e1*c.m_e0_e1+a.m_e0_e2*b.m_e2*c.m_e0_e2+a.m_e0_e2*b.m_e3*c.m_e0_e3-a.m_e0_e3*b.m_e1*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e2*c.m_e0_e3+a.m_e0_e3*b.m_e3*c.m_e0_e2-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(a.m_e0_e1*b.m_e1*c.m_e0_e3-a.m_e0_e1*b.m_e2*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e3*c.m_e0_e1+a.m_e0_e2*b.m_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e2*c.m_e0_e3-a.m_e0_e2*b.m_e3*c.m_e0_e2+a.m_e0_e3*b.m_e1*c.m_e0_e1+a.m_e0_e3*b.m_e2*c.m_e0_e2+a.m_e0_e3*b.m_e3*c.m_e0_e3-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(a.m_e0_e1*b.m_e1*c.m_scalar-a.m_e0_e1*b.m_e2*c.m_e1_e2+a.m_e0_e1*b.m_e3*c.m_e3_e1+a.m_e0_e2*b.m_e1*c.m_e1_e2+a.m_e0_e2*b.m_e2*c.m_scalar-a.m_e0_e2*b.m_e3*c.m_e2_e3-a.m_e0_e3*b.m_e1*c.m_e3_e1+a.m_e0_e3*b.m_e2*c.m_e2_e3+a.m_e0_e3*b.m_e3*c.m_scalar+a.m_e1_e2*b.m_e1*c.m_e0_e2-a.m_e1_e2*b.m_e2*c.m_e0_e1+a.m_e1_e2*b.m_e3*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e1_e2+a.m_e2_e3*b.m_e1*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e2*c.m_e0_e3-a.m_e2_e3*b.m_e3*c.m_e0_e2-a.m_e3_e1*b.m_e1*c.m_e0_e3+a.m_e3_e1*b.m_e2*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e3*c.m_e0_e1-a.m_scalar*b.m_e1*c.m_e0_e1-a.m_scalar*b.m_e2*c.m_e0_e2-a.m_scalar*b.m_e3*c.m_e0_e3) // e0
		);
}
inline point applyVersorWI(const evenVersor &a, const normalizedPoint &b, const evenVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e0_e1*b.m_e1*c.m_e0_e1+a.m_e0_e1*b.m_e2*c.m_e0_e2+a.m_e0_e1*b.m_e3*c.m_e0_e3-a.m_e0_e1*c.m_scalar-a.m_e0_e2*b.m_e1*c.m_e0_e2+a.m_e0_e2*b.m_e2*c.m_e0_e1-a.m_e0_e2*b.m_e3*c.m_e2_e1_e3_e0+a.m_e0_e2*c.m_e1_e2-a.m_e0_e3*b.m_e1*c.m_e0_e3+a.m_e0_e3*b.m_e2*c.m_e2_e1_e3_e0+a.m_e0_e3*b.m_e3*c.m_e0_e1-a.m_e0_e3*c.m_e3_e1+a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3+a.m_e1_e2*c.m_e0_e2-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e2+a.m_e2_e1_e3_e0*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2-a.m_e2_e3*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar-a.m_e3_e1*c.m_e0_e3+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1+a.m_scalar*c.m_e0_e1), // e1
			(a.m_e0_e1*b.m_e1*c.m_e0_e2-a.m_e0_e1*b.m_e2*c.m_e0_e1+a.m_e0_e1*b.m_e3*c.m_e2_e1_e3_e0-a.m_e0_e1*c.m_e1_e2+a.m_e0_e2*b.m_e1*c.m_e0_e1+a.m_e0_e2*b.m_e2*c.m_e0_e2+a.m_e0_e2*b.m_e3*c.m_e0_e3-a.m_e0_e2*c.m_scalar-a.m_e0_e3*b.m_e1*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e2*c.m_e0_e3+a.m_e0_e3*b.m_e3*c.m_e0_e2+a.m_e0_e3*c.m_e2_e3-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e1_e2*c.m_e0_e1+a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e1+a.m_e2_e1_e3_e0*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar+a.m_e2_e3*c.m_e0_e3-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2-a.m_e3_e1*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3+a.m_scalar*c.m_e0_e2), // e2
			(a.m_e0_e1*b.m_e1*c.m_e0_e3-a.m_e0_e1*b.m_e2*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e3*c.m_e0_e1+a.m_e0_e1*c.m_e3_e1+a.m_e0_e2*b.m_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e2*c.m_e0_e3-a.m_e0_e2*b.m_e3*c.m_e0_e2-a.m_e0_e2*c.m_e2_e3+a.m_e0_e3*b.m_e1*c.m_e0_e1+a.m_e0_e3*b.m_e2*c.m_e0_e2+a.m_e0_e3*b.m_e3*c.m_e0_e3-a.m_e0_e3*c.m_scalar-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e1_e2*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3-a.m_e2_e3*c.m_e0_e2+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1+a.m_e3_e1*c.m_e0_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar+a.m_scalar*c.m_e0_e3), // e3
			(a.m_e0_e1*b.m_e1*c.m_scalar-a.m_e0_e1*b.m_e2*c.m_e1_e2+a.m_e0_e1*b.m_e3*c.m_e3_e1+a.m_e0_e1*c.m_e0_e1+a.m_e0_e2*b.m_e1*c.m_e1_e2+a.m_e0_e2*b.m_e2*c.m_scalar-a.m_e0_e2*b.m_e3*c.m_e2_e3+a.m_e0_e2*c.m_e0_e2-a.m_e0_e3*b.m_e1*c.m_e3_e1+a.m_e0_e3*b.m_e2*c.m_e2_e3+a.m_e0_e3*b.m_e3*c.m_scalar+a.m_e0_e3*c.m_e0_e3+a.m_e1_e2*b.m_e1*c.m_e0_e2-a.m_e1_e2*b.m_e2*c.m_e0_e1+a.m_e1_e2*b.m_e3*c.m_e2_e1_e3_e0-a.m_e1_e2*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e1_e2-a.m_e2_e1_e3_e0*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e1*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e2*c.m_e0_e3-a.m_e2_e3*b.m_e3*c.m_e0_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*b.m_e1*c.m_e0_e3+a.m_e3_e1*b.m_e2*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e3*c.m_e0_e1-a.m_e3_e1*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e0_e1-a.m_scalar*b.m_e2*c.m_e0_e2-a.m_scalar*b.m_e3*c.m_e0_e3+a.m_scalar*c.m_scalar) // e0
		);
}
inline point applyVersorWI(const evenVersor &a, const point &b, const evenVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0_e1*b.m_e0*c.m_scalar+a.m_e0_e1*b.m_e1*c.m_e0_e1+a.m_e0_e1*b.m_e2*c.m_e0_e2+a.m_e0_e1*b.m_e3*c.m_e0_e3+a.m_e0_e2*b.m_e0*c.m_e1_e2-a.m_e0_e2*b.m_e1*c.m_e0_e2+a.m_e0_e2*b.m_e2*c.m_e0_e1-a.m_e0_e2*b.m_e3*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e0*c.m_e3_e1-a.m_e0_e3*b.m_e1*c.m_e0_e3+a.m_e0_e3*b.m_e2*c.m_e2_e1_e3_e0+a.m_e0_e3*b.m_e3*c.m_e0_e1+a.m_e1_e2*b.m_e0*c.m_e0_e2+a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3+a.m_e2_e1_e3_e0*b.m_e0*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e2-a.m_e2_e3*b.m_e0*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2-a.m_e3_e1*b.m_e0*c.m_e0_e3+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e0*c.m_e0_e1+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e0_e1*b.m_e0*c.m_e1_e2+a.m_e0_e1*b.m_e1*c.m_e0_e2-a.m_e0_e1*b.m_e2*c.m_e0_e1+a.m_e0_e1*b.m_e3*c.m_e2_e1_e3_e0-a.m_e0_e2*b.m_e0*c.m_scalar+a.m_e0_e2*b.m_e1*c.m_e0_e1+a.m_e0_e2*b.m_e2*c.m_e0_e2+a.m_e0_e2*b.m_e3*c.m_e0_e3+a.m_e0_e3*b.m_e0*c.m_e2_e3-a.m_e0_e3*b.m_e1*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e2*c.m_e0_e3+a.m_e0_e3*b.m_e3*c.m_e0_e2-a.m_e1_e2*b.m_e0*c.m_e0_e1-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e0*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e3*c.m_e0_e1+a.m_e2_e3*b.m_e0*c.m_e0_e3-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e0*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e0*c.m_e0_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(a.m_e0_e1*b.m_e0*c.m_e3_e1+a.m_e0_e1*b.m_e1*c.m_e0_e3-a.m_e0_e1*b.m_e2*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e3*c.m_e0_e1-a.m_e0_e2*b.m_e0*c.m_e2_e3+a.m_e0_e2*b.m_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e2*c.m_e0_e3-a.m_e0_e2*b.m_e3*c.m_e0_e2-a.m_e0_e3*b.m_e0*c.m_scalar+a.m_e0_e3*b.m_e1*c.m_e0_e1+a.m_e0_e3*b.m_e2*c.m_e0_e2+a.m_e0_e3*b.m_e3*c.m_e0_e3-a.m_e1_e2*b.m_e0*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e0*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e1*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e2*c.m_e0_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e0*c.m_e0_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e0*c.m_e0_e1+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1+a.m_scalar*b.m_e0*c.m_e0_e3-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(a.m_e0_e1*b.m_e0*c.m_e0_e1+a.m_e0_e1*b.m_e1*c.m_scalar-a.m_e0_e1*b.m_e2*c.m_e1_e2+a.m_e0_e1*b.m_e3*c.m_e3_e1+a.m_e0_e2*b.m_e0*c.m_e0_e2+a.m_e0_e2*b.m_e1*c.m_e1_e2+a.m_e0_e2*b.m_e2*c.m_scalar-a.m_e0_e2*b.m_e3*c.m_e2_e3+a.m_e0_e3*b.m_e0*c.m_e0_e3-a.m_e0_e3*b.m_e1*c.m_e3_e1+a.m_e0_e3*b.m_e2*c.m_e2_e3+a.m_e0_e3*b.m_e3*c.m_scalar-a.m_e1_e2*b.m_e0*c.m_e1_e2+a.m_e1_e2*b.m_e1*c.m_e0_e2-a.m_e1_e2*b.m_e2*c.m_e0_e1+a.m_e1_e2*b.m_e3*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e0*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e1*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e2*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e0*c.m_e2_e3+a.m_e2_e3*b.m_e1*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e2*c.m_e0_e3-a.m_e2_e3*b.m_e3*c.m_e0_e2-a.m_e3_e1*b.m_e0*c.m_e3_e1-a.m_e3_e1*b.m_e1*c.m_e0_e3+a.m_e3_e1*b.m_e2*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e3*c.m_e0_e1+a.m_scalar*b.m_e0*c.m_scalar-a.m_scalar*b.m_e1*c.m_e0_e1-a.m_scalar*b.m_e2*c.m_e0_e2-a.m_scalar*b.m_e3*c.m_e0_e3) // e0
		);
}
inline line applyVersorWI(const evenVersor &a, const bivector &b, const evenVersor &c)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(a.m_e0_e1*b.m_e1_e2*c.m_e1_e2+a.m_e0_e1*b.m_e2_e3*c.m_e2_e3+a.m_e0_e1*b.m_e3_e1*c.m_e3_e1+a.m_e0_e2*b.m_e1_e2*c.m_scalar-a.m_e0_e2*b.m_e2_e3*c.m_e3_e1+a.m_e0_e2*b.m_e3_e1*c.m_e2_e3+a.m_e0_e3*b.m_e1_e2*c.m_e2_e3-a.m_e0_e3*b.m_e2_e3*c.m_e1_e2-a.m_e0_e3*b.m_e3_e1*c.m_scalar+a.m_e1_e2*b.m_e1_e2*c.m_e0_e1-a.m_e1_e2*b.m_e2_e3*c.m_e0_e3+a.m_e1_e2*b.m_e3_e1*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e1_e2+a.m_e2_e3*b.m_e1_e2*c.m_e0_e3+a.m_e2_e3*b.m_e2_e3*c.m_e0_e1+a.m_e2_e3*b.m_e3_e1*c.m_e0_e2-a.m_e3_e1*b.m_e1_e2*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e2_e3*c.m_e0_e2+a.m_e3_e1*b.m_e3_e1*c.m_e0_e1-a.m_scalar*b.m_e1_e2*c.m_e0_e2+a.m_scalar*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e3_e1*c.m_e0_e3), // e0_e1
			-(-a.m_e0_e1*b.m_e1_e2*c.m_scalar+a.m_e0_e1*b.m_e2_e3*c.m_e3_e1-a.m_e0_e1*b.m_e3_e1*c.m_e2_e3+a.m_e0_e2*b.m_e1_e2*c.m_e1_e2+a.m_e0_e2*b.m_e2_e3*c.m_e2_e3+a.m_e0_e2*b.m_e3_e1*c.m_e3_e1+a.m_e0_e3*b.m_e1_e2*c.m_e3_e1+a.m_e0_e3*b.m_e2_e3*c.m_scalar-a.m_e0_e3*b.m_e3_e1*c.m_e1_e2+a.m_e1_e2*b.m_e1_e2*c.m_e0_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e3_e1*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e2_e3+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_scalar+a.m_e2_e3*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e2_e3*c.m_e0_e2-a.m_e2_e3*b.m_e3_e1*c.m_e0_e1+a.m_e3_e1*b.m_e1_e2*c.m_e0_e3+a.m_e3_e1*b.m_e2_e3*c.m_e0_e1+a.m_e3_e1*b.m_e3_e1*c.m_e0_e2+a.m_scalar*b.m_e1_e2*c.m_e0_e1-a.m_scalar*b.m_e2_e3*c.m_e0_e3+a.m_scalar*b.m_e3_e1*c.m_e2_e1_e3_e0), // e0_e2
			-(-a.m_e0_e1*b.m_e1_e2*c.m_e2_e3+a.m_e0_e1*b.m_e2_e3*c.m_e1_e2+a.m_e0_e1*b.m_e3_e1*c.m_scalar-a.m_e0_e2*b.m_e1_e2*c.m_e3_e1-a.m_e0_e2*b.m_e2_e3*c.m_scalar+a.m_e0_e2*b.m_e3_e1*c.m_e1_e2+a.m_e0_e3*b.m_e1_e2*c.m_e1_e2+a.m_e0_e3*b.m_e2_e3*c.m_e2_e3+a.m_e0_e3*b.m_e3_e1*c.m_e3_e1+a.m_e1_e2*b.m_e1_e2*c.m_e0_e3+a.m_e1_e2*b.m_e2_e3*c.m_e0_e1+a.m_e1_e2*b.m_e3_e1*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e2_e3-a.m_e2_e3*b.m_e1_e2*c.m_e0_e1+a.m_e2_e3*b.m_e2_e3*c.m_e0_e3-a.m_e2_e3*b.m_e3_e1*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e1_e2*c.m_e0_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e3_e1*c.m_e0_e3+a.m_scalar*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e2_e3*c.m_e0_e2-a.m_scalar*b.m_e3_e1*c.m_e0_e1), // e0_e3
			(a.m_e0_e1*b.m_e1_e2*c.m_e0_e1-a.m_e0_e1*b.m_e2_e3*c.m_e0_e3+a.m_e0_e1*b.m_e3_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e1_e2*c.m_e0_e2-a.m_e0_e2*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e0_e2*b.m_e3_e1*c.m_e0_e3-a.m_e0_e3*b.m_e1_e2*c.m_e0_e3-a.m_e0_e3*b.m_e2_e3*c.m_e0_e1-a.m_e0_e3*b.m_e3_e1*c.m_e0_e2-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e0_e2-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e0_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e0_e1*b.m_e1_e2*c.m_e0_e3-a.m_e0_e1*b.m_e2_e3*c.m_e0_e1-a.m_e0_e1*b.m_e3_e1*c.m_e0_e2+a.m_e0_e2*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e2_e3*c.m_e0_e2-a.m_e0_e2*b.m_e3_e1*c.m_e0_e1-a.m_e0_e3*b.m_e1_e2*c.m_e0_e1+a.m_e0_e3*b.m_e2_e3*c.m_e0_e3-a.m_e0_e3*b.m_e3_e1*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e0_e3-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e0_e1*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e0_e1*b.m_e2_e3*c.m_e0_e2-a.m_e0_e1*b.m_e3_e1*c.m_e0_e1+a.m_e0_e2*b.m_e1_e2*c.m_e0_e3+a.m_e0_e2*b.m_e2_e3*c.m_e0_e1+a.m_e0_e2*b.m_e3_e1*c.m_e0_e2+a.m_e0_e3*b.m_e1_e2*c.m_e0_e2-a.m_e0_e3*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e3_e1*c.m_e0_e3+a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e0_e1+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline line applyVersorWI(const evenVersor &a, const line &b, const evenVersor &c)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(a.m_e0_e1*b.m_e0_e1*c.m_e0_e1+a.m_e0_e1*b.m_e0_e2*c.m_e0_e2+a.m_e0_e1*b.m_e0_e3*c.m_e0_e3+a.m_e0_e1*b.m_e1_e2*c.m_e1_e2+a.m_e0_e1*b.m_e2_e3*c.m_e2_e3+a.m_e0_e1*b.m_e3_e1*c.m_e3_e1-a.m_e0_e2*b.m_e0_e1*c.m_e0_e2+a.m_e0_e2*b.m_e0_e2*c.m_e0_e1-a.m_e0_e2*b.m_e0_e3*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e1_e2*c.m_scalar-a.m_e0_e2*b.m_e2_e3*c.m_e3_e1+a.m_e0_e2*b.m_e3_e1*c.m_e2_e3-a.m_e0_e3*b.m_e0_e1*c.m_e0_e3+a.m_e0_e3*b.m_e0_e2*c.m_e2_e1_e3_e0+a.m_e0_e3*b.m_e0_e3*c.m_e0_e1+a.m_e0_e3*b.m_e1_e2*c.m_e2_e3-a.m_e0_e3*b.m_e2_e3*c.m_e1_e2-a.m_e0_e3*b.m_e3_e1*c.m_scalar-a.m_e1_e2*b.m_e0_e1*c.m_e1_e2-a.m_e1_e2*b.m_e0_e2*c.m_scalar+a.m_e1_e2*b.m_e0_e3*c.m_e2_e3+a.m_e1_e2*b.m_e1_e2*c.m_e0_e1-a.m_e1_e2*b.m_e2_e3*c.m_e0_e3+a.m_e1_e2*b.m_e3_e1*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e1_e2+a.m_e2_e3*b.m_e0_e1*c.m_e2_e3+a.m_e2_e3*b.m_e0_e2*c.m_e3_e1+a.m_e2_e3*b.m_e0_e3*c.m_e1_e2+a.m_e2_e3*b.m_e1_e2*c.m_e0_e3+a.m_e2_e3*b.m_e2_e3*c.m_e0_e1+a.m_e2_e3*b.m_e3_e1*c.m_e0_e2-a.m_e3_e1*b.m_e0_e1*c.m_e3_e1+a.m_e3_e1*b.m_e0_e2*c.m_e2_e3+a.m_e3_e1*b.m_e0_e3*c.m_scalar-a.m_e3_e1*b.m_e1_e2*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e2_e3*c.m_e0_e2+a.m_e3_e1*b.m_e3_e1*c.m_e0_e1-a.m_scalar*b.m_e0_e1*c.m_scalar+a.m_scalar*b.m_e0_e2*c.m_e1_e2-a.m_scalar*b.m_e0_e3*c.m_e3_e1-a.m_scalar*b.m_e1_e2*c.m_e0_e2+a.m_scalar*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e3_e1*c.m_e0_e3), // e0_e1
			-(a.m_e0_e1*b.m_e0_e1*c.m_e0_e2-a.m_e0_e1*b.m_e0_e2*c.m_e0_e1+a.m_e0_e1*b.m_e0_e3*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e1_e2*c.m_scalar+a.m_e0_e1*b.m_e2_e3*c.m_e3_e1-a.m_e0_e1*b.m_e3_e1*c.m_e2_e3+a.m_e0_e2*b.m_e0_e1*c.m_e0_e1+a.m_e0_e2*b.m_e0_e2*c.m_e0_e2+a.m_e0_e2*b.m_e0_e3*c.m_e0_e3+a.m_e0_e2*b.m_e1_e2*c.m_e1_e2+a.m_e0_e2*b.m_e2_e3*c.m_e2_e3+a.m_e0_e2*b.m_e3_e1*c.m_e3_e1-a.m_e0_e3*b.m_e0_e1*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e0_e2*c.m_e0_e3+a.m_e0_e3*b.m_e0_e3*c.m_e0_e2+a.m_e0_e3*b.m_e1_e2*c.m_e3_e1+a.m_e0_e3*b.m_e2_e3*c.m_scalar-a.m_e0_e3*b.m_e3_e1*c.m_e1_e2+a.m_e1_e2*b.m_e0_e1*c.m_scalar-a.m_e1_e2*b.m_e0_e2*c.m_e1_e2+a.m_e1_e2*b.m_e0_e3*c.m_e3_e1+a.m_e1_e2*b.m_e1_e2*c.m_e0_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e3_e1*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_e0_e1-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e2_e3+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_scalar+a.m_e2_e3*b.m_e0_e1*c.m_e3_e1-a.m_e2_e3*b.m_e0_e2*c.m_e2_e3-a.m_e2_e3*b.m_e0_e3*c.m_scalar+a.m_e2_e3*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e2_e3*c.m_e0_e2-a.m_e2_e3*b.m_e3_e1*c.m_e0_e1+a.m_e3_e1*b.m_e0_e1*c.m_e2_e3+a.m_e3_e1*b.m_e0_e2*c.m_e3_e1+a.m_e3_e1*b.m_e0_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1_e2*c.m_e0_e3+a.m_e3_e1*b.m_e2_e3*c.m_e0_e1+a.m_e3_e1*b.m_e3_e1*c.m_e0_e2-a.m_scalar*b.m_e0_e1*c.m_e1_e2-a.m_scalar*b.m_e0_e2*c.m_scalar+a.m_scalar*b.m_e0_e3*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e0_e1-a.m_scalar*b.m_e2_e3*c.m_e0_e3+a.m_scalar*b.m_e3_e1*c.m_e2_e1_e3_e0), // e0_e2
			-(a.m_e0_e1*b.m_e0_e1*c.m_e0_e3-a.m_e0_e1*b.m_e0_e2*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e0_e3*c.m_e0_e1-a.m_e0_e1*b.m_e1_e2*c.m_e2_e3+a.m_e0_e1*b.m_e2_e3*c.m_e1_e2+a.m_e0_e1*b.m_e3_e1*c.m_scalar+a.m_e0_e2*b.m_e0_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e0_e2*c.m_e0_e3-a.m_e0_e2*b.m_e0_e3*c.m_e0_e2-a.m_e0_e2*b.m_e1_e2*c.m_e3_e1-a.m_e0_e2*b.m_e2_e3*c.m_scalar+a.m_e0_e2*b.m_e3_e1*c.m_e1_e2+a.m_e0_e3*b.m_e0_e1*c.m_e0_e1+a.m_e0_e3*b.m_e0_e2*c.m_e0_e2+a.m_e0_e3*b.m_e0_e3*c.m_e0_e3+a.m_e0_e3*b.m_e1_e2*c.m_e1_e2+a.m_e0_e3*b.m_e2_e3*c.m_e2_e3+a.m_e0_e3*b.m_e3_e1*c.m_e3_e1+a.m_e1_e2*b.m_e0_e1*c.m_e2_e3+a.m_e1_e2*b.m_e0_e2*c.m_e3_e1+a.m_e1_e2*b.m_e0_e3*c.m_e1_e2+a.m_e1_e2*b.m_e1_e2*c.m_e0_e3+a.m_e1_e2*b.m_e2_e3*c.m_e0_e1+a.m_e1_e2*b.m_e3_e1*c.m_e0_e2-a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_e0_e1-a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e2_e3+a.m_e2_e3*b.m_e0_e1*c.m_e1_e2+a.m_e2_e3*b.m_e0_e2*c.m_scalar-a.m_e2_e3*b.m_e0_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1_e2*c.m_e0_e1+a.m_e2_e3*b.m_e2_e3*c.m_e0_e3-a.m_e2_e3*b.m_e3_e1*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e0_e1*c.m_scalar+a.m_e3_e1*b.m_e0_e2*c.m_e1_e2-a.m_e3_e1*b.m_e0_e3*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_e0_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e3_e1*c.m_e0_e3+a.m_scalar*b.m_e0_e1*c.m_e3_e1-a.m_scalar*b.m_e0_e2*c.m_e2_e3-a.m_scalar*b.m_e0_e3*c.m_scalar+a.m_scalar*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e2_e3*c.m_e0_e2-a.m_scalar*b.m_e3_e1*c.m_e0_e1), // e0_e3
			(-a.m_e0_e1*b.m_e0_e1*c.m_e1_e2-a.m_e0_e1*b.m_e0_e2*c.m_scalar+a.m_e0_e1*b.m_e0_e3*c.m_e2_e3+a.m_e0_e1*b.m_e1_e2*c.m_e0_e1-a.m_e0_e1*b.m_e2_e3*c.m_e0_e3+a.m_e0_e1*b.m_e3_e1*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e0_e1*c.m_scalar-a.m_e0_e2*b.m_e0_e2*c.m_e1_e2+a.m_e0_e2*b.m_e0_e3*c.m_e3_e1+a.m_e0_e2*b.m_e1_e2*c.m_e0_e2-a.m_e0_e2*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e0_e2*b.m_e3_e1*c.m_e0_e3-a.m_e0_e3*b.m_e0_e1*c.m_e2_e3-a.m_e0_e3*b.m_e0_e2*c.m_e3_e1-a.m_e0_e3*b.m_e0_e3*c.m_e1_e2-a.m_e0_e3*b.m_e1_e2*c.m_e0_e3-a.m_e0_e3*b.m_e2_e3*c.m_e0_e1-a.m_e0_e3*b.m_e3_e1*c.m_e0_e2-a.m_e1_e2*b.m_e0_e1*c.m_e0_e1-a.m_e1_e2*b.m_e0_e2*c.m_e0_e2-a.m_e1_e2*b.m_e0_e3*c.m_e0_e3-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_scalar+a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e0_e2-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e0_e1-a.m_e2_e3*b.m_e0_e1*c.m_e0_e3+a.m_e2_e3*b.m_e0_e2*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e0_e3*c.m_e0_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar-a.m_e3_e1*b.m_e0_e1*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e0_e2*c.m_e0_e3+a.m_e3_e1*b.m_e0_e3*c.m_e0_e2+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2-a.m_scalar*b.m_e0_e1*c.m_e0_e2+a.m_scalar*b.m_e0_e2*c.m_e0_e1-a.m_scalar*b.m_e0_e3*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e0_e1*b.m_e0_e1*c.m_e2_e3-a.m_e0_e1*b.m_e0_e2*c.m_e3_e1-a.m_e0_e1*b.m_e0_e3*c.m_e1_e2-a.m_e0_e1*b.m_e1_e2*c.m_e0_e3-a.m_e0_e1*b.m_e2_e3*c.m_e0_e1-a.m_e0_e1*b.m_e3_e1*c.m_e0_e2+a.m_e0_e2*b.m_e0_e1*c.m_e3_e1-a.m_e0_e2*b.m_e0_e2*c.m_e2_e3-a.m_e0_e2*b.m_e0_e3*c.m_scalar+a.m_e0_e2*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e2_e3*c.m_e0_e2-a.m_e0_e2*b.m_e3_e1*c.m_e0_e1+a.m_e0_e3*b.m_e0_e1*c.m_e1_e2+a.m_e0_e3*b.m_e0_e2*c.m_scalar-a.m_e0_e3*b.m_e0_e3*c.m_e2_e3-a.m_e0_e3*b.m_e1_e2*c.m_e0_e1+a.m_e0_e3*b.m_e2_e3*c.m_e0_e3-a.m_e0_e3*b.m_e3_e1*c.m_e2_e1_e3_e0+a.m_e1_e2*b.m_e0_e1*c.m_e0_e3-a.m_e1_e2*b.m_e0_e2*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e0_e3*c.m_e0_e1-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_scalar+a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e0_e3-a.m_e2_e3*b.m_e0_e1*c.m_e0_e1-a.m_e2_e3*b.m_e0_e2*c.m_e0_e2-a.m_e2_e3*b.m_e0_e3*c.m_e0_e3-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1+a.m_e3_e1*b.m_e0_e1*c.m_e0_e2-a.m_e3_e1*b.m_e0_e2*c.m_e0_e1+a.m_e3_e1*b.m_e0_e3*c.m_e2_e1_e3_e0-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3-a.m_scalar*b.m_e0_e1*c.m_e2_e1_e3_e0-a.m_scalar*b.m_e0_e2*c.m_e0_e3+a.m_scalar*b.m_e0_e3*c.m_e0_e2+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e0_e1*b.m_e0_e1*c.m_e3_e1-a.m_e0_e1*b.m_e0_e2*c.m_e2_e3-a.m_e0_e1*b.m_e0_e3*c.m_scalar+a.m_e0_e1*b.m_e1_e2*c.m_e2_e1_e3_e0+a.m_e0_e1*b.m_e2_e3*c.m_e0_e2-a.m_e0_e1*b.m_e3_e1*c.m_e0_e1+a.m_e0_e2*b.m_e0_e1*c.m_e2_e3+a.m_e0_e2*b.m_e0_e2*c.m_e3_e1+a.m_e0_e2*b.m_e0_e3*c.m_e1_e2+a.m_e0_e2*b.m_e1_e2*c.m_e0_e3+a.m_e0_e2*b.m_e2_e3*c.m_e0_e1+a.m_e0_e2*b.m_e3_e1*c.m_e0_e2+a.m_e0_e3*b.m_e0_e1*c.m_scalar-a.m_e0_e3*b.m_e0_e2*c.m_e1_e2+a.m_e0_e3*b.m_e0_e3*c.m_e3_e1+a.m_e0_e3*b.m_e1_e2*c.m_e0_e2-a.m_e0_e3*b.m_e2_e3*c.m_e2_e1_e3_e0-a.m_e0_e3*b.m_e3_e1*c.m_e0_e3-a.m_e1_e2*b.m_e0_e1*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e0_e2*c.m_e0_e3+a.m_e1_e2*b.m_e0_e3*c.m_e0_e2+a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e0_e1*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e0_e2*c.m_scalar-a.m_e2_e1_e3_e0*b.m_e0_e3*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e1_e2*c.m_e0_e1+a.m_e2_e1_e3_e0*b.m_e2_e3*c.m_e0_e3-a.m_e2_e1_e3_e0*b.m_e3_e1*c.m_e2_e1_e3_e0+a.m_e2_e3*b.m_e0_e1*c.m_e0_e2-a.m_e2_e3*b.m_e0_e2*c.m_e0_e1+a.m_e2_e3*b.m_e0_e3*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e0_e1*c.m_e0_e1+a.m_e3_e1*b.m_e0_e2*c.m_e0_e2+a.m_e3_e1*b.m_e0_e3*c.m_e0_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1-a.m_scalar*b.m_e0_e1*c.m_e0_e3+a.m_scalar*b.m_e0_e2*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e0_e3*c.m_e0_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline plane applyVersorWI(const evenVersor &a, const plane &b, const evenVersor &c)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e0_e1*b.m_e1_e2_e0*c.m_e0_e1-a.m_e0_e1*b.m_e1_e2_e3*c.m_e3_e1+a.m_e0_e1*b.m_e2_e3_e0*c.m_e0_e3-a.m_e0_e1*b.m_e3_e1_e0*c.m_e2_e1_e3_e0-a.m_e0_e2*b.m_e1_e2_e0*c.m_e0_e2+a.m_e0_e2*b.m_e1_e2_e3*c.m_e2_e3+a.m_e0_e2*b.m_e2_e3_e0*c.m_e2_e1_e3_e0+a.m_e0_e2*b.m_e3_e1_e0*c.m_e0_e3+a.m_e0_e3*b.m_e1_e2_e0*c.m_e0_e3+a.m_e0_e3*b.m_e1_e2_e3*c.m_scalar+a.m_e0_e3*b.m_e2_e3_e0*c.m_e0_e1+a.m_e0_e3*b.m_e3_e1_e0*c.m_e0_e2-a.m_e1_e2*b.m_e1_e2_e0*c.m_e1_e2+a.m_e1_e2*b.m_e1_e2_e3*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e2_e3_e0*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1_e0*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e1_e2_e0*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e1_e2_e3*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e2_e3_e0*c.m_e0_e2+a.m_e2_e1_e3_e0*b.m_e3_e1_e0*c.m_e0_e1+a.m_e2_e3*b.m_e1_e2_e0*c.m_e2_e3+a.m_e2_e3*b.m_e1_e2_e3*c.m_e0_e2-a.m_e2_e3*b.m_e2_e3_e0*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1_e0*c.m_scalar+a.m_e3_e1*b.m_e1_e2_e0*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2_e3*c.m_e0_e1+a.m_e3_e1*b.m_e2_e3_e0*c.m_scalar-a.m_e3_e1*b.m_e3_e1_e0*c.m_e1_e2+a.m_scalar*b.m_e1_e2_e0*c.m_scalar-a.m_scalar*b.m_e1_e2_e3*c.m_e0_e3-a.m_scalar*b.m_e2_e3_e0*c.m_e3_e1+a.m_scalar*b.m_e3_e1_e0*c.m_e2_e3), // e1_e2_e0
			(a.m_e0_e1*b.m_e1_e2_e0*c.m_e0_e3+a.m_e0_e1*b.m_e1_e2_e3*c.m_scalar+a.m_e0_e1*b.m_e2_e3_e0*c.m_e0_e1+a.m_e0_e1*b.m_e3_e1_e0*c.m_e0_e2-a.m_e0_e2*b.m_e1_e2_e0*c.m_e2_e1_e3_e0-a.m_e0_e2*b.m_e1_e2_e3*c.m_e1_e2-a.m_e0_e2*b.m_e2_e3_e0*c.m_e0_e2+a.m_e0_e2*b.m_e3_e1_e0*c.m_e0_e1+a.m_e0_e3*b.m_e1_e2_e0*c.m_e0_e1+a.m_e0_e3*b.m_e1_e2_e3*c.m_e3_e1-a.m_e0_e3*b.m_e2_e3_e0*c.m_e0_e3+a.m_e0_e3*b.m_e3_e1_e0*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e1_e2_e0*c.m_e2_e3-a.m_e1_e2*b.m_e1_e2_e3*c.m_e0_e2+a.m_e1_e2*b.m_e2_e3_e0*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1_e0*c.m_scalar+a.m_e2_e1_e3_e0*b.m_e1_e2_e0*c.m_e0_e2-a.m_e2_e1_e3_e0*b.m_e1_e2_e3*c.m_e2_e3-a.m_e2_e1_e3_e0*b.m_e2_e3_e0*c.m_e2_e1_e3_e0-a.m_e2_e1_e3_e0*b.m_e3_e1_e0*c.m_e0_e3-a.m_e2_e3*b.m_e1_e2_e0*c.m_e1_e2+a.m_e2_e3*b.m_e1_e2_e3*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e2_e3_e0*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1_e0*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2_e0*c.m_scalar+a.m_e3_e1*b.m_e1_e2_e3*c.m_e0_e3+a.m_e3_e1*b.m_e2_e3_e0*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1_e0*c.m_e2_e3+a.m_scalar*b.m_e1_e2_e0*c.m_e3_e1-a.m_scalar*b.m_e1_e2_e3*c.m_e0_e1+a.m_scalar*b.m_e2_e3_e0*c.m_scalar-a.m_scalar*b.m_e3_e1_e0*c.m_e1_e2), // e2_e3_e0
			-(-a.m_e0_e1*b.m_e1_e2_e0*c.m_e2_e1_e3_e0-a.m_e0_e1*b.m_e1_e2_e3*c.m_e1_e2-a.m_e0_e1*b.m_e2_e3_e0*c.m_e0_e2+a.m_e0_e1*b.m_e3_e1_e0*c.m_e0_e1-a.m_e0_e2*b.m_e1_e2_e0*c.m_e0_e3-a.m_e0_e2*b.m_e1_e2_e3*c.m_scalar-a.m_e0_e2*b.m_e2_e3_e0*c.m_e0_e1-a.m_e0_e2*b.m_e3_e1_e0*c.m_e0_e2-a.m_e0_e3*b.m_e1_e2_e0*c.m_e0_e2+a.m_e0_e3*b.m_e1_e2_e3*c.m_e2_e3+a.m_e0_e3*b.m_e2_e3_e0*c.m_e2_e1_e3_e0+a.m_e0_e3*b.m_e3_e1_e0*c.m_e0_e3+a.m_e1_e2*b.m_e1_e2_e0*c.m_e3_e1-a.m_e1_e2*b.m_e1_e2_e3*c.m_e0_e1+a.m_e1_e2*b.m_e2_e3_e0*c.m_scalar-a.m_e1_e2*b.m_e3_e1_e0*c.m_e1_e2+a.m_e2_e1_e3_e0*b.m_e1_e2_e0*c.m_e0_e1+a.m_e2_e1_e3_e0*b.m_e1_e2_e3*c.m_e3_e1-a.m_e2_e1_e3_e0*b.m_e2_e3_e0*c.m_e0_e3+a.m_e2_e1_e3_e0*b.m_e3_e1_e0*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e1_e2_e0*c.m_scalar+a.m_e2_e3*b.m_e1_e2_e3*c.m_e0_e3+a.m_e2_e3*b.m_e2_e3_e0*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1_e0*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2_e0*c.m_e1_e2-a.m_e3_e1*b.m_e1_e2_e3*c.m_e2_e1_e3_e0+a.m_e3_e1*b.m_e2_e3_e0*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1_e0*c.m_e3_e1+a.m_scalar*b.m_e1_e2_e0*c.m_e2_e3+a.m_scalar*b.m_e1_e2_e3*c.m_e0_e2-a.m_scalar*b.m_e2_e3_e0*c.m_e1_e2-a.m_scalar*b.m_e3_e1_e0*c.m_scalar), // e3_e1_e0
			(-a.m_e0_e1*b.m_e1_e2_e0*c.m_e3_e1+a.m_e0_e1*b.m_e1_e2_e3*c.m_e0_e1-a.m_e0_e1*b.m_e2_e3_e0*c.m_scalar+a.m_e0_e1*b.m_e3_e1_e0*c.m_e1_e2+a.m_e0_e2*b.m_e1_e2_e0*c.m_e2_e3+a.m_e0_e2*b.m_e1_e2_e3*c.m_e0_e2-a.m_e0_e2*b.m_e2_e3_e0*c.m_e1_e2-a.m_e0_e2*b.m_e3_e1_e0*c.m_scalar-a.m_e0_e3*b.m_e1_e2_e0*c.m_scalar+a.m_e0_e3*b.m_e1_e2_e3*c.m_e0_e3+a.m_e0_e3*b.m_e2_e3_e0*c.m_e3_e1-a.m_e0_e3*b.m_e3_e1_e0*c.m_e2_e3-a.m_e1_e2*b.m_e1_e2_e0*c.m_e2_e1_e3_e0-a.m_e1_e2*b.m_e1_e2_e3*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3_e0*c.m_e0_e2+a.m_e1_e2*b.m_e3_e1_e0*c.m_e0_e1+a.m_e2_e1_e3_e0*b.m_e1_e2_e0*c.m_e1_e2-a.m_e2_e1_e3_e0*b.m_e1_e2_e3*c.m_e2_e1_e3_e0+a.m_e2_e1_e3_e0*b.m_e2_e3_e0*c.m_e2_e3+a.m_e2_e1_e3_e0*b.m_e3_e1_e0*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2_e0*c.m_e0_e2-a.m_e2_e3*b.m_e1_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3_e0*c.m_e2_e1_e3_e0-a.m_e2_e3*b.m_e3_e1_e0*c.m_e0_e3-a.m_e3_e1*b.m_e1_e2_e0*c.m_e0_e1-a.m_e3_e1*b.m_e1_e2_e3*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3_e0*c.m_e0_e3-a.m_e3_e1*b.m_e3_e1_e0*c.m_e2_e1_e3_e0+a.m_scalar*b.m_e1_e2_e0*c.m_e0_e3+a.m_scalar*b.m_e1_e2_e3*c.m_scalar+a.m_scalar*b.m_e2_e3_e0*c.m_e0_e1+a.m_scalar*b.m_e3_e1_e0*c.m_e0_e2) // e1_e2_e3
		);
}
inline point applyVersorWI(const oddVersor &a, const vector &b, const oddVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*b.m_e1*c.m_e0+a.m_e0*b.m_e2*c.m_e1_e2_e0-a.m_e0*b.m_e3*c.m_e3_e1_e0+a.m_e1*b.m_e1*c.m_e1+a.m_e1*b.m_e2*c.m_e2+a.m_e1*b.m_e3*c.m_e3-a.m_e1_e2_e0*b.m_e1*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2*c.m_e0+a.m_e1_e2_e0*b.m_e3*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2*c.m_e3+a.m_e1_e2_e3*b.m_e3*c.m_e2-a.m_e2*b.m_e1*c.m_e2+a.m_e2*b.m_e2*c.m_e1-a.m_e2*b.m_e3*c.m_e1_e2_e3+a.m_e2_e3_e0*b.m_e1*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e2*c.m_e3_e1_e0+a.m_e2_e3_e0*b.m_e3*c.m_e1_e2_e0-a.m_e3*b.m_e1*c.m_e3+a.m_e3*b.m_e2*c.m_e1_e2_e3+a.m_e3*b.m_e3*c.m_e1-a.m_e3_e1_e0*b.m_e1*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3*c.m_e0), // e1
			(-a.m_e0*b.m_e1*c.m_e1_e2_e0-a.m_e0*b.m_e2*c.m_e0+a.m_e0*b.m_e3*c.m_e2_e3_e0+a.m_e1*b.m_e1*c.m_e2-a.m_e1*b.m_e2*c.m_e1+a.m_e1*b.m_e3*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e1*c.m_e0-a.m_e1_e2_e0*b.m_e2*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e1*c.m_e3-a.m_e1_e2_e3*b.m_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e3*c.m_e1+a.m_e2*b.m_e1*c.m_e1+a.m_e2*b.m_e2*c.m_e2+a.m_e2*b.m_e3*c.m_e3+a.m_e2_e3_e0*b.m_e1*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e2*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3*c.m_e0-a.m_e3*b.m_e1*c.m_e1_e2_e3-a.m_e3*b.m_e2*c.m_e3+a.m_e3*b.m_e3*c.m_e2+a.m_e3_e1_e0*b.m_e1*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e2*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e3*c.m_e1_e2_e0), // e2
			(a.m_e0*b.m_e1*c.m_e3_e1_e0-a.m_e0*b.m_e2*c.m_e2_e3_e0-a.m_e0*b.m_e3*c.m_e0+a.m_e1*b.m_e1*c.m_e3-a.m_e1*b.m_e2*c.m_e1_e2_e3-a.m_e1*b.m_e3*c.m_e1+a.m_e1_e2_e0*b.m_e1*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e2*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e1*c.m_e2+a.m_e1_e2_e3*b.m_e2*c.m_e1-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e3+a.m_e2*b.m_e1*c.m_e1_e2_e3+a.m_e2*b.m_e2*c.m_e3-a.m_e2*b.m_e3*c.m_e2+a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e0+a.m_e2_e3_e0*b.m_e2*c.m_e0-a.m_e2_e3_e0*b.m_e3*c.m_e2_e3_e0+a.m_e3*b.m_e1*c.m_e1+a.m_e3*b.m_e2*c.m_e2+a.m_e3*b.m_e3*c.m_e3-a.m_e3_e1_e0*b.m_e1*c.m_e0+a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e0-a.m_e3_e1_e0*b.m_e3*c.m_e3_e1_e0), // e3
			(a.m_e0*b.m_e1*c.m_e1+a.m_e0*b.m_e2*c.m_e2+a.m_e0*b.m_e3*c.m_e3+a.m_e1*b.m_e1*c.m_e0-a.m_e1*b.m_e2*c.m_e1_e2_e0+a.m_e1*b.m_e3*c.m_e3_e1_e0-a.m_e1_e2_e0*b.m_e1*c.m_e2+a.m_e1_e2_e0*b.m_e2*c.m_e1-a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e2*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e0+a.m_e2*b.m_e1*c.m_e1_e2_e0+a.m_e2*b.m_e2*c.m_e0-a.m_e2*b.m_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e2*c.m_e3+a.m_e2_e3_e0*b.m_e3*c.m_e2-a.m_e3*b.m_e1*c.m_e3_e1_e0+a.m_e3*b.m_e2*c.m_e2_e3_e0+a.m_e3*b.m_e3*c.m_e0+a.m_e3_e1_e0*b.m_e1*c.m_e3-a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e3*c.m_e1) // e0
		);
}
inline point applyVersorWI(const oddVersor &a, const normalizedPoint &b, const oddVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*b.m_e1*c.m_e0+a.m_e0*b.m_e2*c.m_e1_e2_e0-a.m_e0*b.m_e3*c.m_e3_e1_e0+a.m_e0*c.m_e1+a.m_e1*b.m_e1*c.m_e1+a.m_e1*b.m_e2*c.m_e2+a.m_e1*b.m_e3*c.m_e3+a.m_e1*c.m_e0-a.m_e1_e2_e0*b.m_e1*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2*c.m_e0+a.m_e1_e2_e0*b.m_e3*c.m_e2_e3_e0+a.m_e1_e2_e0*c.m_e2-a.m_e1_e2_e3*b.m_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2*c.m_e3+a.m_e1_e2_e3*b.m_e3*c.m_e2-a.m_e1_e2_e3*c.m_e2_e3_e0-a.m_e2*b.m_e1*c.m_e2+a.m_e2*b.m_e2*c.m_e1-a.m_e2*b.m_e3*c.m_e1_e2_e3-a.m_e2*c.m_e1_e2_e0+a.m_e2_e3_e0*b.m_e1*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e2*c.m_e3_e1_e0+a.m_e2_e3_e0*b.m_e3*c.m_e1_e2_e0-a.m_e2_e3_e0*c.m_e1_e2_e3-a.m_e3*b.m_e1*c.m_e3+a.m_e3*b.m_e2*c.m_e1_e2_e3+a.m_e3*b.m_e3*c.m_e1+a.m_e3*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e1*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3*c.m_e0-a.m_e3_e1_e0*c.m_e3), // e1
			(-a.m_e0*b.m_e1*c.m_e1_e2_e0-a.m_e0*b.m_e2*c.m_e0+a.m_e0*b.m_e3*c.m_e2_e3_e0+a.m_e0*c.m_e2+a.m_e1*b.m_e1*c.m_e2-a.m_e1*b.m_e2*c.m_e1+a.m_e1*b.m_e3*c.m_e1_e2_e3+a.m_e1*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e1*c.m_e0-a.m_e1_e2_e0*b.m_e2*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3*c.m_e3_e1_e0-a.m_e1_e2_e0*c.m_e1+a.m_e1_e2_e3*b.m_e1*c.m_e3-a.m_e1_e2_e3*b.m_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e3*c.m_e1-a.m_e1_e2_e3*c.m_e3_e1_e0+a.m_e2*b.m_e1*c.m_e1+a.m_e2*b.m_e2*c.m_e2+a.m_e2*b.m_e3*c.m_e3+a.m_e2*c.m_e0+a.m_e2_e3_e0*b.m_e1*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e2*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3*c.m_e0+a.m_e2_e3_e0*c.m_e3-a.m_e3*b.m_e1*c.m_e1_e2_e3-a.m_e3*b.m_e2*c.m_e3+a.m_e3*b.m_e3*c.m_e2-a.m_e3*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e1*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e2*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e3*c.m_e1_e2_e0-a.m_e3_e1_e0*c.m_e1_e2_e3), // e2
			(a.m_e0*b.m_e1*c.m_e3_e1_e0-a.m_e0*b.m_e2*c.m_e2_e3_e0-a.m_e0*b.m_e3*c.m_e0+a.m_e0*c.m_e3+a.m_e1*b.m_e1*c.m_e3-a.m_e1*b.m_e2*c.m_e1_e2_e3-a.m_e1*b.m_e3*c.m_e1-a.m_e1*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e1*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e2*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e0-a.m_e1_e2_e0*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1*c.m_e2+a.m_e1_e2_e3*b.m_e2*c.m_e1-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*c.m_e1_e2_e0+a.m_e2*b.m_e1*c.m_e1_e2_e3+a.m_e2*b.m_e2*c.m_e3-a.m_e2*b.m_e3*c.m_e2+a.m_e2*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e0+a.m_e2_e3_e0*b.m_e2*c.m_e0-a.m_e2_e3_e0*b.m_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*c.m_e2+a.m_e3*b.m_e1*c.m_e1+a.m_e3*b.m_e2*c.m_e2+a.m_e3*b.m_e3*c.m_e3+a.m_e3*c.m_e0-a.m_e3_e1_e0*b.m_e1*c.m_e0+a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e0-a.m_e3_e1_e0*b.m_e3*c.m_e3_e1_e0+a.m_e3_e1_e0*c.m_e1), // e3
			(a.m_e0*b.m_e1*c.m_e1+a.m_e0*b.m_e2*c.m_e2+a.m_e0*b.m_e3*c.m_e3+a.m_e0*c.m_e0+a.m_e1*b.m_e1*c.m_e0-a.m_e1*b.m_e2*c.m_e1_e2_e0+a.m_e1*b.m_e3*c.m_e3_e1_e0-a.m_e1*c.m_e1-a.m_e1_e2_e0*b.m_e1*c.m_e2+a.m_e1_e2_e0*b.m_e2*c.m_e1-a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e3-a.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e1*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e2*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e0+a.m_e1_e2_e3*c.m_e1_e2_e3+a.m_e2*b.m_e1*c.m_e1_e2_e0+a.m_e2*b.m_e2*c.m_e0-a.m_e2*b.m_e3*c.m_e2_e3_e0-a.m_e2*c.m_e2-a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e2*c.m_e3+a.m_e2_e3_e0*b.m_e3*c.m_e2-a.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e3*b.m_e1*c.m_e3_e1_e0+a.m_e3*b.m_e2*c.m_e2_e3_e0+a.m_e3*b.m_e3*c.m_e0-a.m_e3*c.m_e3+a.m_e3_e1_e0*b.m_e1*c.m_e3-a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e3*c.m_e1-a.m_e3_e1_e0*c.m_e3_e1_e0) // e0
		);
}
inline point applyVersorWI(const oddVersor &a, const point &b, const oddVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e0*b.m_e0*c.m_e1-a.m_e0*b.m_e1*c.m_e0+a.m_e0*b.m_e2*c.m_e1_e2_e0-a.m_e0*b.m_e3*c.m_e3_e1_e0+a.m_e1*b.m_e0*c.m_e0+a.m_e1*b.m_e1*c.m_e1+a.m_e1*b.m_e2*c.m_e2+a.m_e1*b.m_e3*c.m_e3+a.m_e1_e2_e0*b.m_e0*c.m_e2-a.m_e1_e2_e0*b.m_e1*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2*c.m_e0+a.m_e1_e2_e0*b.m_e3*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e0*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2*c.m_e3+a.m_e1_e2_e3*b.m_e3*c.m_e2-a.m_e2*b.m_e0*c.m_e1_e2_e0-a.m_e2*b.m_e1*c.m_e2+a.m_e2*b.m_e2*c.m_e1-a.m_e2*b.m_e3*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e0*c.m_e1_e2_e3+a.m_e2_e3_e0*b.m_e1*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e2*c.m_e3_e1_e0+a.m_e2_e3_e0*b.m_e3*c.m_e1_e2_e0+a.m_e3*b.m_e0*c.m_e3_e1_e0-a.m_e3*b.m_e1*c.m_e3+a.m_e3*b.m_e2*c.m_e1_e2_e3+a.m_e3*b.m_e3*c.m_e1-a.m_e3_e1_e0*b.m_e0*c.m_e3-a.m_e3_e1_e0*b.m_e1*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3*c.m_e0), // e1
			(a.m_e0*b.m_e0*c.m_e2-a.m_e0*b.m_e1*c.m_e1_e2_e0-a.m_e0*b.m_e2*c.m_e0+a.m_e0*b.m_e3*c.m_e2_e3_e0+a.m_e1*b.m_e0*c.m_e1_e2_e0+a.m_e1*b.m_e1*c.m_e2-a.m_e1*b.m_e2*c.m_e1+a.m_e1*b.m_e3*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e0*c.m_e1+a.m_e1_e2_e0*b.m_e1*c.m_e0-a.m_e1_e2_e0*b.m_e2*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e0*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e1*c.m_e3-a.m_e1_e2_e3*b.m_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e3*c.m_e1+a.m_e2*b.m_e0*c.m_e0+a.m_e2*b.m_e1*c.m_e1+a.m_e2*b.m_e2*c.m_e2+a.m_e2*b.m_e3*c.m_e3+a.m_e2_e3_e0*b.m_e0*c.m_e3+a.m_e2_e3_e0*b.m_e1*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e2*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3*c.m_e0-a.m_e3*b.m_e0*c.m_e2_e3_e0-a.m_e3*b.m_e1*c.m_e1_e2_e3-a.m_e3*b.m_e2*c.m_e3+a.m_e3*b.m_e3*c.m_e2-a.m_e3_e1_e0*b.m_e0*c.m_e1_e2_e3+a.m_e3_e1_e0*b.m_e1*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e2*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e3*c.m_e1_e2_e0), // e2
			(a.m_e0*b.m_e0*c.m_e3+a.m_e0*b.m_e1*c.m_e3_e1_e0-a.m_e0*b.m_e2*c.m_e2_e3_e0-a.m_e0*b.m_e3*c.m_e0-a.m_e1*b.m_e0*c.m_e3_e1_e0+a.m_e1*b.m_e1*c.m_e3-a.m_e1*b.m_e2*c.m_e1_e2_e3-a.m_e1*b.m_e3*c.m_e1-a.m_e1_e2_e0*b.m_e0*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e1*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e2*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e1*c.m_e2+a.m_e1_e2_e3*b.m_e2*c.m_e1-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e3+a.m_e2*b.m_e0*c.m_e2_e3_e0+a.m_e2*b.m_e1*c.m_e1_e2_e3+a.m_e2*b.m_e2*c.m_e3-a.m_e2*b.m_e3*c.m_e2-a.m_e2_e3_e0*b.m_e0*c.m_e2+a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e0+a.m_e2_e3_e0*b.m_e2*c.m_e0-a.m_e2_e3_e0*b.m_e3*c.m_e2_e3_e0+a.m_e3*b.m_e0*c.m_e0+a.m_e3*b.m_e1*c.m_e1+a.m_e3*b.m_e2*c.m_e2+a.m_e3*b.m_e3*c.m_e3+a.m_e3_e1_e0*b.m_e0*c.m_e1-a.m_e3_e1_e0*b.m_e1*c.m_e0+a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e0-a.m_e3_e1_e0*b.m_e3*c.m_e3_e1_e0), // e3
			(a.m_e0*b.m_e0*c.m_e0+a.m_e0*b.m_e1*c.m_e1+a.m_e0*b.m_e2*c.m_e2+a.m_e0*b.m_e3*c.m_e3-a.m_e1*b.m_e0*c.m_e1+a.m_e1*b.m_e1*c.m_e0-a.m_e1*b.m_e2*c.m_e1_e2_e0+a.m_e1*b.m_e3*c.m_e3_e1_e0-a.m_e1_e2_e0*b.m_e0*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e1*c.m_e2+a.m_e1_e2_e0*b.m_e2*c.m_e1-a.m_e1_e2_e0*b.m_e3*c.m_e1_e2_e3+a.m_e1_e2_e3*b.m_e0*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e2*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e3*c.m_e1_e2_e0-a.m_e2*b.m_e0*c.m_e2+a.m_e2*b.m_e1*c.m_e1_e2_e0+a.m_e2*b.m_e2*c.m_e0-a.m_e2*b.m_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e0*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e1*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e2*c.m_e3+a.m_e2_e3_e0*b.m_e3*c.m_e2-a.m_e3*b.m_e0*c.m_e3-a.m_e3*b.m_e1*c.m_e3_e1_e0+a.m_e3*b.m_e2*c.m_e2_e3_e0+a.m_e3*b.m_e3*c.m_e0-a.m_e3_e1_e0*b.m_e0*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e1*c.m_e3-a.m_e3_e1_e0*b.m_e2*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e3*c.m_e1) // e0
		);
}
inline line applyVersorWI(const oddVersor &a, const bivector &b, const oddVersor &c)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e0*b.m_e1_e2*c.m_e2+a.m_e0*b.m_e2_e3*c.m_e1_e2_e3+a.m_e0*b.m_e3_e1*c.m_e3-a.m_e1*b.m_e1_e2*c.m_e1_e2_e0-a.m_e1*b.m_e2_e3*c.m_e2_e3_e0-a.m_e1*b.m_e3_e1*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e1-a.m_e1_e2_e0*b.m_e2_e3*c.m_e3+a.m_e1_e2_e0*b.m_e3_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1_e2*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e2_e3*c.m_e0+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1_e2_e0-a.m_e2*b.m_e1_e2*c.m_e0+a.m_e2*b.m_e2_e3*c.m_e3_e1_e0-a.m_e2*b.m_e3_e1*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e1_e2*c.m_e3+a.m_e2_e3_e0*b.m_e2_e3*c.m_e1+a.m_e2_e3_e0*b.m_e3_e1*c.m_e2-a.m_e3*b.m_e1_e2*c.m_e2_e3_e0+a.m_e3*b.m_e2_e3*c.m_e1_e2_e0+a.m_e3*b.m_e3_e1*c.m_e0-a.m_e3_e1_e0*b.m_e1_e2*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e2_e3*c.m_e2+a.m_e3_e1_e0*b.m_e3_e1*c.m_e1), // e0_e1
			-(a.m_e0*b.m_e1_e2*c.m_e1-a.m_e0*b.m_e2_e3*c.m_e3+a.m_e0*b.m_e3_e1*c.m_e1_e2_e3+a.m_e1*b.m_e1_e2*c.m_e0-a.m_e1*b.m_e2_e3*c.m_e3_e1_e0+a.m_e1*b.m_e3_e1*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e2-a.m_e1_e2_e0*b.m_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e3_e1*c.m_e3+a.m_e1_e2_e3*b.m_e1_e2*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e2_e3*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e3_e1*c.m_e0-a.m_e2*b.m_e1_e2*c.m_e1_e2_e0-a.m_e2*b.m_e2_e3*c.m_e2_e3_e0-a.m_e2*b.m_e3_e1*c.m_e3_e1_e0+a.m_e2_e3_e0*b.m_e1_e2*c.m_e1_e2_e3+a.m_e2_e3_e0*b.m_e2_e3*c.m_e2-a.m_e2_e3_e0*b.m_e3_e1*c.m_e1-a.m_e3*b.m_e1_e2*c.m_e3_e1_e0-a.m_e3*b.m_e2_e3*c.m_e0+a.m_e3*b.m_e3_e1*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e1_e2*c.m_e3+a.m_e3_e1_e0*b.m_e2_e3*c.m_e1+a.m_e3_e1_e0*b.m_e3_e1*c.m_e2), // e0_e2
			-(a.m_e0*b.m_e1_e2*c.m_e1_e2_e3+a.m_e0*b.m_e2_e3*c.m_e2-a.m_e0*b.m_e3_e1*c.m_e1+a.m_e1*b.m_e1_e2*c.m_e2_e3_e0-a.m_e1*b.m_e2_e3*c.m_e1_e2_e0-a.m_e1*b.m_e3_e1*c.m_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e3+a.m_e1_e2_e0*b.m_e2_e3*c.m_e1+a.m_e1_e2_e0*b.m_e3_e1*c.m_e2-a.m_e1_e2_e3*b.m_e1_e2*c.m_e0+a.m_e1_e2_e3*b.m_e2_e3*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e3_e1*c.m_e2_e3_e0+a.m_e2*b.m_e1_e2*c.m_e3_e1_e0+a.m_e2*b.m_e2_e3*c.m_e0-a.m_e2*b.m_e3_e1*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e1_e2*c.m_e1+a.m_e2_e3_e0*b.m_e2_e3*c.m_e3-a.m_e2_e3_e0*b.m_e3_e1*c.m_e1_e2_e3-a.m_e3*b.m_e1_e2*c.m_e1_e2_e0-a.m_e3*b.m_e2_e3*c.m_e2_e3_e0-a.m_e3*b.m_e3_e1*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e1_e2*c.m_e2+a.m_e3_e1_e0*b.m_e2_e3*c.m_e1_e2_e3+a.m_e3_e1_e0*b.m_e3_e1*c.m_e3), // e0_e3
			(a.m_e0*b.m_e1_e2*c.m_e0-a.m_e0*b.m_e2_e3*c.m_e3_e1_e0+a.m_e0*b.m_e3_e1*c.m_e2_e3_e0-a.m_e1*b.m_e1_e2*c.m_e1+a.m_e1*b.m_e2_e3*c.m_e3-a.m_e1*b.m_e3_e1*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e1_e2*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2_e3*c.m_e2_e3_e0-a.m_e1_e2_e0*b.m_e3_e1*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e1_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2_e3*c.m_e2+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1-a.m_e2*b.m_e1_e2*c.m_e2+a.m_e2*b.m_e2_e3*c.m_e1_e2_e3+a.m_e2*b.m_e3_e1*c.m_e3+a.m_e2_e3_e0*b.m_e1_e2*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e2_e3*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e0+a.m_e3*b.m_e1_e2*c.m_e3+a.m_e3*b.m_e2_e3*c.m_e1+a.m_e3*b.m_e3_e1*c.m_e2+a.m_e3_e1_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e0-a.m_e3_e1_e0*b.m_e3_e1*c.m_e1_e2_e0), // e1_e2
			(a.m_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e0*b.m_e2_e3*c.m_e0-a.m_e0*b.m_e3_e1*c.m_e1_e2_e0+a.m_e1*b.m_e1_e2*c.m_e3+a.m_e1*b.m_e2_e3*c.m_e1+a.m_e1*b.m_e3_e1*c.m_e2-a.m_e1_e2_e0*b.m_e1_e2*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e2_e3*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3_e1*c.m_e0+a.m_e1_e2_e3*b.m_e1_e2*c.m_e2-a.m_e1_e2_e3*b.m_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e3_e1*c.m_e3-a.m_e2*b.m_e1_e2*c.m_e1_e2_e3-a.m_e2*b.m_e2_e3*c.m_e2+a.m_e2*b.m_e3_e1*c.m_e1-a.m_e2_e3_e0*b.m_e1_e2*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e2_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e3_e1_e0+a.m_e3*b.m_e1_e2*c.m_e1-a.m_e3*b.m_e2_e3*c.m_e3+a.m_e3*b.m_e3_e1*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e1_e2*c.m_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e3_e1*c.m_e2_e3_e0), // e2_e3
			-(a.m_e0*b.m_e1_e2*c.m_e2_e3_e0-a.m_e0*b.m_e2_e3*c.m_e1_e2_e0-a.m_e0*b.m_e3_e1*c.m_e0-a.m_e1*b.m_e1_e2*c.m_e1_e2_e3-a.m_e1*b.m_e2_e3*c.m_e2+a.m_e1*b.m_e3_e1*c.m_e1+a.m_e1_e2_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e2_e3*c.m_e0-a.m_e1_e2_e0*b.m_e3_e1*c.m_e1_e2_e0+a.m_e1_e2_e3*b.m_e1_e2*c.m_e1-a.m_e1_e2_e3*b.m_e2_e3*c.m_e3+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1_e2_e3-a.m_e2*b.m_e1_e2*c.m_e3-a.m_e2*b.m_e2_e3*c.m_e1-a.m_e2*b.m_e3_e1*c.m_e2-a.m_e2_e3_e0*b.m_e1_e2*c.m_e0+a.m_e2_e3_e0*b.m_e2_e3*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e2_e3_e0-a.m_e3*b.m_e1_e2*c.m_e2+a.m_e3*b.m_e2_e3*c.m_e1_e2_e3+a.m_e3*b.m_e3_e1*c.m_e3+a.m_e3_e1_e0*b.m_e1_e2*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3_e1*c.m_e3_e1_e0) // e3_e1
		);
}
inline line applyVersorWI(const oddVersor &a, const line &b, const oddVersor &c)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(a.m_e0*b.m_e0_e1*c.m_e0-a.m_e0*b.m_e0_e2*c.m_e1_e2_e0+a.m_e0*b.m_e0_e3*c.m_e3_e1_e0-a.m_e0*b.m_e1_e2*c.m_e2+a.m_e0*b.m_e2_e3*c.m_e1_e2_e3+a.m_e0*b.m_e3_e1*c.m_e3+a.m_e1*b.m_e0_e1*c.m_e1+a.m_e1*b.m_e0_e2*c.m_e2+a.m_e1*b.m_e0_e3*c.m_e3-a.m_e1*b.m_e1_e2*c.m_e1_e2_e0-a.m_e1*b.m_e2_e3*c.m_e2_e3_e0-a.m_e1*b.m_e3_e1*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e0_e1*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e0_e2*c.m_e0-a.m_e1_e2_e0*b.m_e0_e3*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e1-a.m_e1_e2_e0*b.m_e2_e3*c.m_e3+a.m_e1_e2_e0*b.m_e3_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e0_e1*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e0_e2*c.m_e3+a.m_e1_e2_e3*b.m_e0_e3*c.m_e2-a.m_e1_e2_e3*b.m_e1_e2*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e2_e3*c.m_e0+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1_e2_e0-a.m_e2*b.m_e0_e1*c.m_e2+a.m_e2*b.m_e0_e2*c.m_e1-a.m_e2*b.m_e0_e3*c.m_e1_e2_e3-a.m_e2*b.m_e1_e2*c.m_e0+a.m_e2*b.m_e2_e3*c.m_e3_e1_e0-a.m_e2*b.m_e3_e1*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e0_e1*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e0_e2*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e0_e3*c.m_e1_e2_e0+a.m_e2_e3_e0*b.m_e1_e2*c.m_e3+a.m_e2_e3_e0*b.m_e2_e3*c.m_e1+a.m_e2_e3_e0*b.m_e3_e1*c.m_e2-a.m_e3*b.m_e0_e1*c.m_e3+a.m_e3*b.m_e0_e2*c.m_e1_e2_e3+a.m_e3*b.m_e0_e3*c.m_e1-a.m_e3*b.m_e1_e2*c.m_e2_e3_e0+a.m_e3*b.m_e2_e3*c.m_e1_e2_e0+a.m_e3*b.m_e3_e1*c.m_e0+a.m_e3_e1_e0*b.m_e0_e1*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e0_e2*c.m_e2_e3_e0-a.m_e3_e1_e0*b.m_e0_e3*c.m_e0-a.m_e3_e1_e0*b.m_e1_e2*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e2_e3*c.m_e2+a.m_e3_e1_e0*b.m_e3_e1*c.m_e1), // e0_e1
			-(a.m_e0*b.m_e0_e1*c.m_e1_e2_e0+a.m_e0*b.m_e0_e2*c.m_e0-a.m_e0*b.m_e0_e3*c.m_e2_e3_e0+a.m_e0*b.m_e1_e2*c.m_e1-a.m_e0*b.m_e2_e3*c.m_e3+a.m_e0*b.m_e3_e1*c.m_e1_e2_e3+a.m_e1*b.m_e0_e1*c.m_e2-a.m_e1*b.m_e0_e2*c.m_e1+a.m_e1*b.m_e0_e3*c.m_e1_e2_e3+a.m_e1*b.m_e1_e2*c.m_e0-a.m_e1*b.m_e2_e3*c.m_e3_e1_e0+a.m_e1*b.m_e3_e1*c.m_e2_e3_e0-a.m_e1_e2_e0*b.m_e0_e1*c.m_e0+a.m_e1_e2_e0*b.m_e0_e2*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e0_e3*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e2-a.m_e1_e2_e0*b.m_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e3_e1*c.m_e3+a.m_e1_e2_e3*b.m_e0_e1*c.m_e3-a.m_e1_e2_e3*b.m_e0_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e0_e3*c.m_e1+a.m_e1_e2_e3*b.m_e1_e2*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e2_e3*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e3_e1*c.m_e0+a.m_e2*b.m_e0_e1*c.m_e1+a.m_e2*b.m_e0_e2*c.m_e2+a.m_e2*b.m_e0_e3*c.m_e3-a.m_e2*b.m_e1_e2*c.m_e1_e2_e0-a.m_e2*b.m_e2_e3*c.m_e2_e3_e0-a.m_e2*b.m_e3_e1*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e0_e1*c.m_e3_e1_e0+a.m_e2_e3_e0*b.m_e0_e2*c.m_e2_e3_e0+a.m_e2_e3_e0*b.m_e0_e3*c.m_e0+a.m_e2_e3_e0*b.m_e1_e2*c.m_e1_e2_e3+a.m_e2_e3_e0*b.m_e2_e3*c.m_e2-a.m_e2_e3_e0*b.m_e3_e1*c.m_e1-a.m_e3*b.m_e0_e1*c.m_e1_e2_e3-a.m_e3*b.m_e0_e2*c.m_e3+a.m_e3*b.m_e0_e3*c.m_e2-a.m_e3*b.m_e1_e2*c.m_e3_e1_e0-a.m_e3*b.m_e2_e3*c.m_e0+a.m_e3*b.m_e3_e1*c.m_e1_e2_e0-a.m_e3_e1_e0*b.m_e0_e1*c.m_e2_e3_e0-a.m_e3_e1_e0*b.m_e0_e2*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e0_e3*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e1_e2*c.m_e3+a.m_e3_e1_e0*b.m_e2_e3*c.m_e1+a.m_e3_e1_e0*b.m_e3_e1*c.m_e2), // e0_e2
			-(-a.m_e0*b.m_e0_e1*c.m_e3_e1_e0+a.m_e0*b.m_e0_e2*c.m_e2_e3_e0+a.m_e0*b.m_e0_e3*c.m_e0+a.m_e0*b.m_e1_e2*c.m_e1_e2_e3+a.m_e0*b.m_e2_e3*c.m_e2-a.m_e0*b.m_e3_e1*c.m_e1+a.m_e1*b.m_e0_e1*c.m_e3-a.m_e1*b.m_e0_e2*c.m_e1_e2_e3-a.m_e1*b.m_e0_e3*c.m_e1+a.m_e1*b.m_e1_e2*c.m_e2_e3_e0-a.m_e1*b.m_e2_e3*c.m_e1_e2_e0-a.m_e1*b.m_e3_e1*c.m_e0-a.m_e1_e2_e0*b.m_e0_e1*c.m_e2_e3_e0-a.m_e1_e2_e0*b.m_e0_e2*c.m_e3_e1_e0-a.m_e1_e2_e0*b.m_e0_e3*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e1_e2*c.m_e3+a.m_e1_e2_e0*b.m_e2_e3*c.m_e1+a.m_e1_e2_e0*b.m_e3_e1*c.m_e2-a.m_e1_e2_e3*b.m_e0_e1*c.m_e2+a.m_e1_e2_e3*b.m_e0_e2*c.m_e1-a.m_e1_e2_e3*b.m_e0_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1_e2*c.m_e0+a.m_e1_e2_e3*b.m_e2_e3*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e3_e1*c.m_e2_e3_e0+a.m_e2*b.m_e0_e1*c.m_e1_e2_e3+a.m_e2*b.m_e0_e2*c.m_e3-a.m_e2*b.m_e0_e3*c.m_e2+a.m_e2*b.m_e1_e2*c.m_e3_e1_e0+a.m_e2*b.m_e2_e3*c.m_e0-a.m_e2*b.m_e3_e1*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e0_e1*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e0_e2*c.m_e0+a.m_e2_e3_e0*b.m_e0_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e1_e2*c.m_e1+a.m_e2_e3_e0*b.m_e2_e3*c.m_e3-a.m_e2_e3_e0*b.m_e3_e1*c.m_e1_e2_e3+a.m_e3*b.m_e0_e1*c.m_e1+a.m_e3*b.m_e0_e2*c.m_e2+a.m_e3*b.m_e0_e3*c.m_e3-a.m_e3*b.m_e1_e2*c.m_e1_e2_e0-a.m_e3*b.m_e2_e3*c.m_e2_e3_e0-a.m_e3*b.m_e3_e1*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e0_e1*c.m_e0-a.m_e3_e1_e0*b.m_e0_e2*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e0_e3*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e1_e2*c.m_e2+a.m_e3_e1_e0*b.m_e2_e3*c.m_e1_e2_e3+a.m_e3_e1_e0*b.m_e3_e1*c.m_e3), // e0_e3
			(a.m_e0*b.m_e0_e1*c.m_e2-a.m_e0*b.m_e0_e2*c.m_e1+a.m_e0*b.m_e0_e3*c.m_e1_e2_e3+a.m_e0*b.m_e1_e2*c.m_e0-a.m_e0*b.m_e2_e3*c.m_e3_e1_e0+a.m_e0*b.m_e3_e1*c.m_e2_e3_e0-a.m_e1*b.m_e0_e1*c.m_e1_e2_e0-a.m_e1*b.m_e0_e2*c.m_e0+a.m_e1*b.m_e0_e3*c.m_e2_e3_e0-a.m_e1*b.m_e1_e2*c.m_e1+a.m_e1*b.m_e2_e3*c.m_e3-a.m_e1*b.m_e3_e1*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e0_e1*c.m_e1+a.m_e1_e2_e0*b.m_e0_e2*c.m_e2+a.m_e1_e2_e0*b.m_e0_e3*c.m_e3-a.m_e1_e2_e0*b.m_e1_e2*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2_e3*c.m_e2_e3_e0-a.m_e1_e2_e0*b.m_e3_e1*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e0_e1*c.m_e3_e1_e0-a.m_e1_e2_e3*b.m_e0_e2*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e0_e3*c.m_e0-a.m_e1_e2_e3*b.m_e1_e2*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2_e3*c.m_e2+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1+a.m_e2*b.m_e0_e1*c.m_e0-a.m_e2*b.m_e0_e2*c.m_e1_e2_e0+a.m_e2*b.m_e0_e3*c.m_e3_e1_e0-a.m_e2*b.m_e1_e2*c.m_e2+a.m_e2*b.m_e2_e3*c.m_e1_e2_e3+a.m_e2*b.m_e3_e1*c.m_e3+a.m_e2_e3_e0*b.m_e0_e1*c.m_e3-a.m_e2_e3_e0*b.m_e0_e2*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e0_e3*c.m_e1+a.m_e2_e3_e0*b.m_e1_e2*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e2_e3*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e0-a.m_e3*b.m_e0_e1*c.m_e2_e3_e0-a.m_e3*b.m_e0_e2*c.m_e3_e1_e0-a.m_e3*b.m_e0_e3*c.m_e1_e2_e0+a.m_e3*b.m_e1_e2*c.m_e3+a.m_e3*b.m_e2_e3*c.m_e1+a.m_e3*b.m_e3_e1*c.m_e2+a.m_e3_e1_e0*b.m_e0_e1*c.m_e1_e2_e3+a.m_e3_e1_e0*b.m_e0_e2*c.m_e3-a.m_e3_e1_e0*b.m_e0_e3*c.m_e2+a.m_e3_e1_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e0-a.m_e3_e1_e0*b.m_e3_e1*c.m_e1_e2_e0), // e1_e2
			(a.m_e0*b.m_e0_e1*c.m_e1_e2_e3+a.m_e0*b.m_e0_e2*c.m_e3-a.m_e0*b.m_e0_e3*c.m_e2+a.m_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e0*b.m_e2_e3*c.m_e0-a.m_e0*b.m_e3_e1*c.m_e1_e2_e0-a.m_e1*b.m_e0_e1*c.m_e2_e3_e0-a.m_e1*b.m_e0_e2*c.m_e3_e1_e0-a.m_e1*b.m_e0_e3*c.m_e1_e2_e0+a.m_e1*b.m_e1_e2*c.m_e3+a.m_e1*b.m_e2_e3*c.m_e1+a.m_e1*b.m_e3_e1*c.m_e2-a.m_e1_e2_e0*b.m_e0_e1*c.m_e3+a.m_e1_e2_e0*b.m_e0_e2*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e0_e3*c.m_e1-a.m_e1_e2_e0*b.m_e1_e2*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e2_e3*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3_e1*c.m_e0-a.m_e1_e2_e3*b.m_e0_e1*c.m_e0+a.m_e1_e2_e3*b.m_e0_e2*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e0_e3*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e1_e2*c.m_e2-a.m_e1_e2_e3*b.m_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e3_e1*c.m_e3+a.m_e2*b.m_e0_e1*c.m_e3_e1_e0-a.m_e2*b.m_e0_e2*c.m_e2_e3_e0-a.m_e2*b.m_e0_e3*c.m_e0-a.m_e2*b.m_e1_e2*c.m_e1_e2_e3-a.m_e2*b.m_e2_e3*c.m_e2+a.m_e2*b.m_e3_e1*c.m_e1+a.m_e2_e3_e0*b.m_e0_e1*c.m_e1+a.m_e2_e3_e0*b.m_e0_e2*c.m_e2+a.m_e2_e3_e0*b.m_e0_e3*c.m_e3-a.m_e2_e3_e0*b.m_e1_e2*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e2_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e3_e1_e0+a.m_e3*b.m_e0_e1*c.m_e1_e2_e0+a.m_e3*b.m_e0_e2*c.m_e0-a.m_e3*b.m_e0_e3*c.m_e2_e3_e0+a.m_e3*b.m_e1_e2*c.m_e1-a.m_e3*b.m_e2_e3*c.m_e3+a.m_e3*b.m_e3_e1*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e0_e1*c.m_e2+a.m_e3_e1_e0*b.m_e0_e2*c.m_e1-a.m_e3_e1_e0*b.m_e0_e3*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e1_e2*c.m_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e3_e1*c.m_e2_e3_e0), // e2_e3
			-(a.m_e0*b.m_e0_e1*c.m_e3-a.m_e0*b.m_e0_e2*c.m_e1_e2_e3-a.m_e0*b.m_e0_e3*c.m_e1+a.m_e0*b.m_e1_e2*c.m_e2_e3_e0-a.m_e0*b.m_e2_e3*c.m_e1_e2_e0-a.m_e0*b.m_e3_e1*c.m_e0+a.m_e1*b.m_e0_e1*c.m_e3_e1_e0-a.m_e1*b.m_e0_e2*c.m_e2_e3_e0-a.m_e1*b.m_e0_e3*c.m_e0-a.m_e1*b.m_e1_e2*c.m_e1_e2_e3-a.m_e1*b.m_e2_e3*c.m_e2+a.m_e1*b.m_e3_e1*c.m_e1+a.m_e1_e2_e0*b.m_e0_e1*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e0_e2*c.m_e3-a.m_e1_e2_e0*b.m_e0_e3*c.m_e2+a.m_e1_e2_e0*b.m_e1_e2*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e2_e3*c.m_e0-a.m_e1_e2_e0*b.m_e3_e1*c.m_e1_e2_e0+a.m_e1_e2_e3*b.m_e0_e1*c.m_e1_e2_e0+a.m_e1_e2_e3*b.m_e0_e2*c.m_e0-a.m_e1_e2_e3*b.m_e0_e3*c.m_e2_e3_e0+a.m_e1_e2_e3*b.m_e1_e2*c.m_e1-a.m_e1_e2_e3*b.m_e2_e3*c.m_e3+a.m_e1_e2_e3*b.m_e3_e1*c.m_e1_e2_e3+a.m_e2*b.m_e0_e1*c.m_e2_e3_e0+a.m_e2*b.m_e0_e2*c.m_e3_e1_e0+a.m_e2*b.m_e0_e3*c.m_e1_e2_e0-a.m_e2*b.m_e1_e2*c.m_e3-a.m_e2*b.m_e2_e3*c.m_e1-a.m_e2*b.m_e3_e1*c.m_e2-a.m_e2_e3_e0*b.m_e0_e1*c.m_e2+a.m_e2_e3_e0*b.m_e0_e2*c.m_e1-a.m_e2_e3_e0*b.m_e0_e3*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e1_e2*c.m_e0+a.m_e2_e3_e0*b.m_e2_e3*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e3_e1*c.m_e2_e3_e0+a.m_e3*b.m_e0_e1*c.m_e0-a.m_e3*b.m_e0_e2*c.m_e1_e2_e0+a.m_e3*b.m_e0_e3*c.m_e3_e1_e0-a.m_e3*b.m_e1_e2*c.m_e2+a.m_e3*b.m_e2_e3*c.m_e1_e2_e3+a.m_e3*b.m_e3_e1*c.m_e3-a.m_e3_e1_e0*b.m_e0_e1*c.m_e1-a.m_e3_e1_e0*b.m_e0_e2*c.m_e2-a.m_e3_e1_e0*b.m_e0_e3*c.m_e3+a.m_e3_e1_e0*b.m_e1_e2*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e2_e3*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3_e1*c.m_e3_e1_e0) // e3_e1
		);
}
inline plane applyVersorWI(const oddVersor &a, const plane &b, const oddVersor &c)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e0*b.m_e1_e2_e0*c.m_e0+a.m_e0*b.m_e1_e2_e3*c.m_e3-a.m_e0*b.m_e2_e3_e0*c.m_e3_e1_e0+a.m_e0*b.m_e3_e1_e0*c.m_e2_e3_e0+a.m_e1*b.m_e1_e2_e0*c.m_e1-a.m_e1*b.m_e1_e2_e3*c.m_e3_e1_e0-a.m_e1*b.m_e2_e3_e0*c.m_e3+a.m_e1*b.m_e3_e1_e0*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e1_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e0*b.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e1_e2_e0*b.m_e3_e1_e0*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e1_e2_e0*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e1_e2_e3*c.m_e1_e2_e0+a.m_e1_e2_e3*b.m_e2_e3_e0*c.m_e2-a.m_e1_e2_e3*b.m_e3_e1_e0*c.m_e1+a.m_e2*b.m_e1_e2_e0*c.m_e2+a.m_e2*b.m_e1_e2_e3*c.m_e2_e3_e0-a.m_e2*b.m_e2_e3_e0*c.m_e1_e2_e3-a.m_e2*b.m_e3_e1_e0*c.m_e3+a.m_e2_e3_e0*b.m_e1_e2_e0*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e1_e2_e3*c.m_e2-a.m_e2_e3_e0*b.m_e2_e3_e0*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e3_e1_e0*c.m_e0-a.m_e3*b.m_e1_e2_e0*c.m_e3+a.m_e3*b.m_e1_e2_e3*c.m_e0-a.m_e3*b.m_e2_e3_e0*c.m_e1-a.m_e3*b.m_e3_e1_e0*c.m_e2+a.m_e3_e1_e0*b.m_e1_e2_e0*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e1_e2_e3*c.m_e1+a.m_e3_e1_e0*b.m_e2_e3_e0*c.m_e0-a.m_e3_e1_e0*b.m_e3_e1_e0*c.m_e1_e2_e0), // e1_e2_e0
			(a.m_e0*b.m_e1_e2_e0*c.m_e3_e1_e0+a.m_e0*b.m_e1_e2_e3*c.m_e1+a.m_e0*b.m_e2_e3_e0*c.m_e0-a.m_e0*b.m_e3_e1_e0*c.m_e1_e2_e0-a.m_e1*b.m_e1_e2_e0*c.m_e3+a.m_e1*b.m_e1_e2_e3*c.m_e0-a.m_e1*b.m_e2_e3_e0*c.m_e1-a.m_e1*b.m_e3_e1_e0*c.m_e2-a.m_e1_e2_e0*b.m_e1_e2_e0*c.m_e2_e3_e0+a.m_e1_e2_e0*b.m_e1_e2_e3*c.m_e2+a.m_e1_e2_e0*b.m_e2_e3_e0*c.m_e1_e2_e0+a.m_e1_e2_e0*b.m_e3_e1_e0*c.m_e0-a.m_e1_e2_e3*b.m_e1_e2_e0*c.m_e2-a.m_e1_e2_e3*b.m_e1_e2_e3*c.m_e2_e3_e0+a.m_e1_e2_e3*b.m_e2_e3_e0*c.m_e1_e2_e3+a.m_e1_e2_e3*b.m_e3_e1_e0*c.m_e3+a.m_e2*b.m_e1_e2_e0*c.m_e1_e2_e3-a.m_e2*b.m_e1_e2_e3*c.m_e1_e2_e0+a.m_e2*b.m_e2_e3_e0*c.m_e2-a.m_e2*b.m_e3_e1_e0*c.m_e1-a.m_e2_e3_e0*b.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e2_e3_e0*b.m_e1_e2_e3*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e3_e1_e0*c.m_e3_e1_e0-a.m_e3*b.m_e1_e2_e0*c.m_e1+a.m_e3*b.m_e1_e2_e3*c.m_e3_e1_e0+a.m_e3*b.m_e2_e3_e0*c.m_e3-a.m_e3*b.m_e3_e1_e0*c.m_e1_e2_e3-a.m_e3_e1_e0*b.m_e1_e2_e0*c.m_e0-a.m_e3_e1_e0*b.m_e1_e2_e3*c.m_e3+a.m_e3_e1_e0*b.m_e2_e3_e0*c.m_e3_e1_e0-a.m_e3_e1_e0*b.m_e3_e1_e0*c.m_e2_e3_e0), // e2_e3_e0
			-(a.m_e0*b.m_e1_e2_e0*c.m_e2_e3_e0-a.m_e0*b.m_e1_e2_e3*c.m_e2-a.m_e0*b.m_e2_e3_e0*c.m_e1_e2_e0-a.m_e0*b.m_e3_e1_e0*c.m_e0+a.m_e1*b.m_e1_e2_e0*c.m_e1_e2_e3-a.m_e1*b.m_e1_e2_e3*c.m_e1_e2_e0+a.m_e1*b.m_e2_e3_e0*c.m_e2-a.m_e1*b.m_e3_e1_e0*c.m_e1+a.m_e1_e2_e0*b.m_e1_e2_e0*c.m_e3_e1_e0+a.m_e1_e2_e0*b.m_e1_e2_e3*c.m_e1+a.m_e1_e2_e0*b.m_e2_e3_e0*c.m_e0-a.m_e1_e2_e0*b.m_e3_e1_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e1_e2_e0*c.m_e1+a.m_e1_e2_e3*b.m_e1_e2_e3*c.m_e3_e1_e0+a.m_e1_e2_e3*b.m_e2_e3_e0*c.m_e3-a.m_e1_e2_e3*b.m_e3_e1_e0*c.m_e1_e2_e3+a.m_e2*b.m_e1_e2_e0*c.m_e3-a.m_e2*b.m_e1_e2_e3*c.m_e0+a.m_e2*b.m_e2_e3_e0*c.m_e1+a.m_e2*b.m_e3_e1_e0*c.m_e2-a.m_e2_e3_e0*b.m_e1_e2_e0*c.m_e0-a.m_e2_e3_e0*b.m_e1_e2_e3*c.m_e3+a.m_e2_e3_e0*b.m_e2_e3_e0*c.m_e3_e1_e0-a.m_e2_e3_e0*b.m_e3_e1_e0*c.m_e2_e3_e0+a.m_e3*b.m_e1_e2_e0*c.m_e2+a.m_e3*b.m_e1_e2_e3*c.m_e2_e3_e0-a.m_e3*b.m_e2_e3_e0*c.m_e1_e2_e3-a.m_e3*b.m_e3_e1_e0*c.m_e3+a.m_e3_e1_e0*b.m_e1_e2_e0*c.m_e1_e2_e0+a.m_e3_e1_e0*b.m_e1_e2_e3*c.m_e1_e2_e3+a.m_e3_e1_e0*b.m_e2_e3_e0*c.m_e2_e3_e0+a.m_e3_e1_e0*b.m_e3_e1_e0*c.m_e3_e1_e0), // e3_e1_e0
			(a.m_e0*b.m_e1_e2_e0*c.m_e3-a.m_e0*b.m_e1_e2_e3*c.m_e0+a.m_e0*b.m_e2_e3_e0*c.m_e1+a.m_e0*b.m_e3_e1_e0*c.m_e2+a.m_e1*b.m_e1_e2_e0*c.m_e3_e1_e0+a.m_e1*b.m_e1_e2_e3*c.m_e1+a.m_e1*b.m_e2_e3_e0*c.m_e0-a.m_e1*b.m_e3_e1_e0*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e1_e2_e0*c.m_e1_e2_e3+a.m_e1_e2_e0*b.m_e1_e2_e3*c.m_e1_e2_e0-a.m_e1_e2_e0*b.m_e2_e3_e0*c.m_e2+a.m_e1_e2_e0*b.m_e3_e1_e0*c.m_e1-a.m_e1_e2_e3*b.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*b.m_e1_e2_e3*c.m_e1_e2_e3-a.m_e1_e2_e3*b.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e1_e2_e3*b.m_e3_e1_e0*c.m_e3_e1_e0-a.m_e2*b.m_e1_e2_e0*c.m_e2_e3_e0+a.m_e2*b.m_e1_e2_e3*c.m_e2+a.m_e2*b.m_e2_e3_e0*c.m_e1_e2_e0+a.m_e2*b.m_e3_e1_e0*c.m_e0+a.m_e2_e3_e0*b.m_e1_e2_e0*c.m_e2+a.m_e2_e3_e0*b.m_e1_e2_e3*c.m_e2_e3_e0-a.m_e2_e3_e0*b.m_e2_e3_e0*c.m_e1_e2_e3-a.m_e2_e3_e0*b.m_e3_e1_e0*c.m_e3+a.m_e3*b.m_e1_e2_e0*c.m_e0+a.m_e3*b.m_e1_e2_e3*c.m_e3-a.m_e3*b.m_e2_e3_e0*c.m_e3_e1_e0+a.m_e3*b.m_e3_e1_e0*c.m_e2_e3_e0-a.m_e3_e1_e0*b.m_e1_e2_e0*c.m_e1+a.m_e3_e1_e0*b.m_e1_e2_e3*c.m_e3_e1_e0+a.m_e3_e1_e0*b.m_e2_e3_e0*c.m_e3-a.m_e3_e1_e0*b.m_e3_e1_e0*c.m_e1_e2_e3) // e1_e2_e3
		);
}
inline point applyVersorWI(const oddVersor &a, const e1_t &b, const oddVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e0*c.m_e0+a.m_e1*c.m_e1-a.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*c.m_e1_e2_e3-a.m_e2*c.m_e2+a.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e3*c.m_e3-a.m_e3_e1_e0*c.m_e3_e1_e0), // e1
			(-a.m_e0*c.m_e1_e2_e0+a.m_e1*c.m_e2+a.m_e1_e2_e0*c.m_e0+a.m_e1_e2_e3*c.m_e3+a.m_e2*c.m_e1+a.m_e2_e3_e0*c.m_e3_e1_e0-a.m_e3*c.m_e1_e2_e3+a.m_e3_e1_e0*c.m_e2_e3_e0), // e2
			(a.m_e0*c.m_e3_e1_e0+a.m_e1*c.m_e3+a.m_e1_e2_e0*c.m_e2_e3_e0-a.m_e1_e2_e3*c.m_e2+a.m_e2*c.m_e1_e2_e3+a.m_e2_e3_e0*c.m_e1_e2_e0+a.m_e3*c.m_e1-a.m_e3_e1_e0*c.m_e0), // e3
			(a.m_e0*c.m_e1+a.m_e1*c.m_e0-a.m_e1_e2_e0*c.m_e2-a.m_e1_e2_e3*c.m_e2_e3_e0+a.m_e2*c.m_e1_e2_e0-a.m_e2_e3_e0*c.m_e1_e2_e3-a.m_e3*c.m_e3_e1_e0+a.m_e3_e1_e0*c.m_e3) // e0
		);
}
inline point applyVersorWI(const oddVersor &a, const e2_t &b, const oddVersor &c)
{
	return point(point::coord_e1_e2_e3_e0,
			(a.m_e0*c.m_e1_e2_e0+a.m_e1*c.m_e2-a.m_e1_e2_e0*c.m_e0-a.m_e1_e2_e3*c.m_e3+a.m_e2*c.m_e1+a.m_e2_e3_e0*c.m_e3_e1_e0+a.m_e3*c.m_e1_e2_e3+a.m_e3_e1_e0*c.m_e2_e3_e0), // e1
			(-a.m_e0*c.m_e0-a.m_e1*c.m_e1-a.m_e1_e2_e0*c.m_e1_e2_e0-a.m_e1_e2_e3*c.m_e1_e2_e3+a.m_e2*c.m_e2-a.m_e2_e3_e0*c.m_e2_e3_e0-a.m_e3*c.m_e3+a.m_e3_e1_e0*c.m_e3_e1_e0), // e2
			(-a.m_e0*c.m_e2_e3_e0-a.m_e1*c.m_e1_e2_e3+a.m_e1_e2_e0*c.m_e3_e1_e0+a.m_e1_e2_e3*c.m_e1+a.m_e2*c.m_e3+a.m_e2_e3_e0*c.m_e0+a.m_e3*c.m_e2+a.m_e3_e1_e0*c.m_e1_e2_e0), // e3
			(a.m_e0*c.m_e2-a.m_e1*c.m_e1_e2_e0+a.m_e1_e2_e0*c.m_e1-a.m_e1_e2_e3*c.m_e3_e1_e0+a.m_e2*c.m_e0-a.m_e2_e3_e0*c.m_e3+a.m_e3*c.m_e2_e3_e0-a.m_e3_e1_e0*c.m_e1_e2_e3) // e0
		);
}
inline vector div(const vector &a, const double b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)) // e3
		);
}
inline point div(const normalizedPoint &a, const double b)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)), // e3
			1.0 / (b) // e0
		);
}
inline bivector div(const bivector &a, const double b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline line div(const line &a, const double b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e0_e1/((b)), // e0_e1
			a.m_e0_e2/((b)), // e0_e2
			a.m_e0_e3/((b)), // e0_e3
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline plane div(const plane &a, const double b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0/((b)), // e1_e2_e0
			a.m_e2_e3_e0/((b)), // e2_e3_e0
			a.m_e3_e1_e0/((b)), // e3_e1_e0
			a.m_e1_e2_e3/((b)) // e1_e2_e3
		);
}
inline pseudoscalar div(const pseudoscalar &a, const double b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0/((b)) // e2_e1_e3_e0
		);
}
inline rotor div(const rotor &a, const double b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((b)), // scalar
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline evenVersor div(const evenVersor &a, const double b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((b)), // scalar
			a.m_e0_e1/((b)), // e0_e1
			a.m_e0_e2/((b)), // e0_e2
			a.m_e0_e3/((b)), // e0_e3
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)), // e3_e1
			a.m_e2_e1_e3_e0/((b)) // e2_e1_e3_e0
		);
}
inline oddVersor div(const oddVersor &a, const double b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)), // e3
			a.m_e0/((b)), // e0
			a.m_e1_e2_e0/((b)), // e1_e2_e0
			a.m_e2_e3_e0/((b)), // e2_e3_e0
			a.m_e3_e1_e0/((b)), // e3_e1_e0
			a.m_e1_e2_e3/((b)) // e1_e2_e3
		);
}
inline vector div(const e1_t &a, const double b)
{
	return vector(vector::coord_e1_e2_e3,
			1.0 / (b), // e1
			0.0, // e2
			0.0 // e3
		);
}
inline pseudoscalar div(const I4_t &a, const double b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-1.0 / (b) // e2_e1_e3_e0
		);
}
inline pseudoscalar dual(const double a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a // e2_e1_e3_e0
		);

}
inline pseudoscalar undual(const double a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a // e2_e1_e3_e0
		);

}
inline plane dual(const vector &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline plane undual(const vector &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline plane dual(const normalizedPoint &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			-1.0 // e1_e2_e3
		);

}
inline plane undual(const normalizedPoint &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			-1.0 // e1_e2_e3
		);

}
inline line dual(const bivector &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline line undual(const bivector &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline evenVersor dual(const rotor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-a.m_scalar // e2_e1_e3_e0
		);

}
inline evenVersor undual(const rotor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-a.m_scalar // e2_e1_e3_e0
		);

}
inline oddVersor dual(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e2_e3_e0, // e1
			a.m_e3_e1_e0, // e2
			a.m_e1_e2_e0, // e3
			-a.m_e1_e2_e3, // e0
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			-a.m_e0 // e1_e2_e3
		);

}
inline oddVersor undual(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e2_e3_e0, // e1
			a.m_e3_e1_e0, // e2
			a.m_e1_e2_e0, // e3
			-a.m_e1_e2_e3, // e0
			a.m_e3, // e1_e2_e0
			a.m_e1, // e2_e3_e0
			a.m_e2, // e3_e1_e0
			-a.m_e0 // e1_e2_e3
		);

}
inline evenVersor dual(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			-a.m_e2_e1_e3_e0, // scalar
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			a.m_e0_e3, // e1_e2
			a.m_e0_e1, // e2_e3
			a.m_e0_e2, // e3_e1
			-a.m_scalar // e2_e1_e3_e0
		);

}
inline evenVersor undual(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			-a.m_e2_e1_e3_e0, // scalar
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			a.m_e0_e3, // e1_e2
			a.m_e0_e1, // e2_e3
			a.m_e0_e2, // e3_e1
			-a.m_scalar // e2_e1_e3_e0
		);

}
inline line dual(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			a.m_e0_e3, // e1_e2
			a.m_e0_e1, // e2_e3
			a.m_e0_e2 // e3_e1
		);

}
inline line undual(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e2_e3, // e0_e1
			a.m_e3_e1, // e0_e2
			a.m_e1_e2, // e0_e3
			a.m_e0_e3, // e1_e2
			a.m_e0_e1, // e2_e3
			a.m_e0_e2 // e3_e1
		);

}
inline point dual(const plane &a)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e2_e3_e0, // e1
			a.m_e3_e1_e0, // e2
			a.m_e1_e2_e0, // e3
			-a.m_e1_e2_e3 // e0
		);

}
inline point undual(const plane &a)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e2_e3_e0, // e1
			a.m_e3_e1_e0, // e2
			a.m_e1_e2_e0, // e3
			-a.m_e1_e2_e3 // e0
		);

}
inline double dual(const pseudoscalar &a)
{
	return -a.m_e2_e1_e3_e0;

}
inline double undual(const pseudoscalar &a)
{
	return -a.m_e2_e1_e3_e0;

}
inline plane dual(const e1_t &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			0.0, // e1_e2_e0
			1.0, // e2_e3_e0
			0.0, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline plane undual(const e3_t &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			1.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline double dual(const I4_t &a)
{
	return 1.0;

}
inline double undual(const I4i_t &a)
{
	return 1.0;

}
inline bool equals(const vector &a, const vector &b, const double c)
{
	double d;
	d = a.m_e1 - b.m_e1; if ((d < -c) || (d > c)) return false; /* e1 */
	d = a.m_e2 - b.m_e2; if ((d < -c) || (d > c)) return false; /* e2 */
	d = a.m_e3 - b.m_e3; if ((d < -c) || (d > c)) return false; /* e3 */
	return true;
}
inline bool equals(const bivector &a, const bivector &b, const double c)
{
	double d;
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotor &a, const rotor &b, const double c)
{
	double d;
	d = a.m_scalar - b.m_scalar; if ((d < -c) || (d > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const bivector &a, const rotor &b, const double c)
{
	double d;
	if ((b.m_scalar < -c) || (b.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotor &a, const bivector &b, const double c)
{
	double d;
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotor &a, const line &b, const double c)
{
	double d;
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	if ((-b.m_e0_e1 < -c) || (-b.m_e0_e1 > c)) return false; /* e1^e0 */
	if ((-b.m_e0_e2 < -c) || (-b.m_e0_e2 > c)) return false; /* e2^e0 */
	if ((-b.m_e0_e3 < -c) || (-b.m_e0_e3 > c)) return false; /* e3^e0 */
	return true;
}
inline bool equals(const oddVersor &a, const plane &b, const double c)
{
	double d;
	if ((a.m_e1 < -c) || (a.m_e1 > c)) return false; /* e1 */
	if ((a.m_e2 < -c) || (a.m_e2 > c)) return false; /* e2 */
	if ((a.m_e3 < -c) || (a.m_e3 > c)) return false; /* e3 */
	d = a.m_e1_e2_e3 - b.m_e1_e2_e3; if ((d < -c) || (d > c)) return false; /* e1^e2^e3 */
	if ((a.m_e0 < -c) || (a.m_e0 > c)) return false; /* e0 */
	d = a.m_e1_e2_e0 - b.m_e1_e2_e0; if ((d < -c) || (d > c)) return false; /* e1^e2^e0 */
	d = -a.m_e3_e1_e0 - -b.m_e3_e1_e0; if ((d < -c) || (d > c)) return false; /* e1^e3^e0 */
	d = a.m_e2_e3_e0 - b.m_e2_e3_e0; if ((d < -c) || (d > c)) return false; /* e2^e3^e0 */
	return true;
}
inline bool equals(const line &a, const line &b, const double c)
{
	double d;
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	d = -a.m_e0_e1 - -b.m_e0_e1; if ((d < -c) || (d > c)) return false; /* e1^e0 */
	d = -a.m_e0_e2 - -b.m_e0_e2; if ((d < -c) || (d > c)) return false; /* e2^e0 */
	d = -a.m_e0_e3 - -b.m_e0_e3; if ((d < -c) || (d > c)) return false; /* e3^e0 */
	return true;
}
inline bool equals(const plane &a, const plane &b, const double c)
{
	double d;
	d = a.m_e1_e2_e3 - b.m_e1_e2_e3; if ((d < -c) || (d > c)) return false; /* e1^e2^e3 */
	d = a.m_e1_e2_e0 - b.m_e1_e2_e0; if ((d < -c) || (d > c)) return false; /* e1^e2^e0 */
	d = -a.m_e3_e1_e0 - -b.m_e3_e1_e0; if ((d < -c) || (d > c)) return false; /* e1^e3^e0 */
	d = a.m_e2_e3_e0 - b.m_e2_e3_e0; if ((d < -c) || (d > c)) return false; /* e2^e3^e0 */
	return true;
}
inline bool equals(const normalizedPoint &a, const normalizedPoint &b, const double c)
{
	double d;
	d = a.m_e1 - b.m_e1; if ((d < -c) || (d > c)) return false; /* e1 */
	d = a.m_e2 - b.m_e2; if ((d < -c) || (d > c)) return false; /* e2 */
	d = a.m_e3 - b.m_e3; if ((d < -c) || (d > c)) return false; /* e3 */
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* e0 */
	return true;
}
inline bool equals(const e1_t &a, const e1_t &b, const double c)
{
	double d;
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* e1 */
	return true;
}
inline bool equals(const e1_t &a, const e2_t &b, const double c)
{
	if ((1.0 < -c) || (1.0 > c)) return false; /* e1 */
	if ((1.0 < -c) || (1.0 > c)) return false; /* e2 */
	return true;
}
inline bool equals(const I4_t &a, const I4i_t &b, const double c)
{
	double d;
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* e1^e2^e3^e0 */
	return true;
}
inline double extractGrade0(const rotor &a)
{
	return a.m_scalar;
}
inline bivector extractGrade2(const rotor &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline double extractGrade0(const oddVersor &a)
{
	return 0.0;
}
inline point extractGrade1(const oddVersor &a)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_e0 // e0
		);
}
inline double extractGrade2(const oddVersor &a)
{
	return 0.0;
}
inline plane extractGrade3(const oddVersor &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0, // e1_e2_e0
			a.m_e2_e3_e0, // e2_e3_e0
			a.m_e3_e1_e0, // e3_e1_e0
			a.m_e1_e2_e3 // e1_e2_e3
		);
}
inline double extractGrade0(const evenVersor &a)
{
	return a.m_scalar;
}
inline double extractGrade1(const evenVersor &a)
{
	return 0.0;
}
inline line extractGrade2(const evenVersor &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e0_e1, // e0_e1
			a.m_e0_e2, // e0_e2
			a.m_e0_e3, // e0_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline double extractGrade3(const evenVersor &a)
{
	return 0.0;
}
inline pseudoscalar extractGrade4(const evenVersor &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);
}
inline double extractGrade0(const normalizedPoint &a)
{
	return 0.0;
}
inline normalizedPoint extractGrade1(const normalizedPoint &a)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);
}
inline double extractGrade2(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade3(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade4(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade0(const e1_t &a)
{
	return 0.0;
}
inline e2_t extractGrade1(const e2_t &a)
{
	return e2_t(		);
}
inline double extractGrade2(const e3_t &a)
{
	return 0.0;
}
inline double extractGrade3(const e0_t &a)
{
	return 0.0;
}
inline double extractGrade4(const e1_t &a)
{
	return 0.0;
}
inline double extractGrade0(const I4_t &a)
{
	return 0.0;
}
inline double extractGrade1(const I4i_t &a)
{
	return 0.0;
}
inline double extractGrade2(const I4_t &a)
{
	return 0.0;
}
inline double extractGrade3(const I4i_t &a)
{
	return 0.0;
}
inline I4_t extractGrade4(const I4_t &a)
{
	return I4_t(		);
}
inline rotor gp(const vector &a, const vector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor gp(const rotor &a, const vector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1+a.m_scalar*b.m_e3), // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2) // e1_e2_e3
		);

}
inline oddVersor gp(const vector &a, const line &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1*b.m_e0_e1-a.m_e2*b.m_e0_e2-a.m_e3*b.m_e0_e3), // e0
			(-a.m_e1*b.m_e0_e2+a.m_e2*b.m_e0_e1), // e1_e2_e0
			(-a.m_e2*b.m_e0_e3+a.m_e3*b.m_e0_e2), // e2_e3_e0
			-(-a.m_e1*b.m_e0_e3+a.m_e3*b.m_e0_e1), // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline evenVersor gp(const rotor &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			-(-a.m_e1_e2*b.m_e0_e2+a.m_e3_e1*b.m_e0_e3-a.m_scalar*b.m_e0_e1), // e0_e1
			-(a.m_e1_e2*b.m_e0_e1-a.m_e2_e3*b.m_e0_e3-a.m_scalar*b.m_e0_e2), // e0_e2
			-(a.m_e2_e3*b.m_e0_e2-a.m_e3_e1*b.m_e0_e1-a.m_scalar*b.m_e0_e3), // e0_e3
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_scalar*b.m_e3_e1), // e3_e1
			-(-a.m_e1_e2*b.m_e0_e3-a.m_e2_e3*b.m_e0_e1-a.m_e3_e1*b.m_e0_e2) // e2_e1_e3_e0
		);

}
inline oddVersor gp(const vector &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline rotor gp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1+a.m_e2_e3*b.m_scalar-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline oddVersor gp(const plane &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e3*b.m_e2_e3, // e1
			-a.m_e1_e2_e3*b.m_e3_e1, // e2
			-a.m_e1_e2_e3*b.m_e1_e2, // e3
			(-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			(a.m_e1_e2_e0*b.m_scalar-a.m_e2_e3_e0*b.m_e3_e1+a.m_e3_e1_e0*b.m_e2_e3), // e1_e2_e0
			(a.m_e1_e2_e0*b.m_e3_e1+a.m_e2_e3_e0*b.m_scalar-a.m_e3_e1_e0*b.m_e1_e2), // e2_e3_e0
			-(a.m_e1_e2_e0*b.m_e2_e3-a.m_e2_e3_e0*b.m_e1_e2-a.m_e3_e1_e0*b.m_scalar), // e3_e1_e0
			a.m_e1_e2_e3*b.m_scalar // e1_e2_e3
		);

}
inline oddVersor gp(const plane &a, const line &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2_e0*b.m_e0_e2-a.m_e1_e2_e3*b.m_e2_e3-a.m_e3_e1_e0*b.m_e0_e3), // e1
			(-a.m_e1_e2_e0*b.m_e0_e1-a.m_e1_e2_e3*b.m_e3_e1+a.m_e2_e3_e0*b.m_e0_e3), // e2
			(-a.m_e1_e2_e3*b.m_e1_e2-a.m_e2_e3_e0*b.m_e0_e2+a.m_e3_e1_e0*b.m_e0_e1), // e3
			(-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			(-a.m_e1_e2_e3*b.m_e0_e3-a.m_e2_e3_e0*b.m_e3_e1+a.m_e3_e1_e0*b.m_e2_e3), // e1_e2_e0
			(a.m_e1_e2_e0*b.m_e3_e1-a.m_e1_e2_e3*b.m_e0_e1-a.m_e3_e1_e0*b.m_e1_e2), // e2_e3_e0
			-(a.m_e1_e2_e0*b.m_e2_e3+a.m_e1_e2_e3*b.m_e0_e2-a.m_e2_e3_e0*b.m_e1_e2), // e3_e1_e0
			(a.m_e1_e2_e0*b.m_e0_e3+a.m_e2_e3_e0*b.m_e0_e1+a.m_e3_e1_e0*b.m_e0_e2) // e1_e2_e3
		);

}
inline rotor gp(const bivector &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2) // e3_e1
		);

}
inline evenVersor gp(const point &a, const point &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(a.m_e0*b.m_e0+a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			-(-a.m_e0*b.m_e1+a.m_e1*b.m_e0), // e0_e1
			-(-a.m_e0*b.m_e2+a.m_e2*b.m_e0), // e0_e2
			-(-a.m_e0*b.m_e3+a.m_e3*b.m_e0), // e0_e3
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1), // e3_e1
			0.0 // e2_e1_e3_e0
		);

}
inline evenVersor gp(const normalizedPoint &a, const normalizedPoint &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(1.0+a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			-(a.m_e1-b.m_e1), // e0_e1
			-(a.m_e2-b.m_e2), // e0_e2
			-(a.m_e3-b.m_e3), // e0_e3
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1), // e3_e1
			0.0 // e2_e1_e3_e0
		);

}
inline oddVersor gp(const pseudoscalar &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e2_e1_e3_e0*b.m_e2_e3_e0, // e1
			a.m_e2_e1_e3_e0*b.m_e3_e1_e0, // e2
			a.m_e2_e1_e3_e0*b.m_e1_e2_e0, // e3
			-a.m_e2_e1_e3_e0*b.m_e1_e2_e3, // e0
			a.m_e2_e1_e3_e0*b.m_e3, // e1_e2_e0
			a.m_e2_e1_e3_e0*b.m_e1, // e2_e3_e0
			a.m_e2_e1_e3_e0*b.m_e2, // e3_e1_e0
			-a.m_e2_e1_e3_e0*b.m_e0 // e1_e2_e3
		);

}
inline bivector gp(const e1_t &a, const e2_t &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			1.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline line gp(const e3_t &a, const e0_t &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			0.0, // e0_e1
			0.0, // e0_e2
			-1.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline plane gp(const e3_t &a, const I4i_t &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			1.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline rotor gp_null(const vector &a, const vector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor gp_null(const rotor &a, const vector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1+a.m_scalar*b.m_e3), // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2) // e1_e2_e3
		);

}
inline oddVersor gp_null(const vector &a, const line &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1*b.m_e0_e1-a.m_e2*b.m_e0_e2-a.m_e3*b.m_e0_e3), // e0
			(-a.m_e1*b.m_e0_e2+a.m_e2*b.m_e0_e1), // e1_e2_e0
			(-a.m_e2*b.m_e0_e3+a.m_e3*b.m_e0_e2), // e2_e3_e0
			-(-a.m_e1*b.m_e0_e3+a.m_e3*b.m_e0_e1), // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline evenVersor gp_null(const rotor &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			-(-a.m_e1_e2*b.m_e0_e2+a.m_e3_e1*b.m_e0_e3-a.m_scalar*b.m_e0_e1), // e0_e1
			-(a.m_e1_e2*b.m_e0_e1-a.m_e2_e3*b.m_e0_e3-a.m_scalar*b.m_e0_e2), // e0_e2
			-(a.m_e2_e3*b.m_e0_e2-a.m_e3_e1*b.m_e0_e1-a.m_scalar*b.m_e0_e3), // e0_e3
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_scalar*b.m_e3_e1), // e3_e1
			-(-a.m_e1_e2*b.m_e0_e3-a.m_e2_e3*b.m_e0_e1-a.m_e3_e1*b.m_e0_e2) // e2_e1_e3_e0
		);

}
inline oddVersor gp_null(const vector &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline rotor gp_null(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1+a.m_e2_e3*b.m_scalar-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline oddVersor gp_null(const plane &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e3*b.m_e2_e3, // e1
			-a.m_e1_e2_e3*b.m_e3_e1, // e2
			-a.m_e1_e2_e3*b.m_e1_e2, // e3
			(-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			(a.m_e1_e2_e0*b.m_scalar-a.m_e2_e3_e0*b.m_e3_e1+a.m_e3_e1_e0*b.m_e2_e3), // e1_e2_e0
			(a.m_e1_e2_e0*b.m_e3_e1+a.m_e2_e3_e0*b.m_scalar-a.m_e3_e1_e0*b.m_e1_e2), // e2_e3_e0
			-(a.m_e1_e2_e0*b.m_e2_e3-a.m_e2_e3_e0*b.m_e1_e2-a.m_e3_e1_e0*b.m_scalar), // e3_e1_e0
			a.m_e1_e2_e3*b.m_scalar // e1_e2_e3
		);

}
inline oddVersor gp_null(const plane &a, const line &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e3*b.m_e2_e3, // e1
			-a.m_e1_e2_e3*b.m_e3_e1, // e2
			-a.m_e1_e2_e3*b.m_e1_e2, // e3
			(-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			(-a.m_e1_e2_e3*b.m_e0_e3-a.m_e2_e3_e0*b.m_e3_e1+a.m_e3_e1_e0*b.m_e2_e3), // e1_e2_e0
			(a.m_e1_e2_e0*b.m_e3_e1-a.m_e1_e2_e3*b.m_e0_e1-a.m_e3_e1_e0*b.m_e1_e2), // e2_e3_e0
			-(a.m_e1_e2_e0*b.m_e2_e3+a.m_e1_e2_e3*b.m_e0_e2-a.m_e2_e3_e0*b.m_e1_e2), // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline rotor gp_null(const bivector &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2) // e3_e1
		);

}
inline oddVersor gp_null(const pseudoscalar &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			0.0, // e1
			0.0, // e2
			0.0, // e3
			-a.m_e2_e1_e3_e0*b.m_e1_e2_e3, // e0
			a.m_e2_e1_e3_e0*b.m_e3, // e1_e2_e0
			a.m_e2_e1_e3_e0*b.m_e1, // e2_e3_e0
			a.m_e2_e1_e3_e0*b.m_e2, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline int gradeBitmap(const rotor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_scalar < -b) || (a.m_scalar > b)) bitmap |= 1;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const oddVersor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1 < -b) || (a.m_e1 > b)) bitmap |= 2;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) bitmap |= 2;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) bitmap |= 2;
	if ((a.m_e0 < -b) || (a.m_e0 > b)) bitmap |= 2;
	if ((a.m_e1_e2_e0 < -b) || (a.m_e1_e2_e0 > b)) bitmap |= 8;
	if ((a.m_e2_e3_e0 < -b) || (a.m_e2_e3_e0 > b)) bitmap |= 8;
	if ((a.m_e3_e1_e0 < -b) || (a.m_e3_e1_e0 > b)) bitmap |= 8;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) bitmap |= 8;
	return bitmap;
}
inline int gradeBitmap(const evenVersor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_scalar < -b) || (a.m_scalar > b)) bitmap |= 1;
	if ((a.m_e0_e1 < -b) || (a.m_e0_e1 > b)) bitmap |= 4;
	if ((a.m_e0_e2 < -b) || (a.m_e0_e2 > b)) bitmap |= 4;
	if ((a.m_e0_e3 < -b) || (a.m_e0_e3 > b)) bitmap |= 4;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	if ((a.m_e2_e1_e3_e0 < -b) || (a.m_e2_e1_e3_e0 > b)) bitmap |= 16;
	return bitmap;
}
inline int gradeBitmap(const vector &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1 < -b) || (a.m_e1 > b)) bitmap |= 2;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) bitmap |= 2;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const bivector &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const pseudoscalar &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e2_e1_e3_e0 < -b) || (a.m_e2_e1_e3_e0 > b)) bitmap |= 16;
	return bitmap;
}
inline int gradeBitmap(const line &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e0_e1 < -b) || (a.m_e0_e1 > b)) bitmap |= 4;
	if ((a.m_e0_e2 < -b) || (a.m_e0_e2 > b)) bitmap |= 4;
	if ((a.m_e0_e3 < -b) || (a.m_e0_e3 > b)) bitmap |= 4;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const plane &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1_e2_e0 < -b) || (a.m_e1_e2_e0 > b)) bitmap |= 8;
	if ((a.m_e2_e3_e0 < -b) || (a.m_e2_e3_e0 > b)) bitmap |= 8;
	if ((a.m_e3_e1_e0 < -b) || (a.m_e3_e1_e0 > b)) bitmap |= 8;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) bitmap |= 8;
	return bitmap;
}
inline int gradeBitmap(const e1_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const e2_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const I4_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 16;
	return bitmap;
}
inline int gradeBitmap(const I4i_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 16;
	return bitmap;
}
inline vector hp(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline bivector hp(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline rotor hp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar*b.m_scalar, // scalar
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline oddVersor hp(const oddVersor &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3, // e3
			a.m_e0*b.m_e0, // e0
			a.m_e1_e2_e0*b.m_e1_e2_e0, // e1_e2_e0
			a.m_e2_e3_e0*b.m_e2_e3_e0, // e2_e3_e0
			a.m_e3_e1_e0*b.m_e3_e1_e0, // e3_e1_e0
			a.m_e1_e2_e3*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline vector hp(const vector &a, const oddVersor &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline evenVersor hp(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar*b.m_scalar, // scalar
			a.m_e0_e1*b.m_e0_e1, // e0_e1
			a.m_e0_e2*b.m_e0_e2, // e0_e2
			a.m_e0_e3*b.m_e0_e3, // e0_e3
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0*b.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline bivector hp(const bivector &a, const rotor &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline pseudoscalar hp(const pseudoscalar &a, const evenVersor &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0*b.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline double hp(const pseudoscalar &a, const oddVersor &b)
{
	return 0.0;

}
inline bivector hp(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline bivector hp(const evenVersor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline point hp(const point &a, const point &b)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3, // e3
			a.m_e0*b.m_e0 // e0
		);

}
inline normalizedPoint hp(const normalizedPoint &a, const normalizedPoint &b)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline vector hp(const vector &a, const e1_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline pseudoscalar hp(const I4_t &a, const pseudoscalar &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-b.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline pseudoscalar hp(const pseudoscalar &a, const I4i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline vector ihp(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline bivector ihp(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline rotor ihp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((b.m_scalar)), // scalar
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline oddVersor ihp(const oddVersor &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)), // e3
			a.m_e0/((b.m_e0)), // e0
			a.m_e1_e2_e0/((b.m_e1_e2_e0)), // e1_e2_e0
			a.m_e2_e3_e0/((b.m_e2_e3_e0)), // e2_e3_e0
			-a.m_e3_e1_e0/((-b.m_e3_e1_e0)), // e3_e1_e0
			a.m_e1_e2_e3/((b.m_e1_e2_e3)) // e1_e2_e3
		);

}
inline vector ihp(const vector &a, const oddVersor &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline evenVersor ihp(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((b.m_scalar)), // scalar
			-a.m_e0_e1/((-b.m_e0_e1)), // e0_e1
			-a.m_e0_e2/((-b.m_e0_e2)), // e0_e2
			-a.m_e0_e3/((-b.m_e0_e3)), // e0_e3
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)), // e3_e1
			-a.m_e2_e1_e3_e0/((-b.m_e2_e1_e3_e0)) // e2_e1_e3_e0
		);

}
inline bivector ihp(const bivector &a, const rotor &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline pseudoscalar ihp(const pseudoscalar &a, const evenVersor &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a.m_e2_e1_e3_e0/((-b.m_e2_e1_e3_e0)) // e2_e1_e3_e0
		);

}
inline double ihp(const pseudoscalar &a, const oddVersor &b)
{
	return 0.0;

}
inline bivector ihp(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline bivector ihp(const evenVersor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline point ihp(const point &a, const point &b)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)), // e3
			a.m_e0/((b.m_e0)) // e0
		);

}
inline normalizedPoint ihp(const normalizedPoint &a, const normalizedPoint &b)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline vector ihp(const vector &a, const e1_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline pseudoscalar ihp(const I4_t &a, const pseudoscalar &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			1.0 / (-b.m_e2_e1_e3_e0) // e2_e1_e3_e0
		);

}
inline pseudoscalar ihp(const pseudoscalar &a, const I4i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline rotor increment(const bivector &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotor increment(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline evenVersor increment(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(1.0+a.m_scalar), // scalar
			a.m_e0_e1, // e0_e1
			a.m_e0_e2, // e0_e2
			a.m_e0_e3, // e0_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);
}
inline evenVersor increment(const pseudoscalar &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			1.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);
}
inline evenVersor increment(const I4_t &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			1.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-1.0 // e2_e1_e3_e0
		);
}
inline rotor decrement(const bivector &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotor decrement(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline evenVersor decrement(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(-1.0+a.m_scalar), // scalar
			a.m_e0_e1, // e0_e1
			a.m_e0_e2, // e0_e2
			a.m_e0_e3, // e0_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);
}
inline evenVersor decrement(const pseudoscalar &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			-1.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);
}
inline evenVersor decrement(const I4i_t &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			-1.0, // scalar
			0.0, // e0_e1
			0.0, // e0_e2
			0.0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-1.0 // e2_e1_e3_e0
		);
}
inline double sp(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline line lc(const vector &a, const plane &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e2*b.m_e1_e2_e0+a.m_e3*b.m_e3_e1_e0), // e0_e1
			-(a.m_e1*b.m_e1_e2_e0-a.m_e3*b.m_e2_e3_e0), // e0_e2
			-(-a.m_e1*b.m_e3_e1_e0+a.m_e2*b.m_e2_e3_e0), // e0_e3
			a.m_e3*b.m_e1_e2_e3, // e1_e2
			a.m_e1*b.m_e1_e2_e3, // e2_e3
			a.m_e2*b.m_e1_e2_e3 // e3_e1
		);

}
inline double rc(const vector &a, const line &b)
{
	return 0.0;

}
inline double hip(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline plane mhip(const pseudoscalar &a, const vector &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e2_e1_e3_e0*b.m_e3, // e1_e2_e0
			a.m_e2_e1_e3_e0*b.m_e1, // e2_e3_e0
			a.m_e2_e1_e3_e0*b.m_e2, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline double sp(const bivector &a, const oddVersor &b)
{
	return 0.0;

}
inline double lc(const bivector &a, const vector &b)
{
	return 0.0;

}
inline oddVersor rc(const evenVersor &a, const vector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1), // e3
			(a.m_e0_e1*b.m_e1+a.m_e0_e2*b.m_e2+a.m_e0_e3*b.m_e3), // e0
			a.m_e2_e1_e3_e0*b.m_e3, // e1_e2_e0
			a.m_e2_e1_e3_e0*b.m_e1, // e2_e3_e0
			a.m_e2_e1_e3_e0*b.m_e2, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline evenVersor hip(const oddVersor &a, const vector &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			-(-a.m_e1_e2_e0*b.m_e2+a.m_e3_e1_e0*b.m_e3), // e0_e1
			-(a.m_e1_e2_e0*b.m_e1-a.m_e2_e3_e0*b.m_e3), // e0_e2
			-(a.m_e2_e3_e0*b.m_e2-a.m_e3_e1_e0*b.m_e1), // e0_e3
			a.m_e1_e2_e3*b.m_e3, // e1_e2
			a.m_e1_e2_e3*b.m_e1, // e2_e3
			a.m_e1_e2_e3*b.m_e2, // e3_e1
			0.0 // e2_e1_e3_e0
		);

}
inline vector mhip(const bivector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1) // e3
		);

}
inline double sp(const vector &a, const pseudoscalar &b)
{
	return 0.0;

}
inline oddVersor lc(const vector &a, const evenVersor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1*b.m_e0_e1-a.m_e2*b.m_e0_e2-a.m_e3*b.m_e0_e3), // e0
			-a.m_e3*b.m_e2_e1_e3_e0, // e1_e2_e0
			-a.m_e1*b.m_e2_e1_e3_e0, // e2_e3_e0
			-a.m_e2*b.m_e2_e1_e3_e0, // e3_e1_e0
			0.0 // e1_e2_e3
		);

}
inline double rc(const vector &a, const bivector &b)
{
	return 0.0;

}
inline line hip(const vector &a, const plane &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-(-a.m_e2*b.m_e1_e2_e0+a.m_e3*b.m_e3_e1_e0), // e0_e1
			-(a.m_e1*b.m_e1_e2_e0-a.m_e3*b.m_e2_e3_e0), // e0_e2
			-(-a.m_e1*b.m_e3_e1_e0+a.m_e2*b.m_e2_e3_e0), // e0_e3
			a.m_e3*b.m_e1_e2_e3, // e1_e2
			a.m_e1*b.m_e1_e2_e3, // e2_e3
			a.m_e2*b.m_e1_e2_e3 // e3_e1
		);

}
inline point mhip(const vector &a, const line &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1*b.m_e0_e1-a.m_e2*b.m_e0_e2-a.m_e3*b.m_e0_e3) // e0
		);

}
inline double sp(const evenVersor &a, const rotor &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar);

}
inline rotor lc(const evenVersor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1 // e3_e1
		);

}
inline oddVersor rc(const oddVersor &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1*b.m_scalar-a.m_e1_e2_e3*b.m_e2_e3), // e1
			(-a.m_e1_e2_e3*b.m_e3_e1+a.m_e2*b.m_scalar), // e2
			(-a.m_e1_e2_e3*b.m_e1_e2+a.m_e3*b.m_scalar), // e3
			(a.m_e0*b.m_scalar-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			a.m_e1_e2_e0*b.m_scalar, // e1_e2_e0
			a.m_e2_e3_e0*b.m_scalar, // e2_e3_e0
			a.m_e3_e1_e0*b.m_scalar, // e3_e1_e0
			a.m_e1_e2_e3*b.m_scalar // e1_e2_e3
		);

}
inline point hip(const oddVersor &a, const rotor &b)
{
	return point(point::coord_e1_e2_e3_e0,
			(-a.m_e1_e2_e3*b.m_e2_e3-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e1_e2_e3*b.m_e3_e1-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1-a.m_e1_e2_e3*b.m_e1_e2+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1) // e0
		);

}
inline oddVersor mhip(const oddVersor &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(a.m_e1*b.m_scalar-a.m_e1_e2_e3*b.m_e2_e3-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e1_e2_e3*b.m_e3_e1+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1-a.m_e1_e2_e3*b.m_e1_e2+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			(a.m_e0*b.m_scalar-a.m_e1_e2_e0*b.m_e1_e2-a.m_e2_e3_e0*b.m_e2_e3-a.m_e3_e1_e0*b.m_e3_e1), // e0
			a.m_e1_e2_e0*b.m_scalar, // e1_e2_e0
			a.m_e2_e3_e0*b.m_scalar, // e2_e3_e0
			a.m_e3_e1_e0*b.m_scalar, // e3_e1_e0
			a.m_e1_e2_e3*b.m_scalar // e1_e2_e3
		);

}
inline double sp(const e1_t &a, const rotor &b)
{
	return 0.0;

}
inline vector lc(const e2_t &a, const rotor &b)
{
	return vector(vector::coord_e1_e2_e3,
			-b.m_e1_e2, // e1
			0.0, // e2
			b.m_e2_e3 // e3
		);

}
inline evenVersor rc(const I4_t &a, const rotor &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			b.m_e2_e3, // e0_e1
			b.m_e3_e1, // e0_e2
			b.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-b.m_scalar // e2_e1_e3_e0
		);

}
inline line hip(const I4i_t &a, const rotor &b)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			b.m_e2_e3, // e0_e1
			b.m_e3_e1, // e0_e2
			b.m_e1_e2, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline point mhip(const e0_t &a, const rotor &b)
{
	return point(point::coord_e1_e2_e3_e0,
			0.0, // e1
			0.0, // e2
			0.0, // e3
			b.m_scalar // e0
		);

}
inline double sp(const e1_t &a, const e1_t &b)
{
	return 1.0;

}
inline double lc(const e2_t &a, const e3_t &b)
{
	return 0.0;

}
inline double rc(const I4_t &a, const I4i_t &b)
{
	return 1.0;

}
inline plane hip(const I4i_t &a, const e0_t &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			1.0 // e1_e2_e3
		);

}
inline double mhip(const e0_t &a, const e1_t &b)
{
	return 0.0;

}
inline double sp(const rotor &a, const plane &b)
{
	return 0.0;

}
inline evenVersor lc(const rotor &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			a.m_scalar*b.m_e0_e1, // e0_e1
			a.m_scalar*b.m_e0_e2, // e0_e2
			a.m_scalar*b.m_e0_e3, // e0_e3
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1, // e3_e1
			0.0 // e2_e1_e3_e0
		);

}
inline rotor rc(const rotor &a, const evenVersor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			a.m_e1_e2*b.m_scalar, // e1_e2
			a.m_e2_e3*b.m_scalar, // e2_e3
			a.m_e3_e1*b.m_scalar // e3_e1
		);

}
inline double hip(const rotor &a, const bivector &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1);

}
inline evenVersor mhip(const rotor &a, const pseudoscalar &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			-a.m_e2_e3*b.m_e2_e1_e3_e0, // e0_e1
			-a.m_e3_e1*b.m_e2_e1_e3_e0, // e0_e2
			-a.m_e1_e2*b.m_e2_e1_e3_e0, // e0_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			a.m_scalar*b.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline double norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline double norm(const vector &a)
{
	return ::fabs(::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

}
inline double norm_returns_scalar(const vector &a) {
	return norm(a);
}
inline double norm(const bivector &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

}
inline double norm_returns_scalar(const bivector &a) {
	return norm(a);
}
inline double norm(const line &a)
{
	return ::fabs(::sqrt((a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

}
inline double norm_returns_scalar(const line &a) {
	return norm(a);
}
inline double norm(const plane &a)
{
	return ::fabs(::sqrt((a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3_e1_e0*a.m_e3_e1_e0)));

}
inline double norm_returns_scalar(const plane &a) {
	return norm(a);
}
inline double norm(const rotor &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

}
inline double norm_returns_scalar(const rotor &a) {
	return norm(a);
}
inline double norm(const oddVersor &a)
{
	return ::fabs(::sqrt((a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0)));

}
inline double norm_returns_scalar(const oddVersor &a) {
	return norm(a);
}
inline double norm(const evenVersor &a)
{
	return ::fabs(::sqrt((a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

}
inline double norm_returns_scalar(const evenVersor &a) {
	return norm(a);
}
inline double norm(const normalizedPoint &a)
{
	return ::fabs(::sqrt((1.0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

}
inline double norm_returns_scalar(const normalizedPoint &a) {
	return norm(a);
}
inline double norm(const point &a)
{
	return ::fabs(::sqrt((a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

}
inline double norm_returns_scalar(const point &a) {
	return norm(a);
}
inline double norm(const pseudoscalar &a)
{
	return ::fabs(::sqrt(a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0));

}
inline double norm_returns_scalar(const pseudoscalar &a) {
	return norm(a);
}
inline double norm(const e1_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const e1_t &a) {
	return norm(a);
}
inline double norm(const e2_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const e2_t &a) {
	return norm(a);
}
inline double norm(const I4i_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const I4i_t &a) {
	return norm(a);
}
inline double norm2_returns_scalar(const mv &a) {
	return norm2(a);
}
inline double norm2(const vector &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_returns_scalar(const vector &a) {
	return norm2(a);
}
inline double norm2(const bivector &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_returns_scalar(const bivector &a) {
	return norm2(a);
}
inline double norm2(const normalizedPoint &a)
{
	return (1.0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_returns_scalar(const normalizedPoint &a) {
	return norm2(a);
}
inline double norm2(const point &a)
{
	return (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_returns_scalar(const point &a) {
	return norm2(a);
}
inline double norm2(const line &a)
{
	return (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_returns_scalar(const line &a) {
	return norm2(a);
}
inline double norm2(const plane &a)
{
	return (a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3_e1_e0*a.m_e3_e1_e0);

}
inline double norm2_returns_scalar(const plane &a) {
	return norm2(a);
}
inline double norm2(const rotor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_returns_scalar(const rotor &a) {
	return norm2(a);
}
inline double norm2(const oddVersor &a)
{
	return (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

}
inline double norm2_returns_scalar(const oddVersor &a) {
	return norm2(a);
}
inline double norm2(const evenVersor &a)
{
	return (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_returns_scalar(const evenVersor &a) {
	return norm2(a);
}
inline double norm2(const pseudoscalar &a)
{
	return a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0;

}
inline double norm2_returns_scalar(const pseudoscalar &a) {
	return norm2(a);
}
inline double norm2(const e3_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const e3_t &a) {
	return norm2(a);
}
inline double norm2(const e0_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const e0_t &a) {
	return norm2(a);
}
inline double norm2(const I4_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const I4_t &a) {
	return norm2(a);
}
inline double norm_null_returns_scalar(const mv &a) {
	return norm_null(a);
}
inline double norm_null(const vector &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3))));

}
inline double norm_null_returns_scalar(const vector &a) {
	return norm_null(a);
}
inline double norm_null(const bivector &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1))));

}
inline double norm_null_returns_scalar(const bivector &a) {
	return norm_null(a);
}
inline double norm_null(const line &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1))));

}
inline double norm_null_returns_scalar(const line &a) {
	return norm_null(a);
}
inline double norm_null(const plane &a)
{
	return ::fabs(::sqrt(::fabs(a.m_e1_e2_e3*a.m_e1_e2_e3)));

}
inline double norm_null_returns_scalar(const plane &a) {
	return norm_null(a);
}
inline double norm_null(const rotor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))));

}
inline double norm_null_returns_scalar(const rotor &a) {
	return norm_null(a);
}
inline double norm_null(const oddVersor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e3*a.m_e3))));

}
inline double norm_null_returns_scalar(const oddVersor &a) {
	return norm_null(a);
}
inline double norm_null(const evenVersor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))));

}
inline double norm_null_returns_scalar(const evenVersor &a) {
	return norm_null(a);
}
inline double norm_null(const pseudoscalar &a)
{
	return ::fabs(0.0);

}
inline double norm_null_returns_scalar(const pseudoscalar &a) {
	return norm_null(a);
}
inline double norm2_null_returns_scalar(const mv &a) {
	return norm2_null(a);
}
inline double norm2_null(const vector &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_null_returns_scalar(const vector &a) {
	return norm2_null(a);
}
inline double norm2_null(const bivector &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_null_returns_scalar(const bivector &a) {
	return norm2_null(a);
}
inline double norm2_null(const line &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_null_returns_scalar(const line &a) {
	return norm2_null(a);
}
inline double norm2_null(const plane &a)
{
	return a.m_e1_e2_e3*a.m_e1_e2_e3;

}
inline double norm2_null_returns_scalar(const plane &a) {
	return norm2_null(a);
}
inline double norm2_null(const rotor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_null_returns_scalar(const rotor &a) {
	return norm2_null(a);
}
inline double norm2_null(const oddVersor &a)
{
	return (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_null_returns_scalar(const oddVersor &a) {
	return norm2_null(a);
}
inline double norm2_null(const evenVersor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_null_returns_scalar(const evenVersor &a) {
	return norm2_null(a);
}
inline double norm2_null(const pseudoscalar &a)
{
	return 0.0;

}
inline double norm2_null_returns_scalar(const pseudoscalar &a) {
	return norm2_null(a);
}
inline double norm2_null(const e0_t &a)
{
	return 0.0;

}
inline double norm2_null_returns_scalar(const e0_t &a) {
	return norm2_null(a);
}
inline double norm2_null(const I4_t &a)
{
	return 0.0;

}
inline double norm2_null_returns_scalar(const I4_t &a) {
	return norm2_null(a);
}
inline double norm2_null(const e1_t &a)
{
	return 1.0;

}
inline double norm2_null_returns_scalar(const e1_t &a) {
	return norm2_null(a);
}
inline bivector op(const vector &a, const vector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor op(const rotor &a, const vector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_scalar*b.m_e1, // e1
			a.m_scalar*b.m_e2, // e2
			a.m_scalar*b.m_e3, // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2) // e1_e2_e3
		);

}
inline plane op(const vector &a, const line &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			(-a.m_e1*b.m_e0_e2+a.m_e2*b.m_e0_e1), // e1_e2_e0
			(-a.m_e2*b.m_e0_e3+a.m_e3*b.m_e0_e2), // e2_e3_e0
			-(-a.m_e1*b.m_e0_e3+a.m_e3*b.m_e0_e1), // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline evenVersor op(const rotor &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			0.0, // scalar
			a.m_scalar*b.m_e0_e1, // e0_e1
			a.m_scalar*b.m_e0_e2, // e0_e2
			a.m_scalar*b.m_e0_e3, // e0_e3
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1, // e3_e1
			-(-a.m_e1_e2*b.m_e0_e3-a.m_e2_e3*b.m_e0_e1-a.m_e3_e1*b.m_e0_e2) // e2_e1_e3_e0
		);

}
inline oddVersor op(const vector &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1*b.m_scalar, // e1
			a.m_e2*b.m_scalar, // e2
			a.m_e3*b.m_scalar, // e3
			0.0, // e0
			0.0, // e1_e2_e0
			0.0, // e2_e3_e0
			0.0, // e3_e1_e0
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline rotor op(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar*b.m_scalar, // scalar
			(a.m_e1_e2*b.m_scalar+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e2_e3*b.m_scalar+a.m_scalar*b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline plane op(const plane &a, const rotor &b)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0*b.m_scalar, // e1_e2_e0
			a.m_e2_e3_e0*b.m_scalar, // e2_e3_e0
			a.m_e3_e1_e0*b.m_scalar, // e3_e1_e0
			a.m_e1_e2_e3*b.m_scalar // e1_e2_e3
		);

}
inline double op(const plane &a, const line &b)
{
	return 0.0;

}
inline double op(const bivector &a, const bivector &b)
{
	return 0.0;

}
inline double op(const pseudoscalar &a, const oddVersor &b)
{
	return 0.0;

}
inline bivector op(const e1_t &a, const e2_t &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			1.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline double op(const e0_t &a, const I4i_t &b)
{
	return 0.0;

}
inline rotor exp(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			::cos(_alpha), // scalar
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline double cosh(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	return ::cos(_alpha);
}
inline bivector sinh(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline double cos(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	return ::cosh(_alpha);
}
inline bivector sin(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sinh(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline vector negate(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline bivector negate(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline point negate(const normalizedPoint &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-1.0 // e0
		);

}
inline point negate(const point &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0 // e0
		);

}
inline line negate(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline plane negate(const plane &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor negate(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor negate(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0, // e0
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline evenVersor negate(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			-a.m_scalar, // scalar
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			-a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline pseudoscalar negate(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			-a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline vector negate(const e1_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			-1.0, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline vector negate(const e2_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			0.0, // e1
			-1.0, // e2
			0.0 // e3
		);

}
inline pseudoscalar negate(const I4_t &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			1.0 // e2_e1_e3_e0
		);

}
inline double negate(const double a)
{
	return -a;

}
inline vector reverse(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);

}
inline bivector reverse(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline normalizedPoint reverse(const normalizedPoint &a)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);

}
inline point reverse(const point &a)
{
	return point(point::coord_e1_e2_e3_e0,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_e0 // e0
		);

}
inline line reverse(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline plane reverse(const plane &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor reverse(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor reverse(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_e0, // e0
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline evenVersor reverse(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar, // scalar
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline pseudoscalar reverse(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline double reverse(const double a)
{
	return a;

}
inline e0_t reverse(const e0_t &a)
{
	return e0_t(		);

}
inline e3_t reverse(const e3_t &a)
{
	return e3_t(		);

}
inline I4_t reverse(const I4i_t &a)
{
	return I4_t(		);

}
inline vector cliffordConjugate(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline bivector cliffordConjugate(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline point cliffordConjugate(const normalizedPoint &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-1.0 // e0
		);

}
inline point cliffordConjugate(const point &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0 // e0
		);

}
inline line cliffordConjugate(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline plane cliffordConjugate(const plane &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0, // e1_e2_e0
			a.m_e2_e3_e0, // e2_e3_e0
			a.m_e3_e1_e0, // e3_e1_e0
			a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor cliffordConjugate(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor cliffordConjugate(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0, // e0
			a.m_e1_e2_e0, // e1_e2_e0
			a.m_e2_e3_e0, // e2_e3_e0
			a.m_e3_e1_e0, // e3_e1_e0
			a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline evenVersor cliffordConjugate(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar, // scalar
			-a.m_e0_e1, // e0_e1
			-a.m_e0_e2, // e0_e2
			-a.m_e0_e3, // e0_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline pseudoscalar cliffordConjugate(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline double cliffordConjugate(const double a)
{
	return a;

}
inline point cliffordConjugate(const e0_t &a)
{
	return point(point::coord_e1_e2_e3_e0,
			0.0, // e1
			0.0, // e2
			0.0, // e3
			-1.0 // e0
		);

}
inline vector cliffordConjugate(const e3_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			0.0, // e1
			0.0, // e2
			-1.0 // e3
		);

}
inline I4_t cliffordConjugate(const I4i_t &a)
{
	return I4_t(		);

}
inline vector gradeInvolution(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline bivector gradeInvolution(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline point gradeInvolution(const normalizedPoint &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-1.0 // e0
		);

}
inline point gradeInvolution(const point &a)
{
	return point(point::coord_e1_e2_e3_e0,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0 // e0
		);

}
inline line gradeInvolution(const line &a)
{
	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e0_e1, // e0_e1
			a.m_e0_e2, // e0_e2
			a.m_e0_e3, // e0_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline plane gradeInvolution(const plane &a)
{
	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor gradeInvolution(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline oddVersor gradeInvolution(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_e0, // e0
			-a.m_e1_e2_e0, // e1_e2_e0
			-a.m_e2_e3_e0, // e2_e3_e0
			-a.m_e3_e1_e0, // e3_e1_e0
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline evenVersor gradeInvolution(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar, // scalar
			a.m_e0_e1, // e0_e1
			a.m_e0_e2, // e0_e2
			a.m_e0_e3, // e0_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline pseudoscalar gradeInvolution(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0 // e2_e1_e3_e0
		);

}
inline double gradeInvolution(const double a)
{
	return a;

}
inline vector gradeInvolution(const e2_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			0.0, // e1
			-1.0, // e2
			0.0 // e3
		);

}
inline vector gradeInvolution(const e1_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			-1.0, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline I4_t gradeInvolution(const I4_t &a)
{
	return I4_t(		);

}
inline vector unit(const vector &a)
{
	double _n_ = ::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)) // e3
		);
}
inline bivector unit(const bivector &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1));

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline line unit(const line &a)
{
	double _n_ = ::sqrt((a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1));

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e0_e1/((_n_)), // e0_e1
			a.m_e0_e2/((_n_)), // e0_e2
			a.m_e0_e3/((_n_)), // e0_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline plane unit(const plane &a)
{
	double _n_ = ::sqrt((a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3_e1_e0*a.m_e3_e1_e0));

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0/((_n_)), // e1_e2_e0
			a.m_e2_e3_e0/((_n_)), // e2_e3_e0
			a.m_e3_e1_e0/((_n_)), // e3_e1_e0
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline rotor unit(const rotor &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar));

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n_)), // scalar
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline oddVersor unit(const oddVersor &a)
{
	double _n_ = ::sqrt((a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0));

	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_e0/((_n_)), // e0
			a.m_e1_e2_e0/((_n_)), // e1_e2_e0
			a.m_e2_e3_e0/((_n_)), // e2_e3_e0
			a.m_e3_e1_e0/((_n_)), // e3_e1_e0
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline evenVersor unit(const evenVersor &a)
{
	double _n_ = ::sqrt((a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar));

	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((_n_)), // scalar
			a.m_e0_e1/((_n_)), // e0_e1
			a.m_e0_e2/((_n_)), // e0_e2
			a.m_e0_e3/((_n_)), // e0_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)), // e3_e1
			a.m_e2_e1_e3_e0/((_n_)) // e2_e1_e3_e0
		);
}
inline point unit(const normalizedPoint &a)
{
	double _n_ = ::sqrt((1.0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			1.0 / (_n_) // e0
		);
}
inline point unit(const point &a)
{
	double _n_ = ::sqrt((a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_e0/((_n_)) // e0
		);
}
inline pseudoscalar unit(const pseudoscalar &a)
{
	double _n_ = ::sqrt(a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0);

	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0/((_n_)) // e2_e1_e3_e0
		);
}
inline e1_t unit(const e1_t &a)
{
	return e1_t(		);
}
inline e2_t unit(const e2_t &a)
{
	return e2_t(		);
}
inline I4_t unit(const I4_t &a)
{
	return I4_t(		);
}
inline vector unit_null(const vector &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)) // e3
		);
}
inline bivector unit_null(const bivector &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline line unit_null(const line &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			a.m_e0_e1/((_n_)), // e0_e1
			a.m_e0_e2/((_n_)), // e0_e2
			a.m_e0_e3/((_n_)), // e0_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline plane unit_null(const plane &a)
{
	double _n_ = ::sqrt(::fabs(a.m_e1_e2_e3*a.m_e1_e2_e3));

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1_e2_e0/((_n_)), // e1_e2_e0
			a.m_e2_e3_e0/((_n_)), // e2_e3_e0
			a.m_e3_e1_e0/((_n_)), // e3_e1_e0
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline rotor unit_null(const rotor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n_)), // scalar
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline oddVersor unit_null(const oddVersor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_e0/((_n_)), // e0
			a.m_e1_e2_e0/((_n_)), // e1_e2_e0
			a.m_e2_e3_e0/((_n_)), // e2_e3_e0
			a.m_e3_e1_e0/((_n_)), // e3_e1_e0
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline evenVersor unit_null(const evenVersor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((_n_)), // scalar
			a.m_e0_e1/((_n_)), // e0_e1
			a.m_e0_e2/((_n_)), // e0_e2
			a.m_e0_e3/((_n_)), // e0_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)), // e3_e1
			a.m_e2_e1_e3_e0/((_n_)) // e2_e1_e3_e0
		);
}
inline vector versorInverse(const vector &a)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)) // e3
		);
}
inline bivector versorInverse(const bivector &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline line versorInverse(const line &a)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-a.m_e0_e1/((_n2_)), // e0_e1
			-a.m_e0_e2/((_n2_)), // e0_e2
			-a.m_e0_e3/((_n2_)), // e0_e3
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline plane versorInverse(const plane &a)
{
	double _n2_ = (a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e0/((_n2_)), // e1_e2_e0
			-a.m_e2_e3_e0/((_n2_)), // e2_e3_e0
			-a.m_e3_e1_e0/((_n2_)), // e3_e1_e0
			-a.m_e1_e2_e3/((_n2_)) // e1_e2_e3
		);
}
inline rotor versorInverse(const rotor &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n2_)), // scalar
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline oddVersor versorInverse(const oddVersor &a)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e1_e2_e0*a.m_e1_e2_e0+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e2_e3_e0*a.m_e2_e3_e0+a.m_e3*a.m_e3+a.m_e3_e1_e0*a.m_e3_e1_e0);

	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)), // e3
			a.m_e0/((_n2_)), // e0
			-a.m_e1_e2_e0/((_n2_)), // e1_e2_e0
			-a.m_e2_e3_e0/((_n2_)), // e2_e3_e0
			-a.m_e3_e1_e0/((_n2_)), // e3_e1_e0
			-a.m_e1_e2_e3/((_n2_)) // e1_e2_e3
		);
}
inline evenVersor versorInverse(const evenVersor &a)
{
	double _n2_ = (a.m_e0_e1*a.m_e0_e1+a.m_e0_e2*a.m_e0_e2+a.m_e0_e3*a.m_e0_e3+a.m_e1_e2*a.m_e1_e2+a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((_n2_)), // scalar
			-a.m_e0_e1/((_n2_)), // e0_e1
			-a.m_e0_e2/((_n2_)), // e0_e2
			-a.m_e0_e3/((_n2_)), // e0_e3
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)), // e3_e1
			a.m_e2_e1_e3_e0/((_n2_)) // e2_e1_e3_e0
		);
}
inline point versorInverse(const normalizedPoint &a)
{
	double _n2_ = (1.0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)), // e3
			1.0 / (_n2_) // e0
		);
}
inline point versorInverse(const point &a)
{
	double _n2_ = (a.m_e0*a.m_e0+a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return point(point::coord_e1_e2_e3_e0,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)), // e3
			a.m_e0/((_n2_)) // e0
		);
}
inline pseudoscalar versorInverse(const pseudoscalar &a)
{
	double _n2_ = a.m_e2_e1_e3_e0*a.m_e2_e1_e3_e0;

	return pseudoscalar(pseudoscalar::coord_e2e1e3e0,
			a.m_e2_e1_e3_e0/((_n2_)) // e2_e1_e3_e0
		);
}
inline e1_t versorInverse(const e1_t &a)
{
	return e1_t(		);
}
inline e2_t versorInverse(const e2_t &a)
{
	return e2_t(		);
}
inline I4_t versorInverse(const I4_t &a)
{
	return I4_t(		);
}
inline vector versorInverse_null(const vector &a)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)) // e3
		);
}
inline bivector versorInverse_null(const bivector &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline line versorInverse_null(const line &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

	return line(line::coord_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1,
			-a.m_e0_e1/((_n2_)), // e0_e1
			-a.m_e0_e2/((_n2_)), // e0_e2
			-a.m_e0_e3/((_n2_)), // e0_e3
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline plane versorInverse_null(const plane &a)
{
	double _n2_ = a.m_e1_e2_e3*a.m_e1_e2_e3;

	return plane(plane::coord_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			-a.m_e1_e2_e0/((_n2_)), // e1_e2_e0
			-a.m_e2_e3_e0/((_n2_)), // e2_e3_e0
			-a.m_e3_e1_e0/((_n2_)), // e3_e1_e0
			-a.m_e1_e2_e3/((_n2_)) // e1_e2_e3
		);
}
inline rotor versorInverse_null(const rotor &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n2_)), // scalar
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline oddVersor versorInverse_null(const oddVersor &a)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return oddVersor(oddVersor::coord_e1_e2_e3_e0_e1e2e0_e2e3e0_e3e1e0_e1e2e3,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)), // e3
			a.m_e0/((_n2_)), // e0
			-a.m_e1_e2_e0/((_n2_)), // e1_e2_e0
			-a.m_e2_e3_e0/((_n2_)), // e2_e3_e0
			-a.m_e3_e1_e0/((_n2_)), // e3_e1_e0
			-a.m_e1_e2_e3/((_n2_)) // e1_e2_e3
		);
}
inline evenVersor versorInverse_null(const evenVersor &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return evenVersor(evenVersor::coord_scalar_e0e1_e0e2_e0e3_e1e2_e2e3_e3e1_e2e1e3e0,
			a.m_scalar/((_n2_)), // scalar
			-a.m_e0_e1/((_n2_)), // e0_e1
			-a.m_e0_e2/((_n2_)), // e0_e2
			-a.m_e0_e3/((_n2_)), // e0_e3
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)), // e3_e1
			a.m_e2_e1_e3_e0/((_n2_)) // e2_e1_e3_e0
		);
}
inline bool zero(const vector &a, const double b)
{
	if ((a.m_e1 < -b) || (a.m_e1 > b)) return false;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) return false;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) return false;
	return true;
}
inline bool zero(const bivector &a, const double b)
{
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	return true;
}
inline bool zero(const pseudoscalar &a, const double b)
{
	if ((a.m_e2_e1_e3_e0 < -b) || (a.m_e2_e1_e3_e0 > b)) return false;
	return true;
}
inline bool zero(const rotor &a, const double b)
{
	if ((a.m_scalar < -b) || (a.m_scalar > b)) return false;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	return true;
}
inline bool zero(const line &a, const double b)
{
	if ((a.m_e0_e1 < -b) || (a.m_e0_e1 > b)) return false;
	if ((a.m_e0_e2 < -b) || (a.m_e0_e2 > b)) return false;
	if ((a.m_e0_e3 < -b) || (a.m_e0_e3 > b)) return false;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	return true;
}
inline bool zero(const plane &a, const double b)
{
	if ((a.m_e1_e2_e0 < -b) || (a.m_e1_e2_e0 > b)) return false;
	if ((a.m_e2_e3_e0 < -b) || (a.m_e2_e3_e0 > b)) return false;
	if ((a.m_e3_e1_e0 < -b) || (a.m_e3_e1_e0 > b)) return false;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) return false;
	return true;
}
inline bool zero(const evenVersor &a, const double b)
{
	if ((a.m_scalar < -b) || (a.m_scalar > b)) return false;
	if ((a.m_e0_e1 < -b) || (a.m_e0_e1 > b)) return false;
	if ((a.m_e0_e2 < -b) || (a.m_e0_e2 > b)) return false;
	if ((a.m_e0_e3 < -b) || (a.m_e0_e3 > b)) return false;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	if ((a.m_e2_e1_e3_e0 < -b) || (a.m_e2_e1_e3_e0 > b)) return false;
	return true;
}
inline bool zero(const oddVersor &a, const double b)
{
	if ((a.m_e1 < -b) || (a.m_e1 > b)) return false;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) return false;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) return false;
	if ((a.m_e0 < -b) || (a.m_e0 > b)) return false;
	if ((a.m_e1_e2_e0 < -b) || (a.m_e1_e2_e0 > b)) return false;
	if ((a.m_e2_e3_e0 < -b) || (a.m_e2_e3_e0 > b)) return false;
	if ((a.m_e3_e1_e0 < -b) || (a.m_e3_e1_e0 > b)) return false;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) return false;
	return true;
}
inline bool zero(const e1_t &a, const double b)
{
	if (1.0 > b) return false;
	return true;
}
inline bool zero(const e2_t &a, const double b)
{
	if (1.0 > b) return false;
	return true;
}
inline bool zero(const I4i_t &a, const double b)
{
	if (1.0 > b) return false;
	return true;
}


/** structure used by custom parser */
struct p3gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct p3gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace p3ga
#endif /* _P3GA_H_ */
