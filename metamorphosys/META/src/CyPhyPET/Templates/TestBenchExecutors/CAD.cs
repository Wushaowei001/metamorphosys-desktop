// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 10.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace CyPhyPET.Templates.TestBenchExecutors
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Linq;
    using System.Xml.Linq;
    using System.Collections;
    using System.Collections.Generic;
    using ISIS.GME.Dsml.CyPhyML.Classes;
    
    
    #line 1 "C:\Users\snyako.ISIS\Desktop\META\src\CyPhyPET\Templates\TestBenchExecutors\CAD.tt"
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "10.0.0.0")]
    public partial class CAD : CADBase
    {
        public virtual string TransformText()
        {
            this.Write(" \r\n");
            this.Write(" \r\n");
            this.Write(@"# ===========================================================================
# Auto generated from CAD.tt
# ===========================================================================
""""""
Functions in this file are always called from the TestBench directory. They must
return from that directory (if there is an exception it does not matter).
""""""
import os
import subprocess
import logging
import time
import xml.etree.ElementTree as ET
# Throw this exception for ""expected"" errors.
from driver_runner import TestBenchExecutionError

## Maximum time in seconds to wait for each execution.
MAX_WAIT_TIME = 3600 * ");
            
            #line 33 "C:\Users\snyako.ISIS\Desktop\META\src\CyPhyPET\Templates\TestBenchExecutors\CAD.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(this.MaxIterationExecutionTime));
            
            #line default
            #line hidden
            this.Write("\r\n\r\nclass TestBenchParameter_to_CadAssembly(object):\r\n    \"\"\"\r\n    Class definiti" +
                    "on\r\n\r\n    \"\"\"\r\n    # hard-coded names\r\n    local_cadassembly_name = \'CADAssembly" +
                    ".xml\'\r\n    modified_cadassembly_name = \'CADAssembly.xml\'\r\n\r\n    testbench_manife" +
                    "st_json = \'testbench_manifest.json\'\r\n    testbench_cadparam_json = \'CADParamTest" +
                    "BenchMapping.json\'\r\n    layout_json_name = \'\'\r\n\r\n    # dictionaries\r\n    tbmanif" +
                    "est_param_list = []\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Constructor" +
                    "\r\n\r\n        \"\"\"\r\n        self.logger = logging.getLogger()\r\n        self.tbmanif" +
                    "est_param_list = []\r\n        # paths\r\n        project_root = \'\'\r\n        path_to" +
                    "_stats_folder = \'\'\r\n\r\n    def parse_json(self, file):\r\n        import json\r\n    " +
                    "    parsed_json_dict = {}\r\n        with open(file, \'r\') as f_in:\r\n            pa" +
                    "rsed_json_dict = json.load(f_in)\r\n\r\n        return parsed_json_dict\r\n\r\n    def p" +
                    "opulate_cadparam_values(self):\r\n        instanceguid_param_dict = {}\r\n        tb" +
                    "manifest_dict = self.parse_json(self.testbench_manifest_json)\r\n        if \'Param" +
                    "eters\' in tbmanifest_dict:\r\n            self.tbmanifest_param_list = tbmanifest_" +
                    "dict[\'Parameters\']\r\n            self.logger.info(self.tbmanifest_param_list)\r\n  " +
                    "      cadparam_mapping_list = self.parse_json(self.testbench_cadparam_json)\r\n   " +
                    "     for cadparam in cadparam_mapping_list:\r\n            if \'TestBenchParameterN" +
                    "ame\' in cadparam:\r\n                value = self.find_testbench_param_value(cadpa" +
                    "ram[\'TestBenchParameterName\'])\r\n                if value is not None:\r\n         " +
                    "           if cadparam[\'ComponentInstanceGUID\'] not in instanceguid_param_dict:\r" +
                    "\n                        instanceguid_param_dict[cadparam[\'ComponentInstanceGUID" +
                    "\']] = {}\r\n\r\n                    instanceguid_param_dict[cadparam[\'ComponentInsta" +
                    "nceGUID\']][cadparam[\'ComponentCADParameterName\']] = value\r\n                    s" +
                    "elf.logger.info(\'instanceguid_param_dict : {0}\'.format(instanceguid_param_dict))" +
                    "\r\n\r\n        return instanceguid_param_dict\r\n\r\n    def find_testbench_param_value" +
                    "(self, param_name):\r\n        value = None\r\n        for param in self.tbmanifest_" +
                    "param_list:\r\n            if param[\'Name\'] == param_name:\r\n                value " +
                    "= param[\'Value\']\r\n\r\n        return value\r\n\r\n    def modify_cad_assembly_file(sel" +
                    "f, statusfile):\r\n        import xml.etree.ElementTree as ET\r\n        tree = ET.p" +
                    "arse(self.local_cadassembly_name)\r\n        root = tree.getroot()\r\n\r\n        inst" +
                    "anceguid_param_dict = self.populate_cadparam_values()\r\n        # find Component " +
                    "under <Assemblies><Assembly>\r\n        for ass_elem in tree.iter(tag=\'Assembly\'):" +
                    "\r\n            for cc_parent in ass_elem.findall(\'CADComponent\'):\r\n              " +
                    "  self.logger.debug(\'Found a parent component in CADAssembly.xml [\' + str(cc_par" +
                    "ent.attrib[\'DisplayName\']) + \']\')\r\n                for cc in cc_parent.findall(\'" +
                    "CADComponent\'):\r\n                    self.logger.debug(\'Found a component in CAD" +
                    "Assembly.xml [\' + str(cc.attrib[\'DisplayName\']) + \']\')\r\n                    if c" +
                    "c.attrib[\'ComponentID\'] in instanceguid_param_dict:\r\n                        gui" +
                    "d = cc.attrib[\'ComponentID\']\r\n                        cadparam_dict_src = instan" +
                    "ceguid_param_dict[guid]\r\n                        # recurse Found Element Compone" +
                    "nt to find CADParameters\r\n                        for pp in cc.findall(\'Parametr" +
                    "icParameters\'):\r\n                            for cp in pp.findall(\'CADParameter\'" +
                    "):\r\n                                if cp.get(\'Name\') in cadparam_dict_src:\r\n   " +
                    "                                 cp.set(\'Value\', str(cadparam_dict_src[cp.get(\'N" +
                    "ame\')]))\r\n                                    statusfile.write(\'Replaced in XML " +
                    "[%s:%s:%s]\\n\' % (guid, cp.get(\'Name\'), str(cadparam_dict_src[cp.get(\'Name\')])))\r" +
                    "\n\r\n            tree.write(self.modified_cadassembly_name)\r\n            self.logg" +
                    "er.debug(\'end\')\r\n\r\n\r\ndef initial_run():\r\n    \"\"\"\r\n    Setup whatever needs to be" +
                    " setup once. Then execute a run once using the default parameters\r\n    in testbe" +
                    "nch_manifest.json. (These and their metrics will be saved and used in the final\r" +
                    "\n    testbench_manifest.json.\r\n    \"\"\"\r\n    log = logging.getLogger()\r\n    log.i" +
                    "nfo(\'Running initial run, calling execute.\')\r\n    execute()\r\n\r\n\r\ndef update_para" +
                    "meters(parameters):\r\n    \"\"\"\r\n    Update parameters for the run. (The parameters" +
                    " are already updated in testbench_manifest.json.)\r\n    :type parameters: dict\r\n " +
                    "   :param parameters: keys are name of Parameter and value is float.\r\n    \"\"\"\r\n " +
                    "   log = logging.getLogger()\r\n    log.info(\'About to update parameters in CADAss" +
                    "embly.xml.\')\r\n    ltc = TestBenchParameter_to_CadAssembly()\r\n    with open(\'CADP" +
                    "aramTestBenchMapping.log\', \'w\') as statusfile:\r\n        ltc.modify_cad_assembly_" +
                    "file(statusfile)\r\n\r\n    log.info(\'Wrote back to CADAssembly.xml\')\r\n\r\n\r\ndef execu" +
                    "te():\r\n    \"\"\"\r\n    Execute the test-bench. A call to this function should updat" +
                    "e the metrics in the testbench_manifest.json.\r\n    :rtype: dict or None\r\n    :re" +
                    "turn: Dictionary with metrics names and values if testbench_manifest.json is not" +
                    " updated, else None.\r\n    \"\"\"\r\n    log = logging.getLogger()\r\n    cad_bat = \'run" +
                    "CADJob.bat\'\r\n    out_put_file = \'PET_run.txt\'\r\n\r\n    if os.path.isfile(out_put_f" +
                    "ile):\r\n        os.remove(out_put_file)\r\n\r\n    log.info(\'About to call :: {}\'.for" +
                    "mat(os.path.abspath(cad_bat)))\r\n    was_killed = False\r\n    with open(out_put_fi" +
                    "le, \'w\') as f_out:\r\n        timer = 0\r\n        sim_process = subprocess.Popen(ca" +
                    "d_bat, stdout=f_out, stderr=f_out)\r\n        while sim_process.poll() is None:\r\n " +
                    "           time.sleep(0.1)\r\n            timer += 0.1\r\n        if timer > MAX_WAI" +
                    "T_TIME:\r\n            sim_process.kill()\r\n            f_out.write(\'runCADJob.bat " +
                    "exceeded MAX_WAIT_TIME = {0} (seconds).\'.format(MAX_WAIT_TIME))\r\n            was" +
                    "_killed = True\r\n\r\n    with open(out_put_file, \'r\') as f_in:\r\n        out_put = \'" +
                    "\'.join(f_in.readlines())\r\n    if was_killed:\r\n        raise TestBenchExecutionEr" +
                    "ror(out_put)\r\n    else:\r\n        log.debug(out_put)\r\n        log.info(\'Successfu" +
                    "l {} run!\'.format(cad_bat))\r\n\r\n    return None\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }
        
        #line 185 "C:\Users\snyako.ISIS\Desktop\META\src\CyPhyPET\Templates\TestBenchExecutors\CAD.tt"
 
public int MaxIterationExecutionTime {get;set;}
 
        
        #line default
        #line hidden
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "10.0.0.0")]
    public class CADBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
